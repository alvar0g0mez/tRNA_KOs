Nt_at_17 = Nt_at_17_1 == Nt_at_17_2,
Nt_at_18 = Nt_at_18_1 == Nt_at_18_2,
Nt_at_19 = Nt_at_19_1 == Nt_at_19_2,
Nt_at_20 = Nt_at_20_1 == Nt_at_30_2,
Nt_at_21 = Nt_at_21_1 == Nt_at_21_2,
Nt_at_22 = Nt_at_22_1 == Nt_at_22_2,
Nt_at_23 = Nt_at_23_1 == Nt_at_23_2,
Nt_at_24 = Nt_at_24_1 == Nt_at_24_2,
Nt_at_25 = Nt_at_25_1 == Nt_at_25_2,
Nt_at_26 = Nt_at_26_1 == Nt_at_26_2,
Nt_at_27 = Nt_at_27_1 == Nt_at_27_2,
Nt_at_28 = Nt_at_28_1 == Nt_at_28_2,
Nt_at_29 = Nt_at_29_1 == Nt_at_29_2,
Nt_at_30 = Nt_at_30_1 == Nt_at_30_2,
Nt_at_31 = Nt_at_31_1 == Nt_at_31_2,
Nt_at_32 = Nt_at_32_1 == Nt_at_32_2,
Nt_at_33 = Nt_at_33_1 == Nt_at_33_2,
Nt_at_34 = Nt_at_34_1 == Nt_at_34_2,
Nt_at_35 = Nt_at_35_1 == Nt_at_35_2,
Nt_at_36 = Nt_at_36_1 == Nt_at_36_2,
Nt_at_37 = Nt_at_37_1 == Nt_at_37_2,
Nt_at_38 = Nt_at_38_1 == Nt_at_38_2,
Nt_at_39 = Nt_at_39_1 == Nt_at_39_2,
Nt_at_40 = Nt_at_40_1 == Nt_at_40_2,
Nt_at_41 = Nt_at_41_1 == Nt_at_41_2,
Nt_at_42 = Nt_at_42_1 == Nt_at_42_2,
Nt_at_43 = Nt_at_43_1 == Nt_at_43_2,
Nt_at_44 = Nt_at_44_1 == Nt_at_44_2,
Nt_at_45 = Nt_at_45_1 == Nt_at_45_2,
Nt_at_46 = Nt_at_46_1 == Nt_at_46_2,
Nt_at_47 = Nt_at_47_1 == Nt_at_47_2,
Nt_at_48 = Nt_at_48_1 == Nt_at_48_2,
Nt_at_49 = Nt_at_49_1 == Nt_at_49_2,
Nt_at_50 = Nt_at_50_1 == Nt_at_50_2,
Nt_at_51 = Nt_at_51_1 == Nt_at_51_2,
Nt_at_52 = Nt_at_52_1 == Nt_at_52_2,
Nt_at_53 = Nt_at_53_1 == Nt_at_53_2,
Nt_at_54 = Nt_at_54_1 == Nt_at_54_2,
Nt_at_55 = Nt_at_55_1 == Nt_at_55_2,
Nt_at_56 = Nt_at_56_1 == Nt_at_56_2,
Nt_at_57 = Nt_at_57_1 == Nt_at_57_2,
Nt_at_58 = Nt_at_58_1 == Nt_at_58_2,
Nt_at_59 = Nt_at_59_1 == Nt_at_59_2,
Nt_at_60 = Nt_at_60_1 == Nt_at_60_2,
Nt_at_61 = Nt_at_61_1 == Nt_at_61_2,
Nt_at_62 = Nt_at_62_1 == Nt_at_62_2,
Nt_at_63 = Nt_at_63_1 == Nt_at_63_2,
Nt_at_64 = Nt_at_64_1 == Nt_at_64_2,
Nt_at_65 = Nt_at_65_1 == Nt_at_65_2,
Nt_at_66 = Nt_at_66_1 == Nt_at_66_2,
Nt_at_67 = Nt_at_67_1 == Nt_at_67_2,
Nt_at_68 = Nt_at_68_1 == Nt_at_68_2,
Nt_at_69 = Nt_at_69_1 == Nt_at_69_2,
Nt_at_70 = Nt_at_70_1 == Nt_at_70_2) %>%
dplyr::select(-c(Nt_at_1_1, Nt_at_1_2, Nt_at_2_1, Nt_at_2_2, Nt_at_3_1, Nt_at_3_2, Nt_at_4_1, Nt_at_4_2, Nt_at_5_1, Nt_at_5_2, Nt_at_6_1, Nt_at_6_2, Nt_at_7_1, Nt_at_7_2, Nt_at_8_1, Nt_at_8_2, Nt_at_9_1, Nt_at_9_2, Nt_at_10_1, Nt_at_10_2, Nt_at_11_1, Nt_at_11_2, Nt_at_12_1, Nt_at_12_2, Nt_at_13_1, Nt_at_13_2, Nt_at_14_1, Nt_at_14_2, Nt_at_15_1, Nt_at_15_2, Nt_at_16_1, Nt_at_16_2, Nt_at_17_1, Nt_at_17_2, Nt_at_18_1, Nt_at_18_2, Nt_at_19_1, Nt_at_19_2, Nt_at_20_1, Nt_at_20_2, Nt_at_21_1, Nt_at_21_2, Nt_at_22_1, Nt_at_22_2, Nt_at_23_1, Nt_at_23_2, Nt_at_24_1, Nt_at_24_2, Nt_at_25_1, Nt_at_25_2, Nt_at_26_1, Nt_at_26_2, Nt_at_27_1, Nt_at_27_2, Nt_at_28_1, Nt_at_28_2, Nt_at_29_1, Nt_at_29_2, Nt_at_30_1, Nt_at_30_2, Nt_at_31_1, Nt_at_31_2, Nt_at_32_1, Nt_at_32_2, Nt_at_33_1, Nt_at_33_2, Nt_at_34_1, Nt_at_34_2, Nt_at_35_1, Nt_at_35_2, Nt_at_36_1, Nt_at_36_2, Nt_at_37_1, Nt_at_37_2, Nt_at_38_1, Nt_at_38_2, Nt_at_39_1, Nt_at_39_2, Nt_at_40_1, Nt_at_40_2, Nt_at_41_1, Nt_at_41_2, Nt_at_42_1, Nt_at_42_2, Nt_at_43_1, Nt_at_43_2, Nt_at_44_1, Nt_at_44_2, Nt_at_45_1, Nt_at_45_2, Nt_at_46_1, Nt_at_46_2, Nt_at_47_1, Nt_at_47_2, Nt_at_48_1, Nt_at_48_2, Nt_at_49_1, Nt_at_49_2, Nt_at_50_1, Nt_at_50_2, Nt_at_51_1, Nt_at_51_2, Nt_at_52_1, Nt_at_52_2, Nt_at_53_1, Nt_at_53_2, Nt_at_54_1, Nt_at_54_2, Nt_at_55_1, Nt_at_55_2, Nt_at_56_1, Nt_at_56_2, Nt_at_57_1, Nt_at_57_2, Nt_at_58_1, Nt_at_58_2, Nt_at_59_1, Nt_at_59_2, Nt_at_60_1, Nt_at_60_2, Nt_at_61_1, Nt_at_61_2, Nt_at_62_1, Nt_at_62_2, Nt_at_63_1, Nt_at_63_2, Nt_at_64_1, Nt_at_64_2, Nt_at_65_1, Nt_at_65_2, Nt_at_66_1, Nt_at_66_2, Nt_at_67_1, Nt_at_67_2, Nt_at_68_1, Nt_at_68_2, Nt_at_69_1, Nt_at_69_2, Nt_at_70_1, Nt_at_70_2))
# Get columns based on strain_1 and strain_2, but which reorganize this: the one with more DEPs to one column, the one with less DEPs to the other
# Just so that I can check the overlap_size/amount of DEPs in the KO strain with less out of the pair. Not sure if too important but oh well
DE_protein_overlaps <- DE_protein_overlaps %>%
rowwise() %>%
mutate(Strain_more_DEPs = max(protein_number_1, protein_number_2),
Strain_less_DEPs = min(protein_number_1, protein_number_2),
Ratio_more_to_less_DEPs = Strain_more_DEPs/Strain_less_DEPs)
# Add columns where I combine the strings for the anticodons and amino acids for the 2 strains (always using sort() before so that they are unique)
DE_protein_overlaps <- DE_protein_overlaps %>%
rowwise() %>%
mutate(both_anticodons = paste(sort(c(anticodon_1, anticodon_2)), collapse = "-"),
both_amino_acids = paste(sort(c(Amino_acid_1, Amino_acid_2)), collapse = "-"),
both_aa_types = paste(sort(c(aa_type_1, aa_type_2)), collapse = "-"),
both_aa_charges = paste(sort(c(aa_charge_1, aa_charge_2)), collapse = "-"))
# Put columns with protein names as the last ones
DE_protein_overlaps <- DE_protein_overlaps %>%
relocate(protein_names_1, .after = last_col()) %>%
relocate(protein_names_2, .after = last_col()) %>%
relocate(overlap, .after = last_col())
fwrite(DE_protein_overlaps, paste(base_dir, "tRNA_KOs/Data/compare_DEPs_across_KOs/DE_protein_overlaps_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".tsv", sep=""))
# Load protein overlaps dataset created in previous section, with all possible intersections
DE_protein_overlaps <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/compare_DEPs_across_KOs/DE_protein_overlaps_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".tsv", sep="")))
# Master dataset
master_dataset <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/basic/master_tRNA_dataset.csv", sep = "")))
# This is what happens if I filter based on major - minor (defined by me)
DE_protein_overlaps_major_within_family <- DE_protein_overlaps %>%
filter(anticodon_1 == anticodon_2,
Gene_type_1 == "Major" & Gene_type_2 == "Major")
# Get a version of this which I can screenshot for a slide
temp <- DE_protein_overlaps_major_within_family %>%
dplyr::select(strains_1, strains_2, protein_number_1, protein_number_2, overlap_size, Jaccard_index)
# Grab the strains in here and put them into a vector so I can filter the EA results by them
paired_major_strains <- sort(unique(c(as.character(DE_protein_overlaps_major_within_family$strains_1), as.character(DE_protein_overlaps_major_within_family$strains_2))))
# Load GO EA results - this one doesn't work recently because I haven't been running the GO analysis! Only the GSEA, with both GO and KEGG annotations
go_results_list <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_results_list_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), simplifyVector = T)
N <- 10
# Load the GO GSEA results produced in that file
go_gsea_results <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), simplifyVector = T)
knitr::opts_chunk$set(echo = TRUE)
library(clusterProfiler)
library(org.Sc.sgd.db)
library(data.table)
library(dplyr)
library(fgsea)
library(ggplot2)
library(jsonlite)
library(stringr)
library(forcats)
library(GO.db)
library(biomaRt)
# Significance level used for defining proteins as DE
alpha <- 0.05
# Significance level above as a plain string to use when loading or writing files
alpha_plain <- str_replace(as.character(alpha), "\\.", "")
# Separate significance level, the one used for the enrichment analysis
alpha_enrichment <- 0.1
# Significance level above as a plain string to use when loading or writing files
alpha_enrichment_plain <- str_replace(as.character(alpha_enrichment), "\\.", "")
# Log-fold change limit to be considered "biologically significant"
lfc_threshold <- 0.5
# Number of nDEP from which a tRNA is considered "major" (this threshold value should be included) - THIS I AM NOT USING ANYMORE, AM I?
threshold_major <- 2
# Set directories to be used
working_from = "charite"
if (working_from == "home") {
base_dir = "/home/alvaro/MyStuff/"
} else
if (working_from == "charite") {
base_dir = "C:/MyStuff/"
}
# List of dataframes with the proteins that were DE in each KO strain - remove emtpy vectors
de_proteins_list <- fromJSON(paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/de_proteins_list_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), )
de_proteins_list <- Filter(function(x) length(x) > 0, de_proteins_list)
# Full Entrez ID dataframe, with all genes
entrez_db <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/entrez_reference.txt", sep="")))
# Load the dataset with that information
master_dataset <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/basic/master_tRNA_dataset.csv", sep="")))
# Phenotypic data from Bloom-Ackermann et al., 2014
phenotypic_data <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/Articles/bloom_ackermann_2014/phenotypic_results_full.tsv", sep="")))
source(paste(base_dir, "tRNA_KOs/Code/R/Mine/0.general_use_functions.R", sep=""))
# Load list of all dataframes (one per strain) wiht the DE results
da <- read_json(paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/da_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), simplifyVector = T)
da <- da[names(da) != "WT"]
# Create empty list to put the named ranked gene lists in
ranked_genes <- list()
number_of_proteins_with_no_Entrez_ID <- c()
# Iterate over these dataframes
for (i in 1:length(da)) {
temp <- da[[i]]
# Get the corresponding Entrez IDs to these systematic gene names, since the GSEA is performed in terms of those
temp$Protein_stable_ID <- rownames(temp)
entrez_temp <- entrez_db %>%
dplyr::select(Protein_stable_ID, `NCBI_gene_(formerly_Entrezgene)_ID`)
temp <- left_join(temp, entrez_temp, by = "Protein_stable_ID")
rownames(temp) <- NULL
temp <- temp %>%
dplyr::select(logFC, adj.P.Val, `NCBI_gene_(formerly_Entrezgene)_ID`) %>%
dplyr::rename(gene_symbol = `NCBI_gene_(formerly_Entrezgene)_ID`)
# Get rid of the proteins for which we don't have the Entrez ID (and save the count of how many of them there are, to check it's not too many) - otherwise GSEA doesn't work
number_of_proteins_with_no_Entrez_ID <- c(number_of_proteins_with_no_Entrez_ID, sum(is.na(temp$gene_symbol)))
temp <- temp %>%
dplyr::filter(!is.na(gene_symbol))
# Using as score the -log10(p-value)*sign of the logFC
rankings <- sign(temp$logFC)*(-log10(temp$adj.P.Val))
names(rankings) <- temp$gene_symbol
rankings <- sort(rankings, decreasing = TRUE)
# Plot
plot(rankings)
# Check max and min - to see if there is a need to correct for -Inf and +Inf - commented out, I don't think it's necessary
#print(max(rankings))
#print(min(rankings))
# Some genes have such low p values that the signed pval is +- inf, we need to change it to the maximum * constant to avoid problems with fgsea
# (this part is copy pasted from the link)
max_ranking <- max(rankings[is.finite(rankings)])
min_ranking <- min(rankings[is.finite(rankings)])
rankings <- replace(rankings, rankings > max_ranking, max_ranking * 10)
rankings <- replace(rankings, rankings < min_ranking, min_ranking * 10)
rankings <- sort(rankings, decreasing = TRUE) # sort genes by ranking
# Add them to the list where we are saving them
ranked_genes[[names(da)[i]]] <- rankings
}
# Save this ranked lists so that I can use them later to pick the top 50 proteins in each strain, to look at the overlaps between major strains within families in a more unbiased manner - not really feasible for now since the distribution of the scores for the vast majority of strains is pretty much flat. I wonder how much this affects my DEA?
write_json(ranked_genes, path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/lists_of_ranked_genes_", alpha_plain, "_logFC_", as.character(lfc_threshold), sep=""),
pretty = T)
# Read in the .gmt file
gmt <- read.gmt(paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/20250305_kegg_sce_gmt", sep=""))
gmt$term <- as.character(gmt$term)
# Get a simple vector with the Entrez IDs of the proteins we detect
trna_ko <- as.data.frame(as.matrix(fread(paste(base_dir, "tRNA_KOs/Data/proteomics_data/processed_proteomics_dataframe.tsv", sep="")), rownames = 1))
yeastmine <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))
proteins_detected <- match_systematic_and_standard_protein_names(data = rownames(trna_ko),
yeastmine = yeastmine,
input = "standard",
simplify = T)
proteins_detected <- entrez_db$`NCBI_gene_(formerly_Entrezgene)_ID`[entrez_db$Protein_stable_ID %in% proteins_detected]
# Get our list of vectors, where each vector is a KEGG pathway and the terms in it are the genes related to it - keeping only genes which are detected in our dataset
gmt <- gmt %>%
mutate(pathway_code = substr(term, 1, str_locate(term, "_")[1]-1),
pathway_name = substr(term, str_locate(term, "_")[1]+1, nchar(term)))
kegg_genes <- list()
pathways <- unique(gmt$pathway_name)
for (i in 1:length(pathways)) {
pathway <- pathways[i]
temp <- gmt %>%
filter(pathway_name == pathway)
kegg_genes[[pathway]] <- as.character(temp$gene)[as.character(temp$gene) %in% proteins_detected]
}
kegg_gsea_results <- list()
for (i in 1:length(ranked_genes)) {
kegg_gsea_results[[names(ranked_genes)[i]]] <- fgsea(pathways = kegg_genes,                                # List of gene sets to check
stats = ranked_genes[[i]],
scoreType = 'std',
# in this case we have both pos and neg rankings. if only pos or neg, set to 'pos', 'neg'
minSize = 1,
maxSize = 1000,
nproc = 1)                                             # for parallelisation
}
# This returns a list, where each element is a dataframe for the corresponding KO strain, and each row in that dataframe is a pathway. However, all pathways are included, so we are going to filter all of these dataframes to keep only the pathways that are significant in each KO strain
kegg_gsea_results_filtered <- lapply(kegg_gsea_results, function(x) filter(x, padj < alpha_enrichment))
bool <- sapply(kegg_gsea_results_filtered, function(x) nrow(x)>0)
kegg_gsea_results_filtered <- kegg_gsea_results_filtered[bool]
# Save these results
write_json(kegg_gsea_results_filtered, paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/kegg_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), pretty = T)
View(responsiveness)
# Step 1: Connect to Ensembl Fungi
ensembl_fungi <- useMart("fungi_mart", dataset = "scerevisiae_eg_gene", host = "https://fungi.ensembl.org")
# Step 2: Retrieve GO annotations
go_annotations <- getBM(attributes = c("ensembl_gene_id", "external_gene_name",
"go_id", "name_1006", "namespace_1003", "entrezgene_id"),
mart = ensembl_fungi)
# This is added by me
trna_ko <- as.data.frame(as.matrix(fread(paste(base_dir, "tRNA_KOs/Data/proteomics_data/processed_proteomics_dataframe.tsv", sep="")), rownames = 1))
go_annotations <- go_annotations %>%
dplyr::filter(namespace_1003 != "go") %>%                                     # Pretty sure these rows are just wrong, or at least not useful to me
dplyr::filter(ensembl_gene_id %in% rownames(trna_ko)) %>%                     # Keep only those genes which are detected in our data, so as to prevent bias
dplyr::mutate(gene_set = case_when(namespace_1003 == "molecular_function" ~ paste(name_1006, " (MF)", sep=""),
namespace_1003 == "biological_process" ~ paste(name_1006, " (BP)", sep=""),
namespace_1003 == "cellular_component" ~ paste(name_1006, " (CC)", sep="")))
# Check the first few rows
head(go_annotations)
# Step 3: Filter for Biological Process (BP) only - not interested in using this for now
go_annotations <- go_annotations %>%
#filter(namespace_1003 == "biological_process") %>%
filter(go_id != "")  # Remove any empty GO terms if present
# Step 4: Build a list: GO Term -> Genes
# Use external_gene_name (common names) or ensembl_gene_id (your choice)
go_list <- split(go_annotations$entrezgene_id, go_annotations$gene_set)
# Step 5: Save this named list of vectors as a JSON file
write_json(go_list, path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_list_gmt.json", sep=""), pretty = T)
# Read in the .json file
go_gene_sets <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_list_gmt.json", sep=""), simplifyVector = T)
go_gsea_results <- list()
for (i in 1:length(ranked_genes)) {
go_gsea_results[[names(ranked_genes)[i]]] <- fgsea(pathways = go_gene_sets,                                # List of gene sets to check
stats = ranked_genes[[i]],
scoreType = 'std',
# in this case we have both pos and neg rankings. if only pos or neg, set to 'pos', 'neg'
minSize = 1,
maxSize = 1000,
nproc = 1)                                             # for parallelisation
}
# This returns a list, where each element is a dataframe for the corresponding KO strain, and each row in that dataframe is a pathway. However, all pathways are included, so we are going to filter all of these dataframes to keep only the pathways that are significant in each KO strain
go_gsea_results_filtered <- lapply(go_gsea_results, function(x) filter(x, padj < alpha_enrichment))
bool <- sapply(go_gsea_results_filtered, function(x) nrow(x)>0)
go_gsea_results_filtered <- go_gsea_results_filtered[bool]
# Save these results
write_json(go_gsea_results_filtered, paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), pretty = T)
N <- 10
# Load the GO GSEA results produced in that file
go_gsea_results <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), simplifyVector = T)
# For GO GSEA results
## Get the unique codons to iterate over
codons <- unique(sapply(names(go_gsea_results), extract_anticodon_from_trna_name))
# Iterate over codons and create a table for each pair of KOs (for those anticodons for which we have more than 1 KO)
for (i in 1:length(codons)) {
codon <- codons[i]
temp_go_gsea_results <- go_gsea_results[grepl(codon, names(go_gsea_results))]
print(names(temp_go_gsea_results))
# Proceed only if there are GSEA results for at least 2 KOs with this anticodon, and if at least 2 of them are major
if ((length(temp_go_gsea_results) > 1) & sum(names(temp_go_gsea_results) %in% paired_major_strains) > 1) {
temp_list <- list()
temp_go_gsea_results <- temp_go_gsea_results[names(temp_go_gsea_results) %in% paired_major_strains]    # Remove the non-major subunits
for (j in 1:length(temp_go_gsea_results)) {
temp_go_gsea_results[[j]] <- temp_go_gsea_results[[j]][order(temp_go_gsea_results[[j]]$padj),]       # Order by increasing p-adj
temp_go_gsea_results[[j]] <- temp_go_gsea_results[[j]][1:N,]                                         # Grab only the first N pathways
temp_list[[names(temp_go_gsea_results)[j]]] <- sort(temp_go_gsea_results[[j]]$pathway)               # Grab the pathway names and order there them                                                                                                                     alphabetically, which makes it easier to compare them                                                                                                             between KO strains
}
out_df <- data.frame(matrix(ncol = 0, nrow = max(sapply(temp_list, length))))
for (j in 1:length(temp_list)) {
new_col <- temp_list[[j]]
if (length(new_col) == max(sapply(temp_list, length))) {
out_df[,j] <- new_col
} else {
out_df[,j] <- c(new_col, rep(NA, max(sapply(temp_list, length))-length(new_col)))
}
}
colnames(out_df) <- names(temp_list)
print(xtable(out_df), include.rownames=FALSE)
}
}
N <- 10
# Load the GO GSEA results produced in that file
go_gsea_results <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), simplifyVector = T)
# For GO GSEA results
## Get the unique codons to iterate over
codons <- unique(sapply(names(go_gsea_results), extract_anticodon_from_trna_name))
# Iterate over codons and create a table for each pair of KOs (for those anticodons for which we have more than 1 KO)
for (i in 1:length(codons)) {
codon <- codons[i]
temp_go_gsea_results <- go_gsea_results[grepl(codon, names(go_gsea_results))]
# Proceed only if there are GSEA results for at least 2 KOs with this anticodon, and if at least 2 of them are major
if ((length(temp_go_gsea_results) > 1) & sum(names(temp_go_gsea_results) %in% paired_major_strains) > 1) {
temp_list <- list()
temp_go_gsea_results <- temp_go_gsea_results[names(temp_go_gsea_results) %in% paired_major_strains]    # Remove the non-major subunits
for (j in 1:length(temp_go_gsea_results)) {
temp_go_gsea_results[[j]] <- temp_go_gsea_results[[j]][order(temp_go_gsea_results[[j]]$padj),]       # Order by increasing p-adj
temp_go_gsea_results[[j]] <- temp_go_gsea_results[[j]][1:N,]                                         # Grab only the first N pathways
temp_list[[names(temp_go_gsea_results)[j]]] <- sort(temp_go_gsea_results[[j]]$pathway)               # Grab the pathway names and order there them                                                                                                                     alphabetically, which makes it easier to compare them                                                                                                             between KO strains
}
out_df <- data.frame(matrix(ncol = 0, nrow = max(sapply(temp_list, length))))
for (j in 1:length(temp_list)) {
new_col <- temp_list[[j]]
if (length(new_col) == max(sapply(temp_list, length))) {
out_df[,j] <- new_col
} else {
out_df[,j] <- c(new_col, rep(NA, max(sapply(temp_list, length))-length(new_col)))
}
}
colnames(out_df) <- names(temp_list)
print(xtable(out_df), include.rownames=FALSE)
}
}
View(DE_protein_overlaps_major_within_family)
N <- 10
# Load the GO GSEA results produced in that file
kegg_gsea_results <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/kegg_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), simplifyVector = T)
# For GO GSEA results
## Get the unique codons to iterate over
codons <- unique(sapply(names(kegg_gsea_results), extract_anticodon_from_trna_name))
# Iterate over codons and create a table for each pair of KOs (for those anticodons for which we have more than 1 KO)
for (i in 1:length(codons)) {
codon <- codons[i]
temp_kegg_gsea_results <- kegg_gsea_results[grepl(codon, names(kegg_gsea_results))]
print(names(temp_kegg_gsea_results))
# Proceed only if there are GSEA results for at least 2 KOs with this anticodon, and if at least 2 of them are major
if ((length(temp_kegg_gsea_results) > 1) & sum(names(temp_kegg_gsea_results) %in% paired_major_strains) > 1) {
temp_list <- list()
temp_kegg_gsea_results <- temp_kegg_gsea_results[names(temp_kegg_gsea_results) %in% paired_major_strains]    # Remove the non-major subunits
for (j in 1:length(temp_kegg_gsea_results)) {
temp_kegg_gsea_results[[j]] <- temp_kegg_gsea_results[[j]][order(temp_kegg_gsea_results[[j]]$padj),]       # Order by increasing p-adj
temp_kegg_gsea_results[[j]] <- temp_kegg_gsea_results[[j]][1:N,]                                         # Grab only the first N pathways
temp_list[[names(temp_kegg_gsea_results)[j]]] <- sort(temp_kegg_gsea_results[[j]]$pathway)               # Grab the pathway names and order there them                                                                                                                     alphabetically, which makes it easier to compare them                                                                                                             between KO strains
}
out_df <- data.frame(matrix(ncol = 0, nrow = max(sapply(temp_list, length))))
for (j in 1:length(temp_list)) {
new_col <- temp_list[[j]]
if (length(new_col) == max(sapply(temp_list, length))) {
out_df[,j] <- new_col
} else {
out_df[,j] <- c(new_col, rep(NA, max(sapply(temp_list, length))-length(new_col)))
}
}
colnames(out_df) <- names(temp_list)
print(xtable(out_df), include.rownames=FALSE)
}
}
N <- 10
# Load the GO GSEA results produced in that file
kegg_gsea_results <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/kegg_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), simplifyVector = T)
# For GO GSEA results
## Get the unique codons to iterate over
codons <- unique(sapply(names(kegg_gsea_results), extract_anticodon_from_trna_name))
# Iterate over codons and create a table for each pair of KOs (for those anticodons for which we have more than 1 KO)
for (i in 1:length(codons)) {
codon <- codons[i]
temp_kegg_gsea_results <- kegg_gsea_results[grepl(codon, names(kegg_gsea_results))]
# Proceed only if there are GSEA results for at least 2 KOs with this anticodon, and if at least 2 of them are major
if ((length(temp_kegg_gsea_results) > 1) & sum(names(temp_kegg_gsea_results) %in% paired_major_strains) > 1) {
temp_list <- list()
temp_kegg_gsea_results <- temp_kegg_gsea_results[names(temp_kegg_gsea_results) %in% paired_major_strains]    # Remove the non-major subunits
for (j in 1:length(temp_kegg_gsea_results)) {
temp_kegg_gsea_results[[j]] <- temp_kegg_gsea_results[[j]][order(temp_kegg_gsea_results[[j]]$padj),]       # Order by increasing p-adj
temp_kegg_gsea_results[[j]] <- temp_kegg_gsea_results[[j]][1:N,]                                         # Grab only the first N pathways
temp_list[[names(temp_kegg_gsea_results)[j]]] <- sort(temp_kegg_gsea_results[[j]]$pathway)               # Grab the pathway names and order there them                                                                                                                     alphabetically, which makes it easier to compare them                                                                                                             between KO strains
}
out_df <- data.frame(matrix(ncol = 0, nrow = max(sapply(temp_list, length))))
for (j in 1:length(temp_list)) {
new_col <- temp_list[[j]]
if (length(new_col) == max(sapply(temp_list, length))) {
out_df[,j] <- new_col
} else {
out_df[,j] <- c(new_col, rep(NA, max(sapply(temp_list, length))-length(new_col)))
}
}
colnames(out_df) <- names(temp_list)
print(xtable(out_df), include.rownames=FALSE)
}
}
View(master_dataset)
View(go_gsea_results_filtered)
go_gsea_results_filtered[["tA(AGC)M1"]][["pathway"]]
cat(go_gsea_results_filtered[["tA(AGC)M1"]][["pathway"]], sep =", ")
cat(go_gsea_results_filtered[["tA(AGC)M2"]][["pathway"]], sep=",")
cat(go_gsea_results_filtered[["tN(GUU)C"]][["pathway"]], sep="")
cat(go_gsea_results_filtered[["tN(GUU)O2"]][["pathway"]], sep="")
View(master_dataset)
# Basic volcano plot - FC vs. -log10(adj.p-value) - tag only significant p-values and FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total))) +
geom_point() +
geom_hline(yintercept = -log10(0.05), col = "red") +
geom_vline(xintercept = 0.5, col = "red") +
geom_vline(xintercept = -0.5, col = "red") +
theme_light() +
geom_text_repel(data = subset(test_codon_enrichment, (((logFC_total > 0.5 | logFC_total < -0.5) &
-log10(p.values.adj_total) > -log10(0.05)))|-log10(p.values.adj_total) > -log10(0.05)),
aes(x = logFC_total, y = -log10(p.values.adj_total), label = Strain.Name)) +
xlab("logFC") +
ylab("-log10(p-value)") +
labs(title = "Testing results for codon proportion in DE vs. non-DE proteins",
subtitle = "Each dot represents a strain")
# Basic volcano plot - FC vs. -log10(adj.p-value) - tag only significant p-values and FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total))) +
geom_point() +
geom_hline(yintercept = -log10(0.05), col = "red") +
geom_vline(xintercept = 0.5, col = "red") +
geom_vline(xintercept = -0.5, col = "red") +
theme_light() +
geom_text_repel(data = subset(test_codon_enrichment, (((logFC_total > 0.5 | logFC_total < -0.5) &
-log10(p.values.adj_total) > -log10(0.05)))|-log10(p.values.adj_total) > -log10(0.05)),
aes(x = logFC_total, y = -log10(p.values.adj_total), label = Strain.Name)) +
xlab("logFC") +
ylab("-log10(p-value)") +
labs(title = "Testing results for target codon proportion in DE vs. non-DE proteins",
subtitle = "Each dot represents a strain")
View(sample_layout)
View(responsiveness)
ggplot(data = responsiveness, aes(x = Strain.Name, y = nDEP, fill = Amino_acid_1_letter)) +
geom_col() +
theme_light() +
theme(axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.title = element_text(size=9),
legend.key.size = unit(0.5, 'cm')) +
xlab("KO strain") +
labs(fill = "Amino acid")
ggplot(data = responsiveness, aes(x = nDEP)) +
geom_density(fill="#77bd89",
color="#1f6e34",
alpha=0.8,
linewidth = 1) +
theme_light()
ggplot(data = responsiveness, aes(x = Amino_acid_1_letter, y = nDEP, fill = Amino_acid_1_letter)) +
geom_boxplot() +
theme_light() +
labs(fill = "Amino acid",
title = 'tRNA KOs Responsiveness per AA',
subtitle = 'Number of Differentially Expressed Proteins (DEPs)') +
xlab("Amino acid") +
theme(legend.title = element_text(size=9),
legend.key.size = unit(0.5, 'cm'))
ggplot(data = responsiveness, aes(x = Amino_acid_1_letter, y = nDEP, fill = Amino_acid_1_letter)) +
geom_boxplot(outliers = F) +
geom_jitter() +
theme_light() +
labs(fill = "Amino acid",
title = 'tRNA KOs Responsiveness per AA',
subtitle = 'Number of Differentially Expressed Proteins (DEPs) - truncated < 100 nDEP') +
xlab("Amino acid") +
theme(legend.title = element_text(size=9),
legend.key.size = unit(0.5, 'cm')) +
coord_cartesian(ylim = c(0, 100))
ggplot(data = responsiveness, aes(x = chromosome_letter, y = nDEP, fill = chromosome_letter)) +
geom_boxplot() +
theme_light() +
labs(fill = "Chromosome",
title = 'tRNA KOs Responsiveness per Chromosome',
subtitle = 'Number of Differentially Expressed Proteins (DEPs)') +
xlab("Chromosome") +
theme(legend.title = element_text(size=9),
legend.key.size = unit(0.5, 'cm'))
ggplot(data = responsiveness, aes(x = chromosome_letter, y = nDEP, fill = chromosome_letter)) +
geom_boxplot(outliers = F) +
geom_jitter() +
theme_light() +
labs(fill = "Chromosome",
title = 'tRNA KOs Responsiveness per Chromosome',
subtitle = 'Number of Differentially Expressed Proteins (DEPs) - truncated < 100 nDEP') +
xlab("Chromosome") +
theme(legend.title = element_text(size=9),
legend.key.size = unit(0.5, 'cm')) +
coord_cartesian(ylim = c(0, 100))
myLetters <- letters[1:26]              # Need this to be able to re-order anticodons by amino acid
ggplot(responsiveness, aes(x = fct_reorder(anticodon, match(tolower(Amino_acid_1_letter), myLetters)), y = nDEP, groupping = Amino_acid_1_letter, fill = Amino_acid_1_letter)) +
geom_boxplot() +
theme_light() +
xlab("Anticodon") +
labs(fill = "Amino acid") +
labs(title = 'tRNA KOs Responsiveness per Anticodon',
subtitle = 'Number of Differentially Expressed Proteins (DEPs)') +
theme(legend.title = element_text(size=9),
legend.key.size = unit(0.5, 'cm'),
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
ggplot(responsiveness, aes(x = fct_reorder(anticodon, match(tolower(Amino_acid_1_letter), myLetters)), y = nDEP, groupping = Amino_acid_1_letter, fill = Amino_acid_1_letter)) +
geom_boxplot(outliers = F) +
geom_jitter() +
theme_light() +
xlab("Anticodon") +
labs(fill = "Amino acid") +
coord_cartesian(ylim = c(0, 150)) +
labs(title = 'tRNA KOs Responsiveness per Anticodon',
subtitle = 'Number of Differentially Expressed Proteins (DEPs) - truncated < 150 nDEP') +
theme(legend.title = element_text(size=9),
legend.key.size = unit(0.5, 'cm'),
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
version
