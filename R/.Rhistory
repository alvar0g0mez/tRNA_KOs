temp[,2] <- as.numeric(temp[,2])
first_rows <- proteomics_raw[1:4, colnames(proteomics_raw) == strain]
out <- c(first_rows[,1], apply(temp, 1, mean))
out_temp[,i] <- out
}
colnames(out_temp) <- repeated_samples
## Remove original columns from dataframe and add the averaged ones
proteomics_raw <- proteomics_raw[,!(colnames(proteomics_raw) %in% repeated_samples)]
proteomics_raw <- cbind(proteomics_raw, out_temp)
# Format data to get a biological protein abundance dataframe with samples names as colnames and gene names as rownames
trna_ko <- proteomics_raw %>%
filter(!(genes %in% c('', 'Genes', 'Protein.Group'))) %>%             # Remove rows for which "genes" column is empty or has "Genes" as value
dplyr::select(-genes & !contains('QC')) %>%                                  # Remove UNIPROT IDs and QCs columns
column_to_rownames(var = 'sample_group')                              # Convert gene name column to rownames
# Convert to a numeric dataframe
trna_ko <- as.data.frame(apply(trna_ko, 2, as.numeric), row.names =  rownames(trna_ko))
# Add sample_names to sample_layout so that we can filter out in the next line
sample_layout <- sample_layout %>%
mutate(sample_names = case_when(Strain.ID == "WT" ~ paste(gsub("-", "_", Sample.ID), ".0", Replicate, sep=""),
TRUE ~ paste(Strain.Name, "_0", Replicate, sep="")))
# Remove the sub-batch that went wrong
samples_in_wrong_batch <- sample_layout$sample_names[sample_layout$Analysis.Plate.96_Replicate == "3_2"]
trna_ko <- trna_ko[,!(colnames(trna_ko) %in% samples_in_wrong_batch)]
# Remove unnecessary objects
rm(proteomics_raw, n_occur, repeated_samples, out_temp, strain, temp, first_rows, out, batch_num, i, new_name, new_names, strain_and_batch, trna_name,
samples_in_wrong_batch, working_from)
# Get the names of all KOs we have, and set WT as the reference
trna_levels <- c()
for (i in 1:ncol(trna_ko)) {
sample_name <- colnames(trna_ko)[i]
strain_name <- sample_layout$Strain.Name[sample_layout$sample_names == sample_name]
if (length(strain_name) > 1) {
strain_name <- strain_name[1]
}
trna_levels <- c(trna_levels, strain_name)
}
trna_levels <- as.factor(trna_levels)
trna_levels <- relevel(trna_levels, ref = "WT")
# Generate design matrix
mm <- model.matrix(~trna_levels)
colnames(mm) <- levels(trna_levels)
voom(trna_ko, mm, plot = TRUE)                                  # This I still need to look into!
# In order to fit linear model we need to get log2(data), but that causes log2(0) = -Inf --> I am turning 0s to 1s before log2 --> IDK HOW CORRECT THIS IS
zeros_to_ones <- function(x) {
if (x == 0) {return(1)}
else {return(x)}
}
trna_ko_log <- trna_ko
trna_ko_log[] <- apply(trna_ko, c(1,2), zeros_to_ones)
trna_ko_log <- log2(trna_ko_log)
# Fit linear model
fit <- lmFit(trna_ko_log, mm)                                 # Notice the log2 here
fit2 <- eBayes(fit, trend = TRUE)
# Identify differentially expressed proteins
da <- list()
for (i in colnames(mm)) {
da[[i]] <- topTable(fit2, coef = i, adjust = 'BH', number = Inf, sort.by = 'none')
}
# At the alpha specified at the top of the document
yeastmine <- as.data.frame(fread(paste(base_dir, "Data/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))
de_proteins_list_001 <- list()
for (i in 1:length(da)) {
temp <- da[[i]]
# Collect protein names and turn them all into systematic notation
general_protein_names <- rownames(temp)[na.omit(temp$adj.P.Val) < alpha]
standard_protein_names <- general_protein_names[general_protein_names %in% yeastmine$Gene.symbol]
systematic_protein_names <- general_protein_names[general_protein_names %in% yeastmine$Gene.secondaryIdentifier]
final_protein_names <- c(systematic_protein_names, match_systematic_and_standard_protein_names(data = standard_protein_names,
yeastmine = yeastmine,
input = "standard",
simplify = T))
# Save protein names
de_proteins_list_001[[names(da)[i]]] <- final_protein_names
}
output_file <- paste(base_dir, "Data/Other/enrichment_analysis/de_proteins_list_001.json", sep="")
write_json(de_proteins_list_001, path=output_file)
# At alpha= 0.05
yeastmine <- as.data.frame(fread(paste(base_dir, "Data/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))
de_proteins_list_005 <- list()
for (i in 1:length(da)) {
temp <- da[[i]]
# Collect protein names and turn them all into systematic notation
general_protein_names <- rownames(temp)[na.omit(temp$adj.P.Val) < 0.05]
standard_protein_names <- general_protein_names[general_protein_names %in% yeastmine$Gene.symbol]
systematic_protein_names <- general_protein_names[general_protein_names %in% yeastmine$Gene.secondaryIdentifier]
final_protein_names <- c(systematic_protein_names, match_systematic_and_standard_protein_names(data = standard_protein_names,
yeastmine = yeastmine,
input = "standard",
simplify = T))
# Save protein names
de_proteins_list_005[[names(da)[i]]] <- final_protein_names
}
output_file <- paste(base_dir, "Data/Other/enrichment_analysis/de_proteins_list_005.json", sep="")
write_json(de_proteins_list_005, path=output_file)
write_json(da, path=paste(base_dir, "Data/Other/enrichment_analysis/da.json", sep=""))
# Format data
da <- bind_rows(da) %>%
mutate(protein = rep(rownames(da[[1]]), times = length(da)),
Strain.Name = rep(names(da), each = nrow(da[[1]])), .before = 1) %>%
`rownames<-`(NULL) %>%
dplyr::select(protein, Strain.Name, logFC, adj.P.Val) %>%
filter(Strain.Name != 'WT') %>%                              # From here on in this function it's added by me
mutate(diffexpressed = case_when(logFC > lfc_threshold & adj.P.Val < alpha ~ "Up_regulated",
logFC < -lfc_threshold & adj.P.Val < alpha ~ "Down_regulated",
TRUE ~ "Not_significant"))
# Add a column to da with the number of replicates per KO - by me - THIS DOESN'T REALLY MAKE SENSE INSIDE THIS FUNCTION BUT WHEN DOING DE FOR ALL PLATES AT ONCE IT WAS, SO I'LL KEEP IT JUST IN CASE
unique_KOs <- unique(da$Strain.Name)
replicates <- c()
for (i in 1:length(unique_KOs)) {
KO <- unique_KOs[i]
replicates <- c(replicates, sum(grepl(KO, colnames(trna_ko), fixed = T)))
}
KOs_replicates <- data.frame(unique_KOs, replicates)
colnames(KOs_replicates) <- c("Strain.Name", "Replicate_num")
da <- merge(da, KOs_replicates, by = "Strain.Name")
# Responsiveness
responsiveness <- da %>%
group_by(Strain.Name) %>%
summarise(nDEP = sum(abs(logFC) >= log2(lfc_threshold) & adj.P.Val <= 0.01, na.rm = T),
Replicate_num = mean(Replicate_num)) %>%
mutate(AA = str_sub(Strain.Name, 2, 2),
chromosome = str_extract(str_remove(str_sub(Strain.Name, 1, -4), '[:digit:]$'), '[:alpha:]$'),
anticodon = str_extract(Strain.Name, "(?<=\\()[[:alpha:]]{3}(?=\\))")) %>%
arrange(AA) %>%
mutate(anticodon = factor(anticodon, levels = unique(anticodon)))
# Save results from the DE analysis in the same way as in the file where I do DE separately for each batch
DE <- list(fit = fit,
fit2 = fit2,
da = da,
responsiveness= responsiveness)
# Remove unnecesary variables
rm(DE, de_proteins_list_001, de_proteins_list_005, fit, fit2, KOs_replicates, mm, sample_layout, temp, trna_ko, trna_ko_log,
yeastmine, final_protein_names, general_protein_names, i, KO, output_file, replicates, sample_name, standard_protein_names, strain_name,
systematic_protein_names, trna_levels, unique_KOs)
# One plot per KO and save them to a PDF - for all KOs
## Come up with the list of plots
plot_list <- list()
for (i in 1:length(levels(as.factor(da$Strain.Name)))) {
trna <- levels(as.factor(da$Strain.Name))[i]
temp <- da %>% filter(Strain.Name == trna)
plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed)) +
geom_point() +
geom_hline(yintercept = -log10(0.01), linetype = "dashed", col = "gray") +
geom_vline(xintercept = c(-1.5, 1.5), linetype = "dashed", col = "gray") +
theme_light() +
theme(legend.position = "none") +
labs(title = trna) +
scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}
## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)
## Print to PDF
output_file = paste(base_dir, "Output/Plots/Volcano_plots/DE_together/volcano_plots_per_KO_all_KOs_together.pdf", sep = "")
ggsave(
filename = output_file,
plot = marrangeGrob(my_grobs, nrow=4, ncol=4),
width = 15, height = 9
)
# One plot per KO and save them to a PDF - only for KOs with at least 1 DE protein
## Remove KOs with 0 DE proteins
KOs_with_DE_proteins <- responsiveness$Strain.Name[responsiveness$nDEP > 0]
da_only_KOs_with_DE_proteins <- da[da$Strain.Name %in% KOs_with_DE_proteins,]
## Come up with the list of plots
plot_list <- list()
for (i in 1:length(KOs_with_DE_proteins)) {
trna <- KOs_with_DE_proteins[i]
temp <- da_only_KOs_with_DE_proteins %>% filter(Strain.Name == trna)
plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed)) +
geom_point() +
geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
theme_light() +
theme(legend.position = "none") +
labs(title = trna) +
scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}
## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)
## Print to PDF
output_file = paste(base_dir, "Output/Plots/Volcano_plots/DE_together/volcano_plots_per_KO_KOs_with_DE_proteins_together.pdf", sep = "")
ggsave(
filename = output_file,
plot = marrangeGrob(my_grobs, nrow=4, ncol=4),
width = 15, height = 9
)
# Remove unused objects
rm(list = c("my_grobs", "plot_list", "KOs_with_DE_proteins", "temp", "da_only_KOs_with_DE_proteins", "trna", "i", "output_file"))
# Load their phenotypic data: growth rate and growth yield for all KOs
phenotypic_data <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/bloom_ackermann_2014/phenotypic_results.tsv", sep = "")))
# Just number of DE proteins
UCU_major_minor <- phenotypic_data %>%
filter(UCU_family != "No") %>%
dplyr::select(gene_name, UCU_family) %>%
rename(Strain.Name = gene_name)
UCU_responsiveness <- responsiveness%>% filter(anticodon == "UCU")
UCU_family <- full_join(UCU_major_minor, UCU_responsiveness, by = "Strain.Name")
# Volcano plots
## Keep only KOs in UCU family
KOs_in_UCU_family <- UCU_family$Strain.Name
da_only_KOs_from_UCU_family <- da[da$Strain.Name %in% KOs_in_UCU_family,]
## Come up with the list of plots
plot_list <- list()
for (i in 1:length(KOs_in_UCU_family)) {
trna <- KOs_in_UCU_family[i]
plot_title <- paste(trna, UCU_family$UCU_family[UCU_family$Strain.Name == trna], sep = "_")
temp <- da_only_KOs_from_UCU_family %>% filter(Strain.Name == trna)
plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed)) +
geom_point() +
geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
geom_vline(xintercept = c(-1.5, 1.5), linetype = "dashed", col = "gray") +
theme_light() +
theme(legend.position = "none") +
labs(title = plot_title) +
scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}
## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)
## Print to PDF
output_location <- paste(base_dir, "Output/Plots/Volcano_plots/DE_together/volcano_plots_per_KO_UCU_family_together.pdf", sep="")
ggsave(
filename = output_location,
plot = marrangeGrob(my_grobs, nrow=4, ncol=4),
width = 15, height = 9
)
# Remove unused objects
rm(list = c("my_grobs", "plot_list", "KOs_in_UCU_family", "temp", "da_only_KOs_from_UCU_family", "trna", "plot_title", "UCU_major_minor", "UCU_responsiveness", "i", "UCU_family", "phenotypic_data", "output_location"))
ggplot(data = responsiveness, aes(x = as.factor(Replicate_num), y = nDEP, col = as.factor(Replicate_num))) +
geom_boxplot() +
geom_jitter(position=position_jitter(0.2)) +
xlab("Number of replicates")
replicate_num_vs_nDEP_cor <- cor(responsiveness$nDEP, responsiveness$Replicate_num)
replicate_num_vs_nDEP_cor
# Remove unnecessary objects
rm(replicate_num_vs_nDEP_cor)
responsiveness <- responsiveness %>%
group_by(anticodon) %>%
mutate(n= n())
ggplot(data = responsiveness, aes(x = anticodon, y = nDEP, fill = n)) +
geom_boxplot()
# Correlation between nDEP and tRNA family size
resp_summarized_by_family <- aggregate(responsiveness$nDEP, list(responsiveness$anticodon), mean)
colnames(resp_summarized_by_family) <- c("anticodon", "nDEP")
resp_summarized_by_family <- merge(resp_summarized_by_family, responsiveness[, c("anticodon", "n")], by = "anticodon", all.x = T)
resp_summarized_by_family <- resp_summarized_by_family %>%
distinct(anticodon, .keep_all = T)
cor(resp_summarized_by_family$nDEP, resp_summarized_by_family$n)
# Remove unnecessary variables
rm(resp_summarized_by_family)
# Histogram of avg_nDEP for each KO strain
ggplot(data = responsiveness, aes(x = nDEP)) +
geom_histogram(binwidth = 1, color="black", fill="grey") +
theme_light() +
xlab("nDEP per tRNA KO") +
ylab("Count") +
labs(title = "Frequency of nDEP across all tRNA KO strains")
# Given this histogram, I define the threshold to make out major and minor tRNA genes - for now I have it at 2
# Define a column with "minor"-"major" based on this so that I can check how many major and minor ones there are per family (I could also do this directly based on the avg_nDEP tbh but oh well)
responsiveness<- responsiveness%>%
mutate(Gene_type = case_when(nDEP < threshold_major ~ "Minor",
TRUE ~ "Major")) %>%
group_by(anticodon) %>%
summarize(Major_count = sum(Gene_type == "Major"), across()) %>%
ungroup()
# Also need to count the total number of KOs I have from each family in the experiment
responsiveness<- responsiveness%>%
group_by(anticodon) %>%
summarize(Family_count = n(), across()) %>%
ungroup()
# Get a dataframe with the size of each family, the number of those genes we have as KOs in the experiment, and how many of them are major, and plot this
colnames(master_dataset)[colnames(master_dataset) == "family_size"] <- "Family_size"
family_sizes <- left_join(master_dataset, responsiveness, by = "Strain.Name")
family_sizes <- family_sizes %>%
filter(Strain.Name %in% responsiveness$Strain.Name) %>%                       # Filtered on KOd before, but that kept strains that were removed during filtering
dplyr::select(anticodon, Family_size, Family_count, Major_count) %>%
distinct(anticodon, .keep_all = T)
# Get long version to plot, and re-order the anticodons by family size, in order to keep that order for the x axis of the plot
family_sizes <- family_sizes[order(-family_sizes$Family_size), ]
family_sizes_long <- family_sizes %>% pivot_longer(!anticodon, names_to = "Type", values_to = "Count")
family_sizes_long$anticodon <- factor(family_sizes_long$anticodon, levels = family_sizes$anticodon)
family_sizes_long$Type <- factor(family_sizes_long$Type, levels = c("Family_size", "Family_count", "Major_count"))
colnames(family_sizes_long)[colnames(family_sizes_long) == "anticodon"] <- "Anticodon"
# Plot this
ggplot(data = family_sizes_long, aes(x = Anticodon, y = Count, fill = Type)) +
geom_bar(position="dodge", stat="identity") +
theme_light() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
legend.position = "none")
# What is the relationship between Family_count and Major_count?
ggplot(data = family_sizes, aes(x = Family_count, y = Major_count)) +
geom_point() +
geom_abline() +
theme_light() +
xlab("Genes in this family in the experiment") +
ylab("Major genes detected in the family") +
geom_text_repel(data = subset(family_sizes, Major_count/Family_count >= 1 | Major_count/Family_count < 0.3),
aes(x = Family_count, y = Major_count, label = anticodon),
size = 4)
# Produce a single histogram like the one at the beginning of this chunk for each set of tRNA isoacceptors - and save them to a PDF
## Create empty list of plots
plot_list <- list()
## Generate the plots and add them to the list
aas <- levels(as.factor(responsiveness$AA))
for (i in 1:length(aas)) {
aa <- aas[i]
temp <- responsiveness%>%
filter(AA == aa)
plot_list[[aa]] <- ggplot(data = temp, aes(x = nDEP, col = anticodon, fill = anticodon)) +
geom_histogram(binwidth = 1) +
theme_light() +
xlab("nDEP") +
ylab("Count") +
labs(title = glue("Frequency of nDEP in tRNAs loading {aa}"))
}
## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)
## Print to PDF
output_file = paste(base_dir, "Output/Plots/nDEP_hists_per_isoacceptors_color_by_codon.pdf", sep = "")
ggsave(
filename = output_file,
plot = marrangeGrob(my_grobs, nrow=4, ncol=4),
width = 15, height = 9
)
# Remove unnecessary variables
rm(family_sizes, family_sizes_long, my_grobs, plot_list, temp, aa, aas, loc, output_file, i)
# Load their phenotypic data: growth rate and growth yield for all KOs
phenotypic_data <- as.data.frame(fread(paste(base_dir, "Data/Other/bloom_ackermann_2014/phenotypic_results.tsv", sep="")))
# Load their phenotypic data: growth rate and growth yield for all KOs
phenotypic_data <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/bloom_ackermann_2014/phenotypic_results.tsv", sep="")))
# Load their small microarray data: fold changes for all genes but only for 5 samples
microarray_data <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/bloom_ackermann_2014/microarray_fold_change_data.tsv", sep="")))
# Load all S. cerevisiae genes from AllianceMine - to be able to go from standard to systematic gene names and vice versa
yeastmine <- as.data.frame(fread(paste(base_dir, "Data/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))
# Need to change the colnames in the microarray data to use () instead of ..
colnames(microarray_data) <- c("gene_names", "tM(CAU)C", "tR(CCU)J", "tR(UCU)M2", "tH(GUG)G1", "tL(GAG)G")
cozen <- read.xlsx(paste(base_dir, "Data/Other/tRNA_expression_comparative/cozen_et_al_2015.xlsx", sep=""), 1) %>%
filter(read.mapping..genomic.sequence.or.mature.tRNA. == "genomic")
cozen_to_merge <- cozen %>%
filter(saccaromyces.genome.datasbase..sgd..tRNA.name != "NA" &
mean.normalized.ReadCount..AlkB != "NA") %>%
dplyr::select(name, tRNA.group, chromosome, chromosome.start, chromosome.end, chromosome.start,
saccaromyces.genome.datasbase..sgd..tRNA.name, mean.normalized.ReadCount..AlkB, read.mapping..genomic.sequence.or.mature.tRNA.) %>%
group_by(saccaromyces.genome.datasbase..sgd..tRNA.name) %>%
mutate(mean_reads_per_tRNA = sum(as.numeric(mean.normalized.ReadCount..AlkB), na.rm = T)) %>%
rename(Strain.Name = saccaromyces.genome.datasbase..sgd..tRNA.name)
## Merge with resp
resp_and_expression <- left_join(resp, cozen_to_merge, by = "Strain.Name")
## Merge with resp
resp_and_expression <- left_join(responsiveness, cozen_to_merge, by = "Strain.Name")
# Load data
chu_synths <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/chu_2011/S3.csv", sep="")))
chu_trnas <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/chu_2011/S2.csv", sep="")))
# The problem with these abundances for tRNAs is that they are for each family, not for each tRNA concretely, so I don't really know if they will be useful to me. I could collapse those from Cozen et al. by family and compare them to this to see if they point in the same direction, but might be a bit of a time waste
# Join the synthetase data to the resp_and_expression dataset
amino_acids <- as.data.frame(fread(paste(base_dir, "Data/Other/GtRNAdb/amino_acids.csv", sep=""))) %>%
rename(Amino_acid = X3_letter_code,
AA = X1_letter_code)
chu_synths <- left_join(chu_synths, amino_acids, by = "Amino_acid") %>%
rename(synthetase_abundance = Abundance)
resp_and_expression <- left_join(resp_and_expression, chu_synths, by = "AA")
# Create function to get anticodon from codon
exchange_individual_nucleotide <- function(nt) {
if (nt == "A") {return("U")}
else if (nt == "C") {return("G")}
else if (nt == "G") {return("C")}
else if (nt == "T") {return("A")}
else if (nt == "U") {return("A")}
else {return("Provided letter is not a nucleotide")}
}
get_anticodon_from_codon <- function(codon) {
anticodon <- ""
for (i in 1:nchar(codon)) {
nt <- substr(codon, i, i)
new_nt <- exchange_individual_nucleotide(nt)
anticodon <- paste(anticodon, new_nt, sep="")
}
return(anticodon)
}
# Get anticodon from codon and rename columns
anticodon_freq <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/chu_2011/S1.csv", sep="")))
anticodon_freq$anticodon <- lapply(anticodon_freq[,colnames(anticodon_freq) == "Codon"], get_anticodon_from_codon)
anticodon_freq$anticodon <- as.character(anticodon_freq$anticodon)
anticodon_freq$anticodon <- as.factor(anticodon_freq$anticodon)
anticodon_freq <- anticodon_freq %>%
rename(codon_frequency_chu_2011 = Frequency)
# Merge to resp_and_expression
resp_and_expression <- left_join(resp_and_expression, anticodon_freq, by = "anticodon")
fit <- glm.nb(data = resp_and_expression,
formula = nDEP ~ synthetase_abundance*k_cat_value*codon_frequency_chu_2011)
summary(fit)
# Check overdispersion
check_overdispersion(fit)
fit
fit$coefficients
exp(fit$coefficients)
# Load list
codon_ratios_list <- fromJSON(paste(base_dir, "Data/Other/check_codon_enrichment_in_protein_sequences/codon_counts.json", sep=""))
# Remove from the list those strains where there aren't at least 4 DE proteins
bool <- c()
for (i in 1:length(codon_ratios_list)) {
bool <- c(bool, length(codon_ratios_list[[i]][["DE"]]) > 4)
}
codon_ratios_list <- codon_ratios_list[bool]
strains <- names(codon_ratios_list)
p.values_wmw <- c()
mean_de <- c()
mean_non_de <- c()
for (i in 1:length(codon_ratios_list)) {
# Grab data for this strain
strain_name <- names(codon_ratios_list)[i]
de <- codon_ratios_list[[strain_name]][["DE"]]
non_de <- codon_ratios_list[[strain_name]][["non_DE"]]
de_df <- data.frame(codon_ratios_list[[strain_name]][["DE"]])
non_de_df <- data.frame(codon_ratios_list[[strain_name]][["non_DE"]])
# Plot overlapping histograms
ggplot() +
geom_histogram(data = de_df, aes(x = log2(codon_ratios_list..strain_name.....DE...)), fill = "red", alpha = 0.9) +
geom_histogram(data = non_de_df, aes(x = log2(codon_ratios_list..strain_name.....non_DE...)), fill = "orange", alpha = 0.4)
# Test - WMW
p.values_wmw <- c(p.values_wmw, wilcox.test(de, non_de)$p.value)
# Test - log2 transform (need to take care of 0s) and use t-test - is this worth doing?
# Save the mean of each group to the output dataframe as well
mean_de <- c(mean_de, mean(de))
mean_non_de <- c(mean_non_de, mean(non_de))
}
p.values.adj <- p.adjust(p.values_wmw, method = "fdr")
test_codon_enrichment <- data.frame(strains, p.values_wmw, p.values.adj, mean_de, mean_non_de) %>%
mutate(direction = case_when(mean_de > mean_non_de ~ "DE",
TRUE ~ "non_DE"))
View(test_codon_enrichment)
test_codon_enrichment <- data.frame(strains, p.values_wmw, p.values.adj, mean_de, mean_non_de) %>%
mutate(direction = case_when(mean_de > mean_non_de ~ "DE",
TRUE ~ "non_DE"),
FC = mean_de/mean_non_de)
ggplot(data = test_codon_enrichment, aes(x = FC, y = -log10(p.values.adj))) +
geom_point() +
geom_hline(yintercept = -log10(alpha), col = "red") +
theme_light()
test_codon_enrichment <- data.frame(strains, p.values_wmw, p.values.adj, mean_de, mean_non_de) %>%
mutate(direction = case_when(mean_de > mean_non_de ~ "DE",
TRUE ~ "non_DE"),
FC = mean_de - mean_non_de)
ggplot(data = test_codon_enrichment, aes(x = FC, y = -log10(p.values.adj))) +
geom_point() +
geom_hline(yintercept = -log10(alpha), col = "red") +
theme_light()
test_codon_enrichment <- data.frame(strains, p.values_wmw, p.values.adj, mean_de, mean_non_de) %>%
mutate(direction = case_when(mean_de > mean_non_de ~ "DE",
TRUE ~ "non_DE"),
FC = mean_de - mean_non_de,
logFC = log10(FC))
log2(-1)
log2_ignoring_zeros <- function(value) {
if (value == 0) {return(0)}
else {return(log2(value))}
}
test_codon_enrichment <- data.frame(strains, p.values_wmw, p.values.adj, mean_de, mean_non_de) %>%
mutate(direction = case_when(mean_de > mean_non_de ~ "DE",
TRUE ~ "non_DE"),
FC = mean_de - mean_non_de,
logFC = log2_ignoring_zeros(FC))
logFC <- c()
for (i in nrow(test_codon_enrichment)) {
FC <- test_codon_enrichment$FC
if (FC < 0) {
out <- -log10(abs(FC))
}
else if (FC > 0) {
out <- log10(FC)
}
else if (FC == 0) {
out <- 0
}
logFC <- c(logFC, out)
}
logFC <- c()
for (i in nrow(test_codon_enrichment)) {
FC <- test_codon_enrichment$FC[i]
if (FC < 0) {
out <- -log10(abs(FC))
}
else if (FC > 0) {
out <- log10(FC)
}
else if (FC == 0) {
out <- 0
}
logFC <- c(logFC, out)
}
test_codon_enrichment$logFC <- logFC
ggplot(data = test_codon_enrichment, aes(x = logFC, y = -log10(p.values.adj))) +
geom_point() +
geom_hline(yintercept = -log10(alpha), col = "red") +
theme_light()
logFC <- c()
for (i in 1:nrow(test_codon_enrichment)) {
FC <- test_codon_enrichment$FC[i]
if (FC < 0) {
out <- -log10(abs(FC))
}
else if (FC > 0) {
out <- log10(FC)
}
else if (FC == 0) {
out <- 0
}
logFC <- c(logFC, out)
}
test_codon_enrichment$logFC <- logFC
ggplot(data = test_codon_enrichment, aes(x = logFC, y = -log10(p.values.adj))) +
geom_point() +
geom_hline(yintercept = -log10(alpha), col = "red") +
theme_light()
