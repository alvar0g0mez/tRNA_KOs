TRUE ~ "KO"))
# Add a column with the following format: Analysis.Plate.96_Replicate
sample_layout <- sample_layout %>%
mutate(Analysis.Plate.96_Replicate = paste(Analysis.Plate.96, Replicate, sep="_"))
# Add a column which identifies samples in Analysis.Plate.96 = 3, Replicate = 2
sample_layout <- sample_layout %>%
mutate(Wrong_batch = case_when(Analysis.Plate.96_Replicate == "3_2" ~ "Yes",
TRUE ~ "No"))
# Merge with master dataframe
colnames(master_dataset)[colnames(master_dataset) == "gene_name"] <- "Strain.Name"
sample_layout <- sample_layout %>%
select(-Anticodon) %>%
left_join(master_dataset, by = c("Strain.Name"))
# Come up with new colnames
new_names <- c("sample_group", "genes")
for (i in 3:ncol(proteomics_raw)) {
strain_and_batch <- colnames(proteomics_raw)[i]
trna_name <- proteomics_raw[1, i]
batch_num <- str_extract(strain_and_batch, "(?<=\\.).*")
new_name <- paste(trna_name, "_", batch_num, sep = "")
new_names <- c(new_names, new_name)
}
colnames(proteomics_raw) <- new_names
# Fix the situation with 2 tRNA_KOs being present twice (so 6 replicates for each instead of 3) - just going to take the average between the replicated samples
## Come up with the averages
n_occur <- data.frame(table(colnames(proteomics_raw)))
repeated_samples <- as.character(n_occur$Var1)[n_occur$Freq > 1]
out_temp <- data.frame(matrix(ncol = 0, nrow = nrow(proteomics_raw)))
for (i in 1:length(repeated_samples)) {
strain <- repeated_samples[i]
temp <- proteomics_raw[5:nrow(proteomics_raw), colnames(proteomics_raw) == strain]
temp[,1] <- as.numeric(temp[,1])
temp[,2] <- as.numeric(temp[,2])
first_rows <- proteomics_raw[1:4, colnames(proteomics_raw) == strain]
out <- c(first_rows[,1], apply(temp, 1, mean))
out_temp[,i] <- out
}
colnames(out_temp) <- repeated_samples
## Remove original columns from dataframe and add the averaged ones
proteomics_raw <- proteomics_raw[,!(colnames(proteomics_raw) %in% repeated_samples)]
proteomics_raw <- cbind(proteomics_raw, out_temp)
# Format data to get a biological protein abundance dataframe with samples names as colnames and gene names as rownames
trna_ko <- proteomics_raw %>%
filter(!(genes %in% c('', 'Genes', 'Protein.Group'))) %>%             # Remove rows for which "genes" column is empty or has "Genes" as value
select(-genes & !contains('QC')) %>%                                  # Remove UNIPROT IDs and QCs columns
column_to_rownames(var = 'sample_group')                              # Convert gene name column to rownames
# Convert to a numeric dataframe
trna_ko <- as.data.frame(apply(trna_ko, 2, as.numeric), row.names =  rownames(trna_ko))
# Add sample_names to sample_layout so that we can filter out in the next line
sample_layout <- sample_layout %>%
mutate(sample_names = case_when(Strain.ID == "WT" ~ paste(gsub("-", "_", Sample.ID), ".0", Replicate, sep=""),
TRUE ~ paste(Strain.Name, "_0", Replicate, sep="")))
# Remove the sub-batch that went wrong
samples_in_wrong_batch <- sample_layout$sample_names[sample_layout$Analysis.Plate.96_Replicate == "3_2"]
trna_ko <- trna_ko[,!(colnames(trna_ko) %in% samples_in_wrong_batch)]
# Remove unnecessary objects
rm(proteomics_raw, n_occur, repeated_samples, out_temp, strain, temp, first_rows, out, batch_num, i, new_name, new_names, strain_and_batch, trna_name,
samples_in_wrong_batch)
# Get the names of all KOs we have, and set WT as the reference
trna_levels <- c()
for (i in 1:ncol(trna_ko)) {
sample_name <- colnames(trna_ko)[i]
strain_name <- sample_layout$Strain.Name[sample_layout$sample_names == sample_name]
if (length(strain_name) > 1) {
strain_name <- strain_name[1]
}
trna_levels <- c(trna_levels, strain_name)
}
trna_levels <- as.factor(trna_levels)
trna_levels <- relevel(trna_levels, ref = "WT")
# Generate design matrix
mm <- model.matrix(~trna_levels)
colnames(mm) <- levels(trna_levels)
voom(trna_ko, mm, plot = TRUE)                                  # This I still need to look into!
# Fit linear model
fit <- lmFit(log2(trna_ko), mm)                                 # Notice the log2 here
fit2 <- eBayes(fit, trend = TRUE)
# Identify differentially expressed proteins
da <- list()
for (i in colnames(mm)) {
da[[i]] <- topTable(fit2, coef = i, adjust = 'BH', n = Inf, sort.by = 'none')
}
# Format data
da <- bind_rows(da) %>%
mutate(protein = rep(rownames(da[[1]]), times = length(da)),
Strain.Name = rep(names(da), each = nrow(da[[1]])), .before = 1) %>%
`rownames<-`(NULL) %>%
select(protein, Strain.Name, logFC, adj.P.Val) %>%
filter(Strain.Name != 'WT') %>%                              # From here on in this function it's added by me
mutate(diffexpressed = case_when(logFC > lfc_threshold & adj.P.Val < alpha ~ "Up_regulated",
logFC < -lfc_threshold & adj.P.Val < alpha ~ "Down_regulated",
TRUE ~ "Not_significant"))
# Add a column to da with the number of replicates per KO - by me - THIS DOESN'T REALLY MAKE SENSE INSIDE THIS FUNCTION BUT WHEN DOING DE FOR ALL PLATES AT ONCE IT WAS, SO I'LL KEEP IT JUST IN CASE
unique_KOs <- unique(da$Strain.Name)
replicates <- c()
for (i in 1:length(unique_KOs)) {
KO <- unique_KOs[i]
replicates <- c(replicates, sum(grepl(KO, colnames(trna_ko), fixed = T)))
}
KOs_replicates <- data.frame(unique_KOs, replicates)
colnames(KOs_replicates) <- c("Strain.Name", "Replicate_num")
da <- merge(da, KOs_replicates, by = "Strain.Name")
# Responsiveness
responsiveness <- da %>%
group_by(Strain.Name) %>%
summarise(nDEP = sum(abs(logFC) >= log2(lfc_threshold) & adj.P.Val <= 0.01, na.rm = T),
Replicate_num = mean(Replicate_num)) %>%
mutate(AA = str_sub(Strain.Name, 2, 2),
chromosome = str_extract(str_remove(str_sub(Strain.Name, 1, -4), '[:digit:]$'), '[:alpha:]$'),
anticodon = str_extract(Strain.Name, "(?<=\\()[[:alpha:]]{3}(?=\\))")) %>%
arrange(AA) %>%
mutate(anticodon = factor(anticodon, levels = unique(anticodon)))
# Save results from the DE analysis in the same way as in the file where I do DE separately for each batch
DE <- list(fit = fit,
fit2 = fit2,
da = da,
resp = responsiveness)
# Save output with the right names for downstream analysis
resp_filtered <- DE$resp
da_full <- DE$da
# For all KOs together
ggplot(data = da, aes(x = logFC, y = -log10(adj.P.Val), col = Strain.Name)) +
geom_point() +
geom_hline(yintercept = -log10(0.01), linetype = "dashed", col = "gray") +
geom_vline(xintercept = c(-1.5, 1.5), linetype = "dashed", col = "gray") +
theme_light() +
theme(legend.position = "none")
# One plot per KO and save them to a PDF - for all KOs
## Come up with the list of plots
plot_list <- list()
for (i in 1:length(levels(as.factor(da$Strain.Name)))) {
trna <- levels(as.factor(da$Strain.Name))[i]
temp <- da %>% filter(Strain.Name == trna)
plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed)) +
geom_point() +
geom_hline(yintercept = -log10(0.01), linetype = "dashed", col = "gray") +
geom_vline(xintercept = c(-1.5, 1.5), linetype = "dashed", col = "gray") +
theme_light() +
theme(legend.position = "none") +
labs(title = trna) +
scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}
## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)
## Print to PDF
ggsave(
filename = "C:/MyStuff/tRNA_KOs/Output/Plots/Volcano_plots/DE_together/volcano_plots_per_KO_all_KOs_together.pdf",
plot = marrangeGrob(my_grobs, nrow=4, ncol=4),
width = 15, height = 9
)
# One plot per KO and save them to a PDF - only for KOs with at least 1 DE protein
## Remove KOs with 0 DE proteins
KOs_with_DE_proteins <- responsiveness$Strain.Name[responsiveness$nDEP > 0]
da_only_KOs_with_DE_proteins <- da[da$Strain.Name %in% KOs_with_DE_proteins,]
## Come up with the list of plots
plot_list <- list()
for (i in 1:length(KOs_with_DE_proteins)) {
trna <- KOs_with_DE_proteins[i]
temp <- da_only_KOs_with_DE_proteins %>% filter(Strain.Name == trna)
plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed)) +
geom_point() +
geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
theme_light() +
theme(legend.position = "none") +
labs(title = trna) +
scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}
## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)
## Print to PDF
ggsave(
filename = "C:/MyStuff/tRNA_KOs/Output/Plots/Volcano_plots/DE_together/volcano_plots_per_KO_KOs_with_DE_proteins_together.pdf",
plot = marrangeGrob(my_grobs, nrow=4, ncol=4),
width = 15, height = 9
)
# Remove unused objects
rm(list = c("my_grobs", "plot_list", "KOs_with_DE_proteins", "temp", "da_only_KOs_with_DE_proteins", "trna", "i"))
# Load their phenotypic data: growth rate and growth yield for all KOs
phenotypic_data <- as.data.frame(fread('C:/MyStuff/tRNA_KOs/Data/bloom_ackermann_2014/phenotypic_results.tsv'))
# Just number of DE proteins
UCU_major_minor <- phenotypic_data %>%
filter(UCU_family != "No") %>%
select(gene_name, UCU_family) %>%
rename(Strain.Name = gene_name)
UCU_responsiveness <- resp_filtered %>% filter(anticodon == "UCU")
UCU_family <- full_join(UCU_major_minor, UCU_responsiveness, by = "Strain.Name")
# Volcano plots
## Keep only KOs in UCU family
KOs_in_UCU_family <- UCU_family$Strain.Name
da_only_KOs_from_UCU_family <- da_full[da_full$Strain.Name %in% KOs_in_UCU_family,]
## Come up with the list of plots
plot_list <- list()
for (i in 1:length(KOs_in_UCU_family)) {
trna <- KOs_in_UCU_family[i]
plot_title <- paste(trna, UCU_family$UCU_family[UCU_family$Strain.Name == trna], sep = "_")
temp <- da_only_KOs_from_UCU_family %>% filter(Strain.Name == trna)
plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed)) +
geom_point() +
geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
geom_vline(xintercept = c(-1.5, 1.5), linetype = "dashed", col = "gray") +
theme_light() +
theme(legend.position = "none") +
labs(title = plot_title) +
scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}
## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)
## Print to PDF
ggsave(
filename = "C:/MyStuff/tRNA_KOs/Output/Plots/Volcano_plots/DE_together/volcano_plots_per_KO_UCU_family_together.pdf",
plot = marrangeGrob(my_grobs, nrow=4, ncol=4),
width = 15, height = 9
)
# Remove unused objects
rm(list = c("my_grobs", "plot_list", "KOs_in_UCU_family", "temp", "da_only_KOs_from_UCU_family", "trna", "plot_title", "UCU_major_minor", "UCU_responsiveness", "i"))
ggplot(data = responsiveness, aes(x = as.factor(Replicate_num), y = nDEP, col = as.factor(Replicate_num))) +
geom_boxplot() +
geom_jitter(position=position_jitter(0.2)) +
xlab("Number of replicates")
replicate_num_vs_nDEP_cor <- cor(responsiveness$nDEP, responsiveness$Replicate_num)
replicate_num_vs_nDEP_cor
# Remove unnecessary objects
rm(replicate_num_vs_nDEP_cor)
responsiveness <- responsiveness %>%
group_by(anticodon) %>%
mutate(n= n())
ggplot(data = responsiveness, aes(x = anticodon, y = nDEP, fill = n)) +
geom_boxplot()
# Correlation between nDEP and tRNA family size
resp_summarized_by_family <- aggregate(responsiveness$nDEP, list(responsiveness$anticodon), mean)
colnames(resp_summarized_by_family) <- c("anticodon", "nDEP")
resp_summarized_by_family <- merge(resp_summarized_by_family, responsiveness[, c("anticodon", "n")], by = "anticodon", all.x = T)
resp_summarized_by_family <- resp_summarized_by_family %>%
distinct(anticodon, .keep_all = T)
cor(resp_summarized_by_family$nDEP, resp_summarized_by_family$n)
ea <- list()
for (i in unique(da_full$Strain.Name)) {
ea[[i]] <- pull(filter(da_full, Strain.Name %in% i & abs(logFC) >= log2(lfc_threshold) & adj.P.Val <= alpha), protein)
}
rm(i)
ea <- gost(ea, organism = 'scerevisiae', correction_method = 'fdr', domain_scope = 'custom', custom_bg = unique(da_full$protein), sources = c('GO', 'KEGG', 'TF'))
ea_terms <- ea$result %>%
group_by(query) %>%
summarise(n_terms = n()) %>%
mutate(AA = str_sub(query, 2, 2),
chromosome = str_extract(str_remove(query, '[:digit:]$'), '[:alpha:]$'),
anticodon = str_extract(query, '(?<=\\.)[:alpha:]{3}'))
ea_terms_ko <- ea$result %>%
group_by(term_name) %>%
summarise(n_kos = n(), source = unique(source)) %>%
ungroup() %>%
filter(n_kos > 25)
View(ea_terms_ko)
# Histogram of avg_nDEP for each KO strain
ggplot(data = resp_filtered, aes(x = avg_nDEP)) +
geom_histogram(binwidth = 1, color="black", fill="grey") +
theme_light()
View(resp_filtered)
# Histogram of avg_nDEP for each KO strain
ggplot(data = resp_filtered, aes(x = nDEP)) +
geom_histogram(binwidth = 1, color="black", fill="grey") +
theme_light()
# There are ~80 KO strains with 0 avg_nDEP, I don't think it's that straightforward but for now I'll assume those are the minor tRNA genes
# Define a column with "minor"-"major" based on this so that I can check how many major and minor ones there are per family (I could also do this directly based on the avg_nDEP tbh but oh well)
resp_filtered <- resp_filtered %>%
mutate(Gene_type = case_when(nDEP == 0 ~ "Minor",
TRUE ~ "Major")) %>%
group_by(anticodon) %>%
summarize(Major_count = sum(Gene_type == "Major"), across()) %>%
ungroup()
# Also need to count the total number of KOs I have from each family in the experiment
resp_filtered <- resp_filtered %>%
group_by(anticodon) %>%
summarize(Family_count = n(), across()) %>%
ungroup()
# Get a dataframe with the size of each family, the number of those genes we have as KOs in the experiment, and how many of them are major, and plot this
colnames(master_dataset)[colnames(master_dataset) == "family_size"] <- "Family_size"
family_sizes <- left_join(master_dataset, resp_filtered, by = "Strain.Name")
family_sizes <- family_sizes %>%
filter(Strain.Name %in% resp_filtered$Strain.Name) %>%                       # Filtered on KOd before, but that kept strains that were removed during filtering
select(anticodon, Family_size, Family_count, Major_count) %>%
distinct(anticodon, .keep_all = T)
# Get long version to plot, and re-order the anticodons by family size, in order to keep that order for the x axis of the plot
family_sizes <- family_sizes[order(-family_sizes$Family_size), ]
family_sizes_long <- family_sizes %>% pivot_longer(!anticodon, names_to = "Type", values_to = "Count")
family_sizes_long$anticodon <- factor(family_sizes_long$anticodon, levels = family_sizes$anticodon)
family_sizes_long$Type <- factor(family_sizes_long$Type, levels = c("Family_size", "Family_count", "Major_count"))
colnames(family_sizes_long)[colnames(family_sizes_long) == "anticodon"] <- "Anticodon"
# Plot this
ggplot(data = family_sizes_long, aes(x = Anticodon, y = Count, fill = Type)) +
geom_bar(position="dodge", stat="identity") +
theme_light() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
legend.position = "none")
# What is the relationship between Family_count and Major_count?
ggplot(data = family_sizes, aes(x = Family_count, y = Major_count)) +
geom_point() +
geom_abline() +
geom_smooth(method='lm') +
theme_light() +
xlab("Genes in this family in the experiment") +
ylab("Major genes detected in the family") +
geom_text_repel(data = subset(family_sizes, Major_count/Family_count >= 1 | Major_count/Family_count < 0.3),
aes(x = Family_count, y = Major_count, label = anticodon),
size = 4)
# Load their phenotypic data: growth rate and growth yield for all KOs
phenotypic_data <- as.data.frame(fread('C:/MyStuff/tRNA_KOs/Data/bloom_ackermann_2014/phenotypic_results.tsv'))
# Change "ko" colname to allow to merge datasets based on it
colnames(resp_filtered)[colnames(resp_filtered) == "Strain.Name"] <- "gene_name"
test <- full_join(phenotypic_data, resp_filtered, by = "gene_name")
# Select numeric columns, calculate correlations and plot heatmap
test <- test %>% select(YPD, SDC, low_glucose, galactose, NaCl, DTT, YPD_GY, SDC_GY, low_glucose_GY, galactose_GY, NaCl_GY, DTT_GY, avg_nDEP)
# Load their phenotypic data: growth rate and growth yield for all KOs
phenotypic_data <- as.data.frame(fread('C:/MyStuff/tRNA_KOs/Data/bloom_ackermann_2014/phenotypic_results.tsv'))
# Change "ko" colname to allow to merge datasets based on it
colnames(resp_filtered)[colnames(resp_filtered) == "Strain.Name"] <- "gene_name"
test <- full_join(phenotypic_data, resp_filtered, by = "gene_name")
# Select numeric columns, calculate correlations and plot heatmap
test <- test %>% select(YPD, SDC, low_glucose, galactose, NaCl, DTT, YPD_GY, SDC_GY, low_glucose_GY, galactose_GY, NaCl_GY, DTT_GY, DEP)
# Load their phenotypic data: growth rate and growth yield for all KOs
phenotypic_data <- as.data.frame(fread('C:/MyStuff/tRNA_KOs/Data/bloom_ackermann_2014/phenotypic_results.tsv'))
# Change "ko" colname to allow to merge datasets based on it
colnames(resp_filtered)[colnames(resp_filtered) == "Strain.Name"] <- "gene_name"
test <- full_join(phenotypic_data, resp_filtered, by = "gene_name")
# Select numeric columns, calculate correlations and plot heatmap
test <- test %>% select(YPD, SDC, low_glucose, galactose, NaCl, DTT, YPD_GY, SDC_GY, low_glucose_GY, galactose_GY, NaCl_GY, DTT_GY, nDEP)
colnames(test) <- c("YPD_GR", "SDC_GR", "low_glucose_GR", "galactose_GR", "NaCl_GR", "DTT_GR", "YPD_GY", "SDC_GY", "low_glucose_GY", "galactose_GY", "NaCl_GY", "DTT_GY", "nDEP")
test_corrs <- round(cor(test, use = "pairwise.complete.obs"), 2)
melted_corrs <- melt(test_corrs)
ggplot(data = melted_corrs, aes(x=Var1, y=Var2, fill=value)) +
geom_tile() +
geom_text(aes(Var2, Var1, label = value), size = 3) +
scale_fill_gradient2(low = "blue", high = "red",
limit = c(-1,1), name="Correlation") +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.background = element_blank(),
axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
# Remove unnecessary objects
rm(test, test_corrs, melted_corrs)
# Load their small microarray data: fold changes for all genes but only for 5 samples
microarray_data <- as.data.frame(fread("C:/MyStuff/tRNA_KOs/Data/microarray_fold_change_data.tsv"))
# Load their small microarray data: fold changes for all genes but only for 5 samples
microarray_data <- as.data.frame(fread("C:/MyStuff/tRNA_KOs/Data/bloom_ackermann_2014/microarray_fold_change_data.tsv"))
# Load all S. cerevisiae genes from AllianceMine - to be able to go from standard to systematic gene names and vice versa
yeastmine <- as.data.frame(fread("C:/MyStuff/tRNA_KOs/Data/alliancemine_results_2024-11-20T11-19-04.tsv"))
# Need to change the colnames in the microarray data to use () instead of ..
colnames(microarray_data) <- c("gene_names", "tM(CAU)C", "tR(CCU)J", "tR(UCU)M2", "tH(GUG)G1", "tL(GAG)G")
# Get standard protein names
source("C:/MyStuff/tRNA_KOs/Scripts/R/Mine/0.general_use_functions.R")
# Get standard protein names
source("C:/MyStuff/tRNA_KOs/Code/R/Mine/0.general_use_functions.R")
microarray_data <- match_systematic_and_standard_protein_names(data = microarray_data,
yeastmine = yeastmine,
input = "systematic",
simplify = FALSE,
add_extra_columns = FALSE)
# Join with our proteomics data - not too sure if this merge is the most appropriate way to do it, even though I think so?
trna_ko_temp <- trna_ko %>%
mutate(Gene.symbol = rownames(trna_ko))
proteomics_and_microarray_data <- left_join(trna_ko_temp, microarray_data, by = "Gene.symbol") # IM KEEPING ALL PROTEINS IN TRNA_KO, THERE ARE ACTUALLY 2863 WHICH ARE IN BOTH, SO SOME IN TRNA_KO ARE NOT IN MICROARRAY_DATA, I SHOULD FIX THIS CODE SO THOSE ARE NOT INCLUDED IN THE RESULTING DATA SET
# Correlation heatmap between our samples
samples_in_microarray <- colnames(microarray_data)[2:6]
sample_names_escaped <- c("tM\\(CAU\\)C",  "tR\\(CCU\\)J",  "tR\\(UCU\\)M2", "tH\\(GUG\\)G1", "tL\\(GAG\\)G")
proteomics_and_microarray_subset <- data.frame(matrix(nrow = nrow(proteomics_and_microarray_data), ncol = 0))
for (i in 1:length(samples_in_microarray)) {
sample_name <- sample_names_escaped[i]
temp <- proteomics_and_microarray_data[, grepl(sample_name, colnames(proteomics_and_microarray_data))]
proteomics_and_microarray_subset <- cbind(proteomics_and_microarray_subset, temp)
}
cormat <- round(cor(proteomics_and_microarray_subset, use = "pairwise.complete.obs", method = "kendall"), 2)
melted_cormat <- melt(cormat)
ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) +
geom_tile() +
geom_text(aes(Var2, Var1, label = value), size = 3) +
scale_fill_gradient2(low = "blue", high = "red",
limit = c(-1,1), name="Correlation") +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.background = element_blank(),
axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
# Remove unnecessary objects
list_for_venn_diagram <- list(Proteomics = rownames(trna_ko),
Transcriptomics = microarray_data$Gene.symbol)
ggvenn(
list_for_venn_diagram,
fill_color = c("#80AAFF", "#FF8080"),
stroke_size = 0.5, set_name_size = 4
)
test <- microarray_data %>% select(-Gene.secondaryIdentifier, -Gene.symbol)
corrs <- round(cor(test, use = "pairwise.complete.obs"), 2)
melted_corrs <- melt(corrs)
ggplot(data = melted_corrs, aes(x=Var1, y=Var2, fill=value)) +
geom_tile() +
geom_text(aes(Var2, Var1, label = value), size = 3) +
scale_fill_gradient2(low = "blue", high = "red",
limit = c(-1,1), name="Correlation") +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.background = element_blank(),
axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
# Remove unnecessary variables
rm(test, corrs, melted_corrs)
# Grab columns of proteomics data with only samples from the strains for which there are microarray data
toMatch <- colnames(microarray_data)[2:6]
matches <- grepl(paste(toMatch,collapse="|"),
colnames(trna_ko))
MC_and_SC_proteomics <- trna_ko[, matches]
# Add MC or SC information to column names and sort columns by this so (expected) clusters are easily visible on heatmap
new_colnames <- c()
for (i in 1:ncol(MC_and_SC_proteomics)) {
old_colname <- colnames(MC_and_SC_proteomics)[i]
if (grepl(paste(c("UCU", "GUG"), collapse = "|"), old_colname))
new_colnames <- c(new_colnames, paste("MC", old_colname, sep = "_"))
else if ((grepl(paste(c("CCU", "GAG", "CAU"), collapse = "|"), old_colname)))
new_colnames <- c(new_colnames, paste("SC", old_colname, sep = "_"))
}
# Grab columns of proteomics data with only samples from the strains for which there are microarray data
matches <- grepl(paste(sample_names_escaped, collapse="|"),
colnames(trna_ko))
MC_and_SC_proteomics <- trna_ko[, matches]
# Add MC or SC information to column names and sort columns by this so (expected) clusters are easily visible on heatmap
new_colnames <- c()
for (i in 1:ncol(MC_and_SC_proteomics)) {
old_colname <- colnames(MC_and_SC_proteomics)[i]
if (grepl(paste(c("UCU", "GUG"), collapse = "|"), old_colname))
new_colnames <- c(new_colnames, paste("MC", old_colname, sep = "_"))
else if ((grepl(paste(c("CCU", "GAG", "CAU"), collapse = "|"), old_colname)))
new_colnames <- c(new_colnames, paste("SC", old_colname, sep = "_"))
}
colnames(MC_and_SC_proteomics) <- new_colnames
MC_and_SC_proteomics <- MC_and_SC_proteomics %>% select(order(colnames(MC_and_SC_proteomics)))
# Correlation heatmap
corrs <- round(cor(MC_and_SC_proteomics, use = "pairwise.complete.obs"), 2)
melted_corrs <- melt(corrs)
ggplot(data = melted_corrs, aes(x=Var1, y=Var2, fill=value)) +
geom_tile() +
geom_text(aes(Var2, Var1, label = value), size = 3) +
scale_fill_gradient2(low = "blue", high = "red",
limit = c(-1,1), name="Correlation") +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.background = element_blank(),
axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
# Remove unnecessary objects
rm(toMatch, matches, corrs, melted_corrs, old_colname, new_colnames)
corrs <- round(cor(trna_ko, use = "pairwise.complete.obs"), 2)
melted_corrs <- melt(corrs)
ggplot(data = melted_corrs, aes(x=Var1, y=Var2, fill=value)) +
geom_tile() +
scale_fill_gradient2(low = "blue", high = "red",
limit = c(-1,1), name="Correlation") +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.background = element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank())
microarray_samples <- colnames(microarray_data[2:6])
da_for_microarray_samples <- da %>% filter(ko %in% microarray_samples)
microarray_samples <- colnames(microarray_data[2:6])
da_for_microarray_samples <- da_full %>% filter(Strain.Name %in% microarray_samples)
for (i in 1:length(microarray_samples)) {
sample <- microarray_samples[i]
da_temp <- da_full %>%
filter(Strain.Name == sample) %>%
select(protein, diffexpressed, logFC, adj.P.Val)
colnames(da_temp) <- c("Gene.symbol", "diffexpressed", "logFC", "adj.P.Val")
microarray_temp <- microarray_data %>% select(all_of(sample), Gene.symbol)
test <- left_join(microarray_temp, da_temp, by = "Gene.symbol")
test <- inner_join(da_temp, microarray_temp, by = "Gene.symbol")
test <- test %>% mutate(diffexpressed = case_when(diffexpressed == "Up_regulated" ~ "Up_regulated",
diffexpressed == "Down_regulated" ~ "Down_regulated",
TRUE ~ "Not_significant"))
colnames(test) <- c("Gene.symbol", "diffexpressed", "logFC", "adj.P.Val", "logfold_microarray")
# Calculate correlation to add to plot
corr_coef <- round(cor(test$logFC, test$logfold_microarray, method = "spearman", use = "complete.obs"), 2)
# Protein names in X axis, transcriptomics fold change in Y axis, color by significance in proteomics - not such a good plot tbh
#p1 <- ggplot(data = test, aes(x = Gene.symbol, y = as.numeric(logfold_microarray), col = diffexpressed)) +
#  geom_point() +
#  labs(title = sample,
#       col = "Differentially\nexpressed\nin proteomics\ndata") +
#  xlab("Protein name") +
#  ylab("Transcriptomics fold change") +
#  theme(axis.text.x=element_blank(),
#      axis.ticks.x=element_blank()) +
#  geom_text(data = subset(test, diffexpressed == "Up_regulated" | diffexpressed == "Down_regulated"),
#            aes(x = Gene.symbol, y = as.numeric(logfold_microarray), col = diffexpressed, label = Gene.symbol),
#            size = 5)
#print(p1)
# logFC transcriptomics vs. logFC proteomics - color by significance in proteomics: much better
p2 <- ggplot(data = test, aes(x = logFC, y = logfold_microarray, col = diffexpressed)) +
geom_point(size = 1.5) +
labs(title = glue('{sample} - correlation coef. = {corr_coef}'),
col = "Differentially\nexpressed\nin proteomics\ndata") +
xlab("logFC proteomics") +
ylab("logFC transcriptomics") +
theme_light() +
geom_text_repel(data = subset(test, diffexpressed == "Up_regulated" | diffexpressed == "Down_regulated"),
aes(x = logFC, y = logfold_microarray, col = diffexpressed, label = Gene.symbol),
size = 4) +
geom_abline() +
scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
print(p2)
# This is just to check if the FCs from the microarrays data are also log2FCs, which I think so but their article says only FC
#hist(test$logfold_microarray)
#hist(test$logFC)
#hist((test$logFC)^2)
}
gc()
