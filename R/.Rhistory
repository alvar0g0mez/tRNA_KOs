library(wesanderson)
library(forcats)
library(ggpubr)
library(xtable)
library(clusterProfiler)
library(org.Sc.sgd.db)
library(fgsea)
library(limpa)
# Significance level to be used for all tests and plots in this file
alpha <- 0.05
# Significance level as a plain string to use when loading or writing files
alpha_plain <- str_replace(as.character(alpha), "\\.", "")
# Minimum threshold for the average log2-expression across all samples in order to keep a protein in the data before DE analysis
mean_log2_across_all_samples_threshold <- 2
# Minimum threshold for the variance of the log2-expression across all samples in order to keep a protein in the data before DE analysis
var_across_log2_all_samples_threshold <- 0.6
# Separate significance level, the one used for the enrichment analysis
alpha_enrichment <- 0.05
# Significance level above as a plain string to use when loading or writing files
alpha_enrichment_plain <- str_replace(as.character(alpha_enrichment), "\\.", "")
# Log-fold change limit to be considered "biologically significant"
lfc_threshold <- 0.5
# Set directories to be used
working_from = "charite"
if (working_from == "home") {
base_dir = "/home/alvaro/MyStuff/"
} else
if (working_from == "charite") {
base_dir = "C:/MyStuff/"
}
# Proteomics data
proteomics_raw <- read.delim2(paste(base_dir, 'tRNA_KOs/Data/proteomics_data/AlternativeAAUsage-tRNA_peptidecentric_ProteinMaxLFQ_driftcorrected_batchcorrected_onWTs.tsv', sep=""), header = T)
# Sample layout
sample_layout <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/basic/sample_layout_alvaro.tsv", sep="")))
View(proteomics_raw)
View(sample_layout)
rm(proteomics_raw)
# Protein abundances - limpa output
y.protein <- readRDS(paste(base_dir, "tRNA_KOs/Data/limpa_analysis/y.protein.rds", sep=""))
trna_ko <- y.protein$E
rm(y.protein)
# Sample layout
sample_layout <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/basic/sample_layout_alvaro.tsv", sep="")))
View(trna_ko)
knitr::opts_chunk$set(echo = TRUE)
dpcfit <- readRDS(paste(base_dir, "Data/Other/limpa_analysis/dpcfit.rds", sep=""))
dpcfit <- readRDS(paste(base_dir, "Data/limpa_analysis/dpcfit.rds", sep=""))
dpcfit <- readRDS(paste(base_dir, "tRNA_KOs/Data/limpa_analysis/dpcfit.rds", sep=""))
y.protein <- readRDS(paste(base_dir, "tRNA_KOs/Data/limpa_analysis/y.protein.rds", sep=""))
View(dpcfit)
View(y.protein)
sum(y.protein$genes$Protein == rownames(y.protein$E))
dpcfit <- readRDS(paste(base_dir, "tRNA_KOs/Data/limpa_analysis/dpcfit.rds", sep=""))
y.protein <- readRDS(paste(base_dir, "tRNA_KOs/Data/limpa_analysis/y.protein.rds", sep=""))
# UniProt dataset
uniprot_db <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv", sep="")))
# Change the protein names from the UniProt ones (produced by DIA-NN) to systematic Sc ones
## For the rownames of y.protein$E
temp_uniprot <- uniprot_db %>%
dplyr::select(Entry, `Gene Names (ordered locus)`) %>%
dplyr::rename(Gene.secondaryIdentifier = `Gene Names (ordered locus)`)
temp_rownames <- data.frame(rownames(y.protein$E))
colnames(temp_rownames) <- "Entry"
temp_rownames <- temp_rownames %>%
left_join(temp_uniprot, by = "Entry")
## For the protein names (they are the same and should be in the same order, but I do it separately just in case), stored in y.protein$genes$Protein
temp_protein_names <- data.frame(y.protein$genes$Protein)
colnames(temp_protein_names) <- "Entry"
temp_protein_names <- temp_protein_names %>%
left_join(temp_uniprot, by = "Entry")
# Some systematic names contain 2 of them - I have to deal with that - I'M TAKING THE FIRST ONE, HOPE THAT'S NOT TOO BAD
remove_second_systematic_name <- function(name) {
if (grepl(";", name)) {
new_name <- substr(name, 0, str_locate(name, ";")[1]-1)
}
else {
new_name <- name
}
return(new_name)
}
# Remove the second systematic names wherever it's present and set the new names to the limpa output object to be saved
## For y.protein$E rownames
temp_rownames$Gene.secondaryIdentifier <- sapply(temp_rownames$Gene.secondaryIdentifier, remove_second_systematic_name)
ronames(y.protein$E) <- temp_rownames$Gene.secondaryIdentifier
rownames(y.protein$E) <- temp_rownames$Gene.secondaryIdentifier
## For y.protein$genes$Protein
temp_protein_names$Gene.secondaryIdentifier <- sapply(temp_protein_names$Gene.secondaryIdentifier, remove_second_systematic_name)
y.protein$genes$Protein <- temp_protein_names$Gene.secondaryIdentifier
rownames(y.protein$E)
sum(rownames(y.protein$E) == y.protein$genes$Protein)
# As .rds
saveRDS(dpcfit, file = paste(base_dir, "tRNA_KOs/Data/limpa_analysis/dpcfit.rds", sep=""))
saveRDS(y.protein, file = paste(base_dir, "tRNA_KOs/Data/limpa_analysis/y.protein.rds", sep=""))
gc()
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(data.table)
library(limma)
library(ggplot2)
library(patchwork)
library(tidyr)
library(tibble)
library(stringr)
library(gprofiler2)
library(xlsx)
library(stringr)
library(gridExtra)
library(grid)
suppressPackageStartupMessages(library(ComplexHeatmap))
suppressPackageStartupMessages(library(circlize))
library(factoextra)
library(glue)
library(dendextend)
library(ggrepel)
library(ggvenn)
library(tidyr)
library(interactions)
library(performance)
library(MASS)
library(jsonlite)
library(UpSetR)
library(ComplexUpset)
library(wesanderson)
library(forcats)
library(ggpubr)
library(xtable)
library(clusterProfiler)
library(org.Sc.sgd.db)
library(fgsea)
library(limpa)
# Significance level to be used for all tests and plots in this file
alpha <- 0.05
# Significance level as a plain string to use when loading or writing files
alpha_plain <- str_replace(as.character(alpha), "\\.", "")
# Minimum threshold for the average log2-expression across all samples in order to keep a protein in the data before DE analysis
mean_log2_across_all_samples_threshold <- 2
# Minimum threshold for the variance of the log2-expression across all samples in order to keep a protein in the data before DE analysis
var_across_log2_all_samples_threshold <- 0.6
# Separate significance level, the one used for the enrichment analysis
alpha_enrichment <- 0.05
# Significance level above as a plain string to use when loading or writing files
alpha_enrichment_plain <- str_replace(as.character(alpha_enrichment), "\\.", "")
# Log-fold change limit to be considered "biologically significant"
lfc_threshold <- 0.5
# Set directories to be used
working_from = "charite"
if (working_from == "home") {
base_dir = "/home/alvaro/MyStuff/"
} else
if (working_from == "charite") {
base_dir = "C:/MyStuff/"
}
# Protein abundances - limpa output
y.protein <- readRDS(paste(base_dir, "tRNA_KOs/Data/limpa_analysis/y.protein.rds", sep=""))
trna_ko <- y.protein$E
rm(y.protein)
# Sample layout
sample_layout <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/basic/sample_layout_alvaro.tsv", sep="")))
View(trna_ko)
View(sample_layout)
# Set the columns in the order I want to have them - by amino acid loaded and by anticodon
sample_layout <- sample_layout %>%
dplyr::arrange(desc(Amino_acid_1_letter), desc(Anticodon))
# Set the columns in the order I want to have them - by amino acid loaded and by anticodon
sample_layout <- sample_layout %>%
dplyr::arrange(Amino_acid_1_letter, Anticodon)
desired_order <- as.character(sample_layout$final_proteomics_colnames)
desired_order <- as.character(sample_layout$final_proteomics_colnames)
trna_ko <- trna_ko %>%
dplyr::select(desired_order)
trna_ko <- as.data.frame(y.protein$E)
# Protein abundances - limpa output
y.protein <- readRDS(paste(base_dir, "tRNA_KOs/Data/limpa_analysis/y.protein.rds", sep=""))
trna_ko <- as.data.frame(y.protein$E)
rm(y.protein)
desired_order <- as.character(sample_layout$final_proteomics_colnames)
trna_ko <- trna_ko %>%
dplyr::select(desired_order)
desired_order <- desired_order[desired_order %in% colnames(trna_ko)]
trna_ko <- trna_ko %>%
dplyr::select(desired_order)
View(trna_ko)
# Import the functions I have created in another file
source(paste(base_dir, "tRNA_KOs/Code/R/Mine/0.general_use_functions.R", sep=""))
# Prepare heatmap data: correlation and melt
cormat <- cor(trna_ko)
View(cormat)
melted_cormat <- melt(cormat)
View(melted_cormat)
# Plot
ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) +
geom_tile() +
geom_text(aes(Var2, Var1, label = value), size = 3) +
scale_fill_gradient2(low = "blue", high = "red",
limit = c(-1,1), name="Correlation") +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.background = element_blank(),
axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
# Plot
ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) +
geom_tile() +
scale_fill_gradient2(low = "blue", high = "red",
limit = c(-1,1), name="Correlation") +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.background = element_blank(),
axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
View(cormat)
clust_df <- trna_ko
clust_df <- as.data.frame(t(clust_df))
clust_df <- scale(clust_df)
fviz_nbclust(clust_df, kmeans, method = "wss", k.max = 15)
a <- 2200000-1600000
a/2200000
perform_clustering <- function(tmp, dist_method, clust_method, num_of_clusters, want_dendrogram = T, want_clust_plot = T) {
# Get distance matrix based on Euclidean distance
dist.euc <- dist(tmp, method = dist_method)
# Perform clustering
tree.complete <- hclust(dist.euc, method = clust_method)
# Plot dendrogram
if (want_dendrogram) {
plot(tree.complete, cex = 0.3,
main = glue("Dendrogram for clustering with {clust_method} link"),
xlab = glue("{dist_method} distance"))
rect.hclust(tree.complete , k = num_of_clusters)
}
if (want_dendrogram) {
dend_obj <- as.dendrogram(tree.complete)
col_dend <- color_branches(dend_obj, k = num_of_clusters)
labels_cex(col_dend)
plot(col_dend)
}
# Visualize clusters
my_clusters <- cutree(tree.complete, k = num_of_clusters)
if (want_clust_plot) {print(fviz_cluster(list(data = tmp, cluster = my_clusters), main = glue("Clustering by {clust_method} link")))}
return(my_clusters)
}
# Use this function to do clustering: k = 2
my_clusters <- perform_clustering(clust_df, "euclidean", "complete", 2)
# Heatmap on the original log2 proteomics data
mat = as.matrix(trna_ko)
col_fun = colorRamp2(c(5, 12.5, 20), c("blue", "white", "red"))     # Not using this now but this is how you do it
Heatmap(mat,
name = "Heatmap",
col = col_fun,
na_col = "black",
row_title = "Proteins",
column_title = "Samples",
#cluster_rows = FALSE,                  # Turn row clustering off, I assume we already know the relationships between the genes
column_dend_height = unit(2, "cm"),
show_row_names = FALSE,
column_names_gp = gpar(fontsize = 5))
# Heatmap with z-score based on median per row
mat_zscore = t(apply(trna_ko, 1, function(x) (x-median(x, na.rm = T))/mad(x, na.rm = T)))
col_fun = colorRamp2(c(-4, -2, 0, 2, 4), c("blue", "blue", "white", "red", "red"))
Heatmap(mat_zscore,
name = "Heatmap",
#col = col_fun,
na_col = "green",
row_title = "Proteins",
column_title = "Samples",
#column_labels = grepl("QC", colnames(mat_zscore)),
#cluster_rows = FALSE,                  # Turn row clustering off, I assume we already know the relationships between the genes
column_dend_height = unit(2, "cm"),
show_row_names = FALSE,
column_names_gp = gpar(fontsize = 5))
# Heatmap with per-gene log2 FC across strains (compared to median of gene across all strains)
temp = t(apply(trna_ko, 1, function(x) x/median(x, na.rm = T)))
mat_log2FC = log2(temp)
col_fun = colorRamp2(c(-2, -1, 0, 1, 2), c("blue", "blue", "white", "red", "red"))
Heatmap(mat_log2FC,
name = "Heatmap",
col = col_fun,
na_col = "green",
row_title = "Proteins",
column_title = "Samples",
#cluster_rows = FALSE,                  # Turn row clustering off, I assume we already know the relationships between the genes
column_dend_height = unit(2, "cm"),
show_row_names = FALSE,                # When I use this, rows are not ordered by abundance anymore :(
column_names_gp = gpar(fontsize = 5))
max(melted_cormat$value)
min(melted_cormat$value)
# Plot
ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) +
geom_tile() +
scale_fill_gradient2(low = "blue", high = "red",
limit = c(min(melted_cormat$value),max(melted_cormat$value)), name="Correlation") +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.background = element_blank(),
axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
# Plot
ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) +
geom_tile() +
scale_fill_gradient2(low = "blue", high = "red",
limit = c(min(melted_cormat$value),max(melted_cormat$value)),
name="Correlation",
midpoint = mean(c(min(melted_cormat$value),max(melted_cormat$value)))) +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.background = element_blank(),
axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
# Plot
ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) +
geom_tile() +
scale_fill_gradient2(low = "blue", high = "red",
limit = c(min(melted_cormat$value),max(melted_cormat$value)),
name="Correlation",
midpoint = mean(c(min(melted_cormat$value),max(melted_cormat$value)))) +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.background = element_blank(),
axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 0.1),
axis.text.y = element_text(vjust = 1, hjust = 1, size = 0.1))
# Look at the distribution of the correlations
ggplot(data = melted_cormat, aes(x = value)) +
geom_histogram() +
theme_light()
# Look at the distribution of the correlations
ggplot(data = melted_cormat, aes(x = value)) +
geom_histogram(fill = "grey", col = "black") +
theme_light()
# Look at the distribution of the correlations
ggplot(data = melted_cormat, aes(x = value)) +
geom_histogram(fill = "grey", col = "black") +
theme_light() +
labs(title = "Distribution of the correlation scores between full proteome of all pairs of samples")
# Look at the distribution of the correlations
ggplot(data = melted_cormat, aes(x = value)) +
geom_histogram(fill = "grey", col = "black") +
theme_light() +
labs(title = "Distribution of the correlation scores between full proteome of all pairs of samples") +
xlab("Correlation") +
ylab("Count")
# Remove highly unvariable proteins - NOT SURE IF THIS IS A GOOD IDEA, I'M JUST TRYING TO GET SOME LOWER CORRELATIONS
protein_variability <- apply(trna_ko, 1, var(na.rm = T))
# Remove highly unvariable proteins - NOT SURE IF THIS IS A GOOD IDEA, I'M JUST TRYING TO GET SOME LOWER CORRELATIONS
protein_variability <- apply(trna_ko, 1, function(x) var(x, na.rm = T))
hist(protein_variability)
most_variable_proteins <- rownames(trna_ko)[protein_variability > 0.4]
trna_ko_high_var <- trna_ko[rownames(trna_ko) %in% most_variable_proteins,]
cormat <- cor(trna_ko_high_var)
melted_cormat <- melt(cormat)
# All correlations are extremely high, I guess this is why we use Z-scores or whatever for clustering and heatmaps with the whole dataset?? Because all correlations are really high because the vast majority of proteins will have similar abundances across all samples??
# Plot
ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) +
geom_tile() +
scale_fill_gradient2(low = "blue", high = "red",
limit = c(min(melted_cormat$value),max(melted_cormat$value)),
name="Correlation",
midpoint = mean(c(min(melted_cormat$value),max(melted_cormat$value)))) +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.background = element_blank(),
axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 0.1),
axis.text.y = element_text(vjust = 1, hjust = 1, size = 0.1))
# Look at the distribution of the correlations
ggplot(data = melted_cormat, aes(x = value)) +
geom_histogram(fill = "grey", col = "black") +
theme_light() +
labs(title = "Distribution of the correlation scores between full proteome of all pairs of samples") +
xlab("Correlation") +
ylab("Count")
# Heatmap on the original log2 proteomics data
mat = as.matrix(trna_ko)
col_fun = colorRamp2(c(5, 12.5, 20), c("blue", "white", "red"))     # Not using this now but this is how you do it
Heatmap(mat,
name = "Heatmap",
#col = col_fun,
na_col = "black",
row_title = "Proteins",
column_title = "Samples",
#cluster_rows = FALSE,                  # Turn row clustering off, I assume we already know the relationships between the genes
column_dend_height = unit(2, "cm"),
show_row_names = FALSE,
column_names_gp = gpar(fontsize = 5))
# Heatmap with z-score based on median per row
mat_zscore = t(apply(trna_ko, 1, function(x) (x-median(x, na.rm = T))/mad(x, na.rm = T)))
col_fun = colorRamp2(c(-4, -2, 0, 2, 4), c("blue", "blue", "white", "red", "red"))
Heatmap(mat_zscore,
name = "Heatmap",
#col = col_fun,
na_col = "green",
row_title = "Proteins",
column_title = "Samples",
#column_labels = grepl("QC", colnames(mat_zscore)),
#cluster_rows = FALSE,                  # Turn row clustering off, I assume we already know the relationships between the genes
column_dend_height = unit(2, "cm"),
show_row_names = FALSE,
column_names_gp = gpar(fontsize = 5))
# Heatmap with per-gene log2 FC across strains (compared to median of gene across all strains)
temp = t(apply(trna_ko, 1, function(x) x/median(x, na.rm = T)))
mat_log2FC = log2(temp)
col_fun = colorRamp2(c(-2, -1, 0, 1, 2), c("blue", "blue", "white", "red", "red"))
Heatmap(mat_log2FC,
name = "Heatmap",
col = col_fun,
na_col = "green",
row_title = "Proteins",
column_title = "Samples",
#cluster_rows = FALSE,                  # Turn row clustering off, I assume we already know the relationships between the genes
column_dend_height = unit(2, "cm"),
show_row_names = FALSE,                # When I use this, rows are not ordered by abundance anymore :(
column_names_gp = gpar(fontsize = 5))
# Heatmap on the original log2 proteomics data
mat = as.matrix(trna_ko)
col_fun = colorRamp2(c(5, 12.5, 20), c("blue", "white", "red"))     # Not using this now but this is how you do it
Heatmap(mat,
name = "Heatmap",
#col = col_fun,
na_col = "black",
row_title = "Proteins",
column_title = "Samples",
#cluster_rows = FALSE,                  # Turn row clustering off, I assume we already know the relationships between the genes
column_dend_height = unit(2, "cm"),
show_row_names = FALSE,
column_names_gp = gpar(fontsize = 5))
# Heatmap with z-score based on median per row
# So this is basically focusing on the variability of each protein across all the samples - removing the basal "effect" of that protein
mat_zscore = t(apply(trna_ko, 1, function(x) (x-median(x, na.rm = T))/mad(x, na.rm = T)))
col_fun = colorRamp2(c(-4, -2, 0, 2, 4), c("blue", "blue", "white", "red", "red"))
Heatmap(mat_zscore,
name = "Heatmap",
#col = col_fun,
na_col = "green",
row_title = "Proteins",
column_title = "Samples",
#column_labels = grepl("QC", colnames(mat_zscore)),
#cluster_rows = FALSE,                  # Turn row clustering off, I assume we already know the relationships between the genes
column_dend_height = unit(2, "cm"),
show_row_names = FALSE,
column_names_gp = gpar(fontsize = 5))
# Heatmap with per-gene log2 FC across strains (compared to median of gene across all strains)
# Here I'm normalizing the values for each protein by dividing them by the median abundance of that protein
temp = t(apply(trna_ko, 1, function(x) x/median(x, na.rm = T)))
mat_log2FC = log2(temp)
col_fun = colorRamp2(c(-2, -1, 0, 1, 2), c("blue", "blue", "white", "red", "red"))
Heatmap(mat_log2FC,
name = "Heatmap",
#col = col_fun,
na_col = "green",
row_title = "Proteins",
column_title = "Samples",
#cluster_rows = FALSE,                  # Turn row clustering off, I assume we already know the relationships between the genes
column_dend_height = unit(2, "cm"),
show_row_names = FALSE,                # When I use this, rows are not ordered by abundance anymore :(
column_names_gp = gpar(fontsize = 5))
# Set the columns in the order I want to have them - by amino acid loaded and by anticodon
sample_layout <- sample_layout %>%
dplyr::arrange(Amino_acid_1_letter, Anticodon)
desired_order <- as.character(sample_layout$final_proteomics_colnames)
desired_order <- desired_order[desired_order %in% colnames(trna_ko)]
trna_ko <- trna_ko %>%
dplyr::select(desired_order)
# Remove highly unvariable proteins - NOT SURE IF THIS IS A GOOD IDEA, I'M JUST TRYING TO GET SOME LOWER CORRELATIONS
protein_variability <- apply(trna_ko, 1, function(x) var(x, na.rm = T))
hist(protein_variability)
most_variable_proteins <- rownames(trna_ko)[protein_variability > 0.4]
trna_ko_high_var <- trna_ko[rownames(trna_ko) %in% most_variable_proteins,]
# Prepare heatmap data: correlation and melt
## Standard, full dataset
cormat <- cor(trna_ko)
melted_cormat <- melt(cormat)
## Keeping only highly variable proteins
cormat_high_var <- cor(trna_ko_high_var)
melted_cormat_high_var <- melt(cormat_high_var)
# All correlations are extremely high, I guess this is why we use Z-scores or whatever for clustering and heatmaps with the whole dataset?? Because all correlations are really high because the vast majority of proteins will have similar abundances across all samples??
# Plot - full dataset
ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) +
geom_tile() +
scale_fill_gradient2(low = "blue", high = "red",
limit = c(min(melted_cormat$value),max(melted_cormat$value)),
name="Correlation",
midpoint = mean(c(min(melted_cormat$value),max(melted_cormat$value)))) +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.background = element_blank(),
axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 0.1),
axis.text.y = element_text(vjust = 1, hjust = 1, size = 0.1)) +
labs(title = "Correlation matrix between full proteomes",
subtitle = "With full dataset")
# Look at the distribution of the correlations - full dataset
ggplot(data = melted_cormat, aes(x = value)) +
geom_histogram(fill = "grey", col = "black") +
theme_light() +
labs(title = "Distribution of the correlation scores between full proteome of all pairs of samples",
subtitle = "With full dataset") +
xlab("Correlation") +
ylab("Count")
# Plot - only highly variable proteins
ggplot(data = melted_cormat_high_var, aes(x=Var1, y=Var2, fill=value)) +
geom_tile() +
scale_fill_gradient2(low = "blue", high = "red",
limit = c(min(melted_cormat_high_var$value),max(melted_cormat_high_var$value)),
name="Correlation",
midpoint = mean(c(min(melted_cormat_high_var$value),max(melted_cormat_high_var$value)))) +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.background = element_blank(),
axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 0.1),
axis.text.y = element_text(vjust = 1, hjust = 1, size = 0.1)) +
labs(title = "Correlation matrix between full proteomes",
subtitle = "With only highly variable proteins")
# Look at the distribution of the correlations - only highly variable proteins
ggplot(data = melted_cormat_high_var, aes(x = value)) +
geom_histogram(fill = "grey", col = "black") +
theme_light() +
labs(title = "Distribution of the correlation scores between full proteome of all pairs of samples",
subtitle = "With only highly variable proteins") +
xlab("Correlation") +
ylab("Count")
