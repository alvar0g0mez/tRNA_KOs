# For each anticodon, grab the tRNAs that contain it, and get a matrix with the right format for an upset plot
anticodon <- anticodons[i]
KOs_with_anticodon <- de_protein_list[grepl(anticodon, names(de_protein_list))]
KOs_with_anticodon_names <- names(KOs_with_anticodon)
# This is so I don't process anticodons for which there is only one KO - there is an error if I do so
if (length(KOs_with_anticodon) > 1) {
# Create the matrix where I will add one-hot encoded columns for each KO
all_proteins_anticodon <- unlist(KOs_with_anticodon)
df_to_upset <- data.frame(Proteins = all_proteins_anticodon)
# Iterate over the KO strains and add a one-hot encoded column for each of them, for presence/absence of that protein among the DE prots in that strain
for (j in 1:length(KOs_with_anticodon_names)) {
KO <- KOs_with_anticodon_names[j]
proteins <- KOs_with_anticodon[[KO]]
df_to_upset[,KO] <- as.numeric(all_proteins_anticodon %in% proteins)
}
}
# Now that we have the dataframe, get the Upset plot and save it to the list
upset_plots_list[[i]] <- upset(df_to_upset)
}
## Print to PDF
my_grobs <- lapply(upset_plots_list, ggplotGrob)
View(df_to_upset)
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list_001)
anticodons <- unique(responsiveness$anticodon)
upset_plots_list <- list()
# Iterate over the anticodons and get an Upset plot for each of them
pdf(file = paste(base_dir, "Output/Plots/compare_DEPs_across_KOs/upset/upset_plots_per_anticodon.pdf", sep = ""))
par(mfrow = c(2,2))
for (i in 1:length(anticodons)) {
# For each anticodon, grab the tRNAs that contain it, and get a matrix with the right format for an upset plot
anticodon <- anticodons[i]
KOs_with_anticodon <- de_protein_list[grepl(anticodon, names(de_protein_list))]
KOs_with_anticodon_names <- names(KOs_with_anticodon)
# This is so I don't process anticodons for which there is only one KO - there is an error if I do so
if (length(KOs_with_anticodon) > 1) {
# Create the matrix where I will add one-hot encoded columns for each KO
all_proteins_anticodon <- unlist(KOs_with_anticodon)
df_to_upset <- data.frame(Proteins = all_proteins_anticodon)
# Iterate over the KO strains and add a one-hot encoded column for each of them, for presence/absence of that protein among the DE prots in that strain
for (j in 1:length(KOs_with_anticodon_names)) {
KO <- KOs_with_anticodon_names[j]
proteins <- KOs_with_anticodon[[KO]]
df_to_upset[,KO] <- as.numeric(all_proteins_anticodon %in% proteins)
}
}
# Now that we have the dataframe, get the Upset plot and save it to the list
upset(df_to_upset)
}
dev.off()
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list_001)
anticodons <- unique(responsiveness$anticodon)
upset_plots_list <- list()
# Iterate over the anticodons and get an Upset plot for each of them
pdf(file = paste(base_dir, "Output/Plots/compare_DEPs_across_KOs/upset/upset_plots_per_anticodon.pdf", sep = ""))
par(mfrow = c(2,2))
for (i in 1:length(anticodons)) {
# For each anticodon, grab the tRNAs that contain it, and get a matrix with the right format for an upset plot
anticodon <- anticodons[i]
KOs_with_anticodon <- de_protein_list[grepl(anticodon, names(de_protein_list))]
KOs_with_anticodon_names <- names(KOs_with_anticodon)
# This is so I don't process anticodons for which there is only one KO - there is an error if I do so
if (length(KOs_with_anticodon) > 1) {
# Create the matrix where I will add one-hot encoded columns for each KO
all_proteins_anticodon <- unlist(KOs_with_anticodon)
df_to_upset <- data.frame(Proteins = all_proteins_anticodon)
# Iterate over the KO strains and add a one-hot encoded column for each of them, for presence/absence of that protein among the DE prots in that strain
for (j in 1:length(KOs_with_anticodon_names)) {
KO <- KOs_with_anticodon_names[j]
proteins <- KOs_with_anticodon[[KO]]
df_to_upset[,KO] <- as.numeric(all_proteins_anticodon %in% proteins)
}
}
# Now that we have the dataframe, get the Upset plot and save it to the list
upset(df_to_upset)
}
dev.off()
install.packages("library(ComplexUpset)")
install.packages("ComplexUpset")
library(ComplexUpset)
# Preparations:
#   - Remove KOs with 0 DE proteins from list,
#   - Grab anticodon names
#   - Create empty list to put data matrices for Upset plots there
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list_001)
anticodons <- unique(responsiveness$anticodon)
upset_plots_list <- list()
# Iterate over the anticodons and get an Upset plot for each of them
for (i in 1:length(anticodons)) {
# For each anticodon, grab the tRNAs that contain it, and get a matrix with the right format for an upset plot
anticodon <- anticodons[i]
KOs_with_anticodon <- de_protein_list[grepl(anticodon, names(de_protein_list))]
KOs_with_anticodon_names <- names(KOs_with_anticodon)
# This is so I don't process anticodons for which there is only one KO - there is an error if I do so
if (length(KOs_with_anticodon) > 1) {
# Create the matrix where I will add one-hot encoded columns for each KO
all_proteins_anticodon <- unlist(KOs_with_anticodon)
df_to_upset <- data.frame(Proteins = all_proteins_anticodon)
# Iterate over the KO strains and add a one-hot encoded column for each of them, for presence/absence of that protein among the DE prots in that strain
for (j in 1:length(KOs_with_anticodon_names)) {
KO <- KOs_with_anticodon_names[j]
proteins <- KOs_with_anticodon[[KO]]
df_to_upset[,KO] <- as.numeric(all_proteins_anticodon %in% proteins)
}
}
# Now that we have the dataframe, get the Upset plot and save it to the list
upset_plots_list[[i]] <- ComplexUpset::upset(df_to_upset)
}
movies = as.data.frame(ggplot2movies::movies)
movies = as.data.frame(ggplot2::movies)
install.packages("ggplot2movies")
library(ggplot2movies)
movies = as.data.frame(ggplot2movies::movies)
head(movies, 3)
genres = colnames(movies)[18:24]
genres
movies[genres] = movies[genres] == 1
t(head(movies[genres], 3))
movies[movies$mpaa == '', 'mpaa'] = NA
movies = na.omit(movies)
set_size(8, 3)
upset(movies, genres, name='genre', width_ratio=0.1)
View(movies)
View(df_to_upset)
# Preparations:
#   - Remove KOs with 0 DE proteins from list,
#   - Grab anticodon names
#   - Create empty list to put data matrices for Upset plots there
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list_001)
anticodons <- unique(responsiveness$anticodon)
upset_plots_list <- list()
# Iterate over the anticodons and get an Upset plot for each of them
for (i in 1:length(anticodons)) {
# For each anticodon, grab the tRNAs that contain it, and get a matrix with the right format for an upset plot
anticodon <- anticodons[i]
KOs_with_anticodon <- de_protein_list[grepl(anticodon, names(de_protein_list))]
KOs_with_anticodon_names <- names(KOs_with_anticodon)
# This is so I don't process anticodons for which there is only one KO - there is an error if I do so
if (length(KOs_with_anticodon) > 1) {
# Create the matrix where I will add one-hot encoded columns for each KO
all_proteins_anticodon <- unlist(KOs_with_anticodon)
df_to_upset <- data.frame(Proteins = all_proteins_anticodon)
# Iterate over the KO strains and add a one-hot encoded column for each of them, for presence/absence of that protein among the DE prots in that strain
for (j in 1:length(KOs_with_anticodon_names)) {
KO <- KOs_with_anticodon_names[j]
proteins <- KOs_with_anticodon[[KO]]
df_to_upset[,KO] <- as.numeric(all_proteins_anticodon %in% proteins)
}
}
# Now that we have the dataframe, get the Upset plot and save it to the list
upset_plots_list[[i]] <- ComplexUpset::upset(data = df_to_upset,
intersect = KOs_with_anticodon_names,
name='KO strain',
width_ratio=0.1)
}
# Preparations:
#   - Remove KOs with 0 DE proteins from list,
#   - Grab anticodon names
#   - Create empty list to put data matrices for Upset plots there
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list_001)
anticodons <- unique(responsiveness$anticodon)
upset_plots_list <- list()
# Iterate over the anticodons and get an Upset plot for each of them
for (i in 1:length(anticodons)) {
# For each anticodon, grab the tRNAs that contain it, and get a matrix with the right format for an upset plot
anticodon <- anticodons[i]
KOs_with_anticodon <- de_protein_list[grepl(anticodon, names(de_protein_list))]
KOs_with_anticodon_names <- names(KOs_with_anticodon)
# This is so I don't process anticodons for which there is only one KO - there is an error if I do so
if (length(KOs_with_anticodon) > 1) {
# Create the matrix where I will add one-hot encoded columns for each KO
all_proteins_anticodon <- unlist(KOs_with_anticodon)
df_to_upset <- data.frame(Proteins = all_proteins_anticodon)
# Iterate over the KO strains and add a one-hot encoded column for each of them, for presence/absence of that protein among the DE prots in that strain
for (j in 1:length(KOs_with_anticodon_names)) {
KO <- KOs_with_anticodon_names[j]
proteins <- KOs_with_anticodon[[KO]]
df_to_upset[,KO] <- as.numeric(all_proteins_anticodon %in% proteins)
}
# Now that we have the dataframe, get the Upset plot and save it to the list
upset_plots_list[[i]] <- ComplexUpset::upset(data = df_to_upset,
intersect = KOs_with_anticodon_names,
name='KO strain',
width_ratio=0.1)
}
}
## Print to PDF
my_grobs <- lapply(upset_plots_list, ggplotGrob)
View(upset_plots_list)
ggplotGrob(upset_plots_list[[1]])
ggplotGrob(upset_plots_list[[1]][[2]])
## Print to PDF
my_grobs <- lapply(upset_plots_list, ggplotGrob)
anticodons[[16]]
View(de_protein_list)
View(responsiveness)
i = 16
# For each anticodon, grab the tRNAs that contain it, and get a matrix with the right format for an upset plot
anticodon <- anticodons[i]
KOs_with_anticodon <- de_protein_list[grepl(anticodon, names(de_protein_list))]
KOs_with_anticodon_names <- names(KOs_with_anticodon)
length(KOs_with_anticodon) > 1
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list_001)
anticodons <- unique(responsiveness$anticodon)
upset_plots_list <- list()
# Iterate over the anticodons and get an Upset plot for each of them
for (i in 1:length(anticodons)) {
# For each anticodon, grab the tRNAs that contain it, and get a matrix with the right format for an upset plot
anticodon <- anticodons[i]
KOs_with_anticodon <- de_protein_list[grepl(anticodon, names(de_protein_list))]
KOs_with_anticodon_names <- names(KOs_with_anticodon)
# This is so I don't process anticodons for which there is only one KO - there is an error if I do so
if (length(KOs_with_anticodon) > 1) {
# Create the matrix where I will add one-hot encoded columns for each KO
all_proteins_anticodon <- unlist(KOs_with_anticodon)
df_to_upset <- data.frame(Proteins = all_proteins_anticodon)
# Iterate over the KO strains and add a one-hot encoded column for each of them, for presence/absence of that protein among the DE prots in that strain
for (j in 1:length(KOs_with_anticodon_names)) {
KO <- KOs_with_anticodon_names[j]
proteins <- KOs_with_anticodon[[KO]]
df_to_upset[,KO] <- as.numeric(all_proteins_anticodon %in% proteins)
}
# Now that we have the dataframe, get the Upset plot and save it to the list
upset_plots_list[[i]] <- ComplexUpset::upset(data = df_to_upset,
intersect = KOs_with_anticodon_names,
name='KO strain',
width_ratio=0.1)
}
}
View(upset_plots_list)
# Something wrong in that for-loop, I shouldn't end up with NULL elements in that list, we should not be generating anything and adding it to the list when length(KOs_with_anticodon) <= 1 -- there is a very clear "if" statement there to prevent that xd, no idea why it is not working
upset_plots_list <- upset_plots_list[!(is.null(upset_plots_list))]
is.null(upset_plots_list)
# Something wrong in that for-loop, I shouldn't end up with NULL elements in that list, we should not be generating anything and adding it to the list when length(KOs_with_anticodon) <= 1 -- there is a very clear "if" statement there to prevent that xd, no idea why it is not working
upset_plots_list <- upset_plots_list[!(lapply(upset_plots_list, is.null))]
sapply(upset_plots_list, is.null)
# Something wrong in that for-loop, I shouldn't end up with NULL elements in that list, we should not be generating anything and adding it to the list when length(KOs_with_anticodon) <= 1 -- there is a very clear "if" statement there to prevent that xd, no idea why it is not working
upset_plots_list <- upset_plots_list[!(sapply(upset_plots_list, is.null))]
my_grobs <- lapply(upset_plots_list, ggplotGrob)
output_file <- paste(base_dir, "Output/Plots/compare_DEPs_across_KOs/upset/upset_plots_per_anticodon.pdf", sep = "")
ggsave(
filename = output_file,
plot = marrangeGrob(my_grobs, nrow=3, ncol=3),
width = 15, height = 9
)
my_grobs <- lapply(upset_plots_list, ggplotGrob)
output_file <- paste(base_dir, "Output/Plots/compare_DEPs_across_KOs/upset/upset_plots_per_anticodon.pdf", sep = "")
ggsave(
filename = output_file,
plot = marrangeGrob(my_grobs, nrow=2, ncol=2),
width = 15, height = 9
)
ggsave(
filename = output_file,
plot = marrangeGrob(my_grobs, nrow=1, ncol=1),
width = 15, height = 9
)
ComplexUpset::upset(data = df_to_upset,
intersect = KOs_with_anticodon_names,
name='KO strain',
width_ratio=0.1)
ggsave(
filename = output_file,
plot = marrangeGrob(my_grobs, nrow=1, ncol=1),
width = 5, height = 3
)
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list_001)
anticodons <- unique(responsiveness$anticodon)
upset_plots_list <- list()
pdf(file = paste(base_dir, "Output/Plots/compare_DEPs_across_KOs/upset/upset_plots_per_anticodon.pdf", sep = ""), onefile = T, width = 12, height = 5, paper = 'USr')
# Iterate over the anticodons and get an Upset plot for each of them
for (i in 1:length(anticodons)) {
# For each anticodon, grab the tRNAs that contain it, and get a matrix with the right format for an upset plot
anticodon <- anticodons[i]
KOs_with_anticodon <- de_protein_list[grepl(anticodon, names(de_protein_list))]
KOs_with_anticodon_names <- names(KOs_with_anticodon)
# This is so I don't process anticodons for which there is only one KO - there is an error if I do so
if (length(KOs_with_anticodon) > 1) {
# Create the matrix where I will add one-hot encoded columns for each KO
all_proteins_anticodon <- unlist(KOs_with_anticodon)
df_to_upset <- data.frame(Proteins = all_proteins_anticodon)
# Iterate over the KO strains and add a one-hot encoded column for each of them, for presence/absence of that protein among the DE prots in that strain
for (j in 1:length(KOs_with_anticodon_names)) {
KO <- KOs_with_anticodon_names[j]
proteins <- KOs_with_anticodon[[KO]]
df_to_upset[,KO] <- as.numeric(all_proteins_anticodon %in% proteins)
}
# Now that we have the dataframe, get the Upset plot and save it to the list
ComplexUpset::upset(data = df_to_upset,
intersect = KOs_with_anticodon_names,
name='KO strain',
width_ratio=0.1)
}
}
dev.off()
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list_001)
anticodons <- unique(responsiveness$anticodon)
upset_plots_list <- list()
pdf(file = paste(base_dir, "Output/Plots/compare_DEPs_across_KOs/upset/upset_plots_per_anticodon.pdf", sep = ""), onefile = T, width = 12, height = 5, paper = 'USr')
# Iterate over the anticodons and get an Upset plot for each of them
for (i in 1:length(anticodons)) {
# For each anticodon, grab the tRNAs that contain it, and get a matrix with the right format for an upset plot
anticodon <- anticodons[i]
KOs_with_anticodon <- de_protein_list[grepl(anticodon, names(de_protein_list))]
KOs_with_anticodon_names <- names(KOs_with_anticodon)
# This is so I don't process anticodons for which there is only one KO - there is an error if I do so
if (length(KOs_with_anticodon) > 1) {
# Create the matrix where I will add one-hot encoded columns for each KO
all_proteins_anticodon <- unlist(KOs_with_anticodon)
df_to_upset <- data.frame(Proteins = all_proteins_anticodon)
# Iterate over the KO strains and add a one-hot encoded column for each of them, for presence/absence of that protein among the DE prots in that strain
for (j in 1:length(KOs_with_anticodon_names)) {
KO <- KOs_with_anticodon_names[j]
proteins <- KOs_with_anticodon[[KO]]
df_to_upset[,KO] <- as.numeric(all_proteins_anticodon %in% proteins)
}
# Now that we have the dataframe, get the Upset plot and save it to the list
p <- ComplexUpset::upset(data = df_to_upset,
intersect = KOs_with_anticodon_names,
name='KO strain',
width_ratio=0.1)
print(p)
}
}
dev.off()
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list_001)
anticodons <- unique(responsiveness$anticodon)
upset_plots_list <- list()
pdf(file = paste(base_dir, "Output/Plots/compare_DEPs_across_KOs/upset/upset_plots_per_anticodon.pdf", sep = ""), onefile = T, width = 12, height = 5, paper = 'USr')
par(mfrow = c(2,2))
# Iterate over the anticodons and get an Upset plot for each of them
for (i in 1:length(anticodons)) {
# For each anticodon, grab the tRNAs that contain it, and get a matrix with the right format for an upset plot
anticodon <- anticodons[i]
KOs_with_anticodon <- de_protein_list[grepl(anticodon, names(de_protein_list))]
KOs_with_anticodon_names <- names(KOs_with_anticodon)
# This is so I don't process anticodons for which there is only one KO - there is an error if I do so
if (length(KOs_with_anticodon) > 1) {
# Create the matrix where I will add one-hot encoded columns for each KO
all_proteins_anticodon <- unlist(KOs_with_anticodon)
df_to_upset <- data.frame(Proteins = all_proteins_anticodon)
# Iterate over the KO strains and add a one-hot encoded column for each of them, for presence/absence of that protein among the DE prots in that strain
for (j in 1:length(KOs_with_anticodon_names)) {
KO <- KOs_with_anticodon_names[j]
proteins <- KOs_with_anticodon[[KO]]
df_to_upset[,KO] <- as.numeric(all_proteins_anticodon %in% proteins)
}
# Now that we have the dataframe, get the Upset plot and save it to the list
p <- ComplexUpset::upset(data = df_to_upset,
intersect = KOs_with_anticodon_names,
name='KO strain',
width_ratio=0.1)
print(p)
}
}
dev.off()
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list_001)
anticodons <- unique(responsiveness$anticodon)
upset_plots_list <- list()
pdf(file = paste(base_dir, "Output/Plots/compare_DEPs_across_KOs/upset/upset_plots_per_anticodon.pdf", sep = ""), onefile = T, width = 12, height = 5, paper = 'USr')
par(mfrow = c(2,2))
# Iterate over the anticodons and get an Upset plot for each of them
for (i in 1:length(anticodons)) {
# For each anticodon, grab the tRNAs that contain it, and get a matrix with the right format for an upset plot
anticodon <- anticodons[i]
KOs_with_anticodon <- de_protein_list[grepl(anticodon, names(de_protein_list))]
KOs_with_anticodon_names <- names(KOs_with_anticodon)
# This is so I don't process anticodons for which there is only one KO - there is an error if I do so
if (length(KOs_with_anticodon) > 1) {
# Create the matrix where I will add one-hot encoded columns for each KO
all_proteins_anticodon <- unlist(KOs_with_anticodon)
df_to_upset <- data.frame(Proteins = all_proteins_anticodon)
# Iterate over the KO strains and add a one-hot encoded column for each of them, for presence/absence of that protein among the DE prots in that strain
for (j in 1:length(KOs_with_anticodon_names)) {
KO <- KOs_with_anticodon_names[j]
proteins <- KOs_with_anticodon[[KO]]
df_to_upset[,KO] <- as.numeric(all_proteins_anticodon %in% proteins)
}
# Now that we have the dataframe, get the Upset plot and save it to the list
p <- ComplexUpset::upset(data = df_to_upset,
intersect = KOs_with_anticodon_names,
name='KO strain',
width_ratio=0.1)
print(p)
}
}
dev.off()
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list_001)
anticodons <- unique(responsiveness$anticodon)
upset_plots_list <- list()
pdf(file = paste(base_dir, "Output/Plots/compare_DEPs_across_KOs/upset/upset_plots_per_anticodon.pdf", sep = ""), paper = 'USr')
par(mfrow = c(2,2))
# Iterate over the anticodons and get an Upset plot for each of them
for (i in 1:length(anticodons)) {
# For each anticodon, grab the tRNAs that contain it, and get a matrix with the right format for an upset plot
anticodon <- anticodons[i]
KOs_with_anticodon <- de_protein_list[grepl(anticodon, names(de_protein_list))]
KOs_with_anticodon_names <- names(KOs_with_anticodon)
# This is so I don't process anticodons for which there is only one KO - there is an error if I do so
if (length(KOs_with_anticodon) > 1) {
# Create the matrix where I will add one-hot encoded columns for each KO
all_proteins_anticodon <- unlist(KOs_with_anticodon)
df_to_upset <- data.frame(Proteins = all_proteins_anticodon)
# Iterate over the KO strains and add a one-hot encoded column for each of them, for presence/absence of that protein among the DE prots in that strain
for (j in 1:length(KOs_with_anticodon_names)) {
KO <- KOs_with_anticodon_names[j]
proteins <- KOs_with_anticodon[[KO]]
df_to_upset[,KO] <- as.numeric(all_proteins_anticodon %in% proteins)
}
# Now that we have the dataframe, get the Upset plot and save it to the list
p <- ComplexUpset::upset(data = df_to_upset,
intersect = KOs_with_anticodon_names,
name='KO strain',
width_ratio=0.1)
print(p)
}
}
dev.off()
library(data.table)
library(dplyr)
library(xlsx)
library(stringr)
#-----------------------------------------------------------------------------------------
# Set directories to be used
working_from = "home"
if (working_from == "home") {
base_dir = "/home/alvaro/MyStuff/tRNA_KOs/"
} else
if (working_from == "charite") {
base_dir = "C:/MyStuff/tRNA_KOs/"
}
#-----------------------------------------------------------------------------------------
# 1. Dealing with the database from GtRNAdb
# Load data
db <- read.xlsx(paste(base_dir, "Data/Other/GtRNAdb/GtRNAdb_gene_list.xlsx", sep=""), 1)
# 1.1. Come up with Intron and Mismatch columns from the Features column
## Create empty columns
db$Intron <- NA
db$Mismatch <- NA
for (i in 1:nrow(db)) {
# If we have mismatch information from the row above
if (grepl("mismatch", db$Features[i]) & is.na(db$Anticodon_and_isotype_model_agreement[i])) {
db$Mismatch[i-1] <- as.numeric(regmatches(db$Features[i], regexpr("(?<=: ).*", db$Features[i], perl = TRUE)))
#db <- db[-c(i),]
}
# If we have mismatch information from this row
else if (grepl("mismatch", db$Features[i])) {
db$Mismatch[i] <- as.numeric(regmatches(db$Features[i], regexpr("(?<=: ).*", db$Features[i], perl = TRUE)))
}
# If we have intron information (only possible for this row)
else if (grepl("intron", db$Features[i])) {
db$Intron[i] <- as.numeric(regmatches(db$Features[i], regexpr("(?<=: ).*", db$Features[i], perl = TRUE)))
}
}
## Remove rows that only contained mismatch information for the previous row
db <- subset(db, !is.na(Anticodon))
## Remove Features column
db <- db %>% select(-Features)
# Load libraries
library(data.table)
library(dplyr)
library(xlsx)
library(stringr)
#-----------------------------------------------------------------------------------------
# Set directories to be used
working_from = "home"
if (working_from == "home") {
base_dir = "/home/alvaro/MyStuff/tRNA_KOs/"
} else
if (working_from == "charite") {
base_dir = "C:/MyStuff/tRNA_KOs/"
}
#-----------------------------------------------------------------------------------------
# 1. Dealing with the database from GtRNAdb
# Load data
db <- read.xlsx(paste(base_dir, "Data/Other/GtRNAdb/GtRNAdb_gene_list.xlsx", sep=""), 1)
# 1.1. Come up with Intron and Mismatch columns from the Features column
## Create empty columns
db$Intron <- NA
db$Mismatch <- NA
for (i in 1:nrow(db)) {
# If we have mismatch information from the row above
if (grepl("mismatch", db$Features[i]) & is.na(db$Anticodon_and_isotype_model_agreement[i])) {
db$Mismatch[i-1] <- as.numeric(regmatches(db$Features[i], regexpr("(?<=: ).*", db$Features[i], perl = TRUE)))
#db <- db[-c(i),]
}
# If we have mismatch information from this row
else if (grepl("mismatch", db$Features[i])) {
db$Mismatch[i] <- as.numeric(regmatches(db$Features[i], regexpr("(?<=: ).*", db$Features[i], perl = TRUE)))
}
# If we have intron information (only possible for this row)
else if (grepl("intron", db$Features[i])) {
db$Intron[i] <- as.numeric(regmatches(db$Features[i], regexpr("(?<=: ).*", db$Features[i], perl = TRUE)))
}
}
## Remove rows that only contained mismatch information for the previous row
db <- subset(db, !is.na(Anticodon))
## Remove Features column
db <- db %>% dplyr::select(-Features)
## Turn NAs in these 2 columns into 0s
db <- db %>%
mutate(Intron = case_when(is.na(Intron) ~ 0,
TRUE ~ Intron),
Mismatch = case_when(is.na(Mismatch) ~ 0,
TRUE ~ Mismatch))
# 1.2. Match 3-letter codes to 1-letter codes
## Load dataframe with amino acid information
aas <- fread(paste(base_dir, "Data/Other/GtRNAdb/amino_acids.csv",sep=""))
aas <- as.data.frame(aas)
## Add new columns
aas_temp <- aas %>% dplyr::select(X3_letter_code, X1_letter_code)
master_dataset <- as.data.frame(fread("/home/alvaro/MyStuff/tRNA_KOs/Data/Other/GtRNAdb/master_tRNA_dataset.csv"))
View(master_dataset)
