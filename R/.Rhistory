rankings <- replace(rankings, rankings < min_ranking, min_ranking * 10)
rankings <- sort(rankings, decreasing = TRUE) # sort genes by ranking
# Add them to the list where we are saving them
ranked_genes[[names(da)[i]]] <- rankings
}
# Save this ranked lists so that I can use them later to pick the top 50 proteins in each strain, to look at the overlaps between major strains within families in a more unbiased manner - not really feasible for now since the distribution of the scores for the vast majority of strains is pretty much flat. I wonder how much this affects my DEA?
write_json(ranked_genes, path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/lists_of_ranked_genes_", alpha_plain, "_logFC_", as.character(lfc_threshold), sep=""),
pretty = T)
# Read in the .gmt file
gmt <- read.gmt(paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/20250305_kegg_sce_gmt", sep=""))
gmt$term <- as.character(gmt$term)
# Get a simple vector with the Entrez IDs of the proteins we detect
trna_ko <- as.data.frame(as.matrix(fread(paste(base_dir, "tRNA_KOs/Data/proteomics_data/processed_proteomics_dataframe.tsv", sep="")), rownames = 1))
yeastmine <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))
proteins_detected <- match_systematic_and_standard_protein_names(data = rownames(trna_ko),
yeastmine = yeastmine,
input = "standard",
simplify = T)
proteins_detected <- entrez_db$`NCBI_gene_(formerly_Entrezgene)_ID`[entrez_db$Protein_stable_ID %in% proteins_detected]
# Get our list of vectors, where each vector is a KEGG pathway and the terms in it are the genes related to it - keeping only genes which are detected in our dataset
gmt <- gmt %>%
mutate(pathway_code = substr(term, 1, str_locate(term, "_")[1]-1),
pathway_name = substr(term, str_locate(term, "_")[1]+1, nchar(term)))
kegg_genes <- list()
pathways <- unique(gmt$pathway_name)
for (i in 1:length(pathways)) {
pathway <- pathways[i]
temp <- gmt %>%
filter(pathway_name == pathway)
kegg_genes[[pathway]] <- as.character(temp$gene)[as.character(temp$gene) %in% proteins_detected]
}
kegg_gsea_results <- list()
for (i in 1:length(ranked_genes)) {
kegg_gsea_results[[names(ranked_genes)[i]]] <- fgsea(pathways = kegg_genes,                                # List of gene sets to check
stats = ranked_genes[[i]],
scoreType = 'std',
# in this case we have both pos and neg rankings. if only pos or neg, set to 'pos', 'neg'
minSize = 1,
maxSize = 1000,
nproc = 1)                                             # for parallelisation
}
# This returns a list, where each element is a dataframe for the corresponding KO strain, and each row in that dataframe is a pathway. However, all pathways are included, so we are going to filter all of these dataframes to keep only the pathways that are significant in each KO strain
kegg_gsea_results_filtered <- lapply(kegg_gsea_results, function(x) filter(x, padj < alpha_enrichment))
bool <- sapply(kegg_gsea_results_filtered, function(x) nrow(x)>0)
kegg_gsea_results_filtered <- kegg_gsea_results_filtered[bool]
# Save these results
write_json(kegg_gsea_results_filtered, paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/kegg_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), pretty = T)
View(responsiveness)
# Step 1: Connect to Ensembl Fungi
ensembl_fungi <- useMart("fungi_mart", dataset = "scerevisiae_eg_gene", host = "https://fungi.ensembl.org")
# Step 2: Retrieve GO annotations
go_annotations <- getBM(attributes = c("ensembl_gene_id", "external_gene_name",
"go_id", "name_1006", "namespace_1003", "entrezgene_id"),
mart = ensembl_fungi)
# This is added by me
trna_ko <- as.data.frame(as.matrix(fread(paste(base_dir, "tRNA_KOs/Data/proteomics_data/processed_proteomics_dataframe.tsv", sep="")), rownames = 1))
go_annotations <- go_annotations %>%
dplyr::filter(namespace_1003 != "go") %>%                                     # Pretty sure these rows are just wrong, or at least not useful to me
dplyr::filter(ensembl_gene_id %in% rownames(trna_ko)) %>%                     # Keep only those genes which are detected in our data, so as to prevent bias
dplyr::mutate(gene_set = case_when(namespace_1003 == "molecular_function" ~ paste(name_1006, " (MF)", sep=""),
namespace_1003 == "biological_process" ~ paste(name_1006, " (BP)", sep=""),
namespace_1003 == "cellular_component" ~ paste(name_1006, " (CC)", sep="")))
# Check the first few rows
head(go_annotations)
# Step 3: Filter for Biological Process (BP) only - not interested in using this for now
go_annotations <- go_annotations %>%
#filter(namespace_1003 == "biological_process") %>%
filter(go_id != "")  # Remove any empty GO terms if present
# Step 4: Build a list: GO Term -> Genes
# Use external_gene_name (common names) or ensembl_gene_id (your choice)
go_list <- split(go_annotations$entrezgene_id, go_annotations$gene_set)
# Step 5: Save this named list of vectors as a JSON file
write_json(go_list, path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_list_gmt.json", sep=""), pretty = T)
# Read in the .json file
go_gene_sets <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_list_gmt.json", sep=""), simplifyVector = T)
go_gsea_results <- list()
for (i in 1:length(ranked_genes)) {
go_gsea_results[[names(ranked_genes)[i]]] <- fgsea(pathways = go_gene_sets,                                # List of gene sets to check
stats = ranked_genes[[i]],
scoreType = 'std',
# in this case we have both pos and neg rankings. if only pos or neg, set to 'pos', 'neg'
minSize = 1,
maxSize = 1000,
nproc = 1)                                             # for parallelisation
}
# This returns a list, where each element is a dataframe for the corresponding KO strain, and each row in that dataframe is a pathway. However, all pathways are included, so we are going to filter all of these dataframes to keep only the pathways that are significant in each KO strain
go_gsea_results_filtered <- lapply(go_gsea_results, function(x) filter(x, padj < alpha_enrichment))
bool <- sapply(go_gsea_results_filtered, function(x) nrow(x)>0)
go_gsea_results_filtered <- go_gsea_results_filtered[bool]
# Save these results
write_json(go_gsea_results_filtered, paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), pretty = T)
N <- 10
# Load the GO GSEA results produced in that file
go_gsea_results <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), simplifyVector = T)
# For GO GSEA results
## Get the unique codons to iterate over
codons <- unique(sapply(names(go_gsea_results), extract_anticodon_from_trna_name))
# Iterate over codons and create a table for each pair of KOs (for those anticodons for which we have more than 1 KO)
for (i in 1:length(codons)) {
codon <- codons[i]
temp_go_gsea_results <- go_gsea_results[grepl(codon, names(go_gsea_results))]
print(names(temp_go_gsea_results))
# Proceed only if there are GSEA results for at least 2 KOs with this anticodon, and if at least 2 of them are major
if ((length(temp_go_gsea_results) > 1) & sum(names(temp_go_gsea_results) %in% paired_major_strains) > 1) {
temp_list <- list()
temp_go_gsea_results <- temp_go_gsea_results[names(temp_go_gsea_results) %in% paired_major_strains]    # Remove the non-major subunits
for (j in 1:length(temp_go_gsea_results)) {
temp_go_gsea_results[[j]] <- temp_go_gsea_results[[j]][order(temp_go_gsea_results[[j]]$padj),]       # Order by increasing p-adj
temp_go_gsea_results[[j]] <- temp_go_gsea_results[[j]][1:N,]                                         # Grab only the first N pathways
temp_list[[names(temp_go_gsea_results)[j]]] <- sort(temp_go_gsea_results[[j]]$pathway)               # Grab the pathway names and order there them                                                                                                                     alphabetically, which makes it easier to compare them                                                                                                             between KO strains
}
out_df <- data.frame(matrix(ncol = 0, nrow = max(sapply(temp_list, length))))
for (j in 1:length(temp_list)) {
new_col <- temp_list[[j]]
if (length(new_col) == max(sapply(temp_list, length))) {
out_df[,j] <- new_col
} else {
out_df[,j] <- c(new_col, rep(NA, max(sapply(temp_list, length))-length(new_col)))
}
}
colnames(out_df) <- names(temp_list)
print(xtable(out_df), include.rownames=FALSE)
}
}
N <- 10
# Load the GO GSEA results produced in that file
go_gsea_results <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), simplifyVector = T)
# For GO GSEA results
## Get the unique codons to iterate over
codons <- unique(sapply(names(go_gsea_results), extract_anticodon_from_trna_name))
# Iterate over codons and create a table for each pair of KOs (for those anticodons for which we have more than 1 KO)
for (i in 1:length(codons)) {
codon <- codons[i]
temp_go_gsea_results <- go_gsea_results[grepl(codon, names(go_gsea_results))]
# Proceed only if there are GSEA results for at least 2 KOs with this anticodon, and if at least 2 of them are major
if ((length(temp_go_gsea_results) > 1) & sum(names(temp_go_gsea_results) %in% paired_major_strains) > 1) {
temp_list <- list()
temp_go_gsea_results <- temp_go_gsea_results[names(temp_go_gsea_results) %in% paired_major_strains]    # Remove the non-major subunits
for (j in 1:length(temp_go_gsea_results)) {
temp_go_gsea_results[[j]] <- temp_go_gsea_results[[j]][order(temp_go_gsea_results[[j]]$padj),]       # Order by increasing p-adj
temp_go_gsea_results[[j]] <- temp_go_gsea_results[[j]][1:N,]                                         # Grab only the first N pathways
temp_list[[names(temp_go_gsea_results)[j]]] <- sort(temp_go_gsea_results[[j]]$pathway)               # Grab the pathway names and order there them                                                                                                                     alphabetically, which makes it easier to compare them                                                                                                             between KO strains
}
out_df <- data.frame(matrix(ncol = 0, nrow = max(sapply(temp_list, length))))
for (j in 1:length(temp_list)) {
new_col <- temp_list[[j]]
if (length(new_col) == max(sapply(temp_list, length))) {
out_df[,j] <- new_col
} else {
out_df[,j] <- c(new_col, rep(NA, max(sapply(temp_list, length))-length(new_col)))
}
}
colnames(out_df) <- names(temp_list)
print(xtable(out_df), include.rownames=FALSE)
}
}
View(DE_protein_overlaps_major_within_family)
N <- 10
# Load the GO GSEA results produced in that file
kegg_gsea_results <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/kegg_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), simplifyVector = T)
# For GO GSEA results
## Get the unique codons to iterate over
codons <- unique(sapply(names(kegg_gsea_results), extract_anticodon_from_trna_name))
# Iterate over codons and create a table for each pair of KOs (for those anticodons for which we have more than 1 KO)
for (i in 1:length(codons)) {
codon <- codons[i]
temp_kegg_gsea_results <- kegg_gsea_results[grepl(codon, names(kegg_gsea_results))]
print(names(temp_kegg_gsea_results))
# Proceed only if there are GSEA results for at least 2 KOs with this anticodon, and if at least 2 of them are major
if ((length(temp_kegg_gsea_results) > 1) & sum(names(temp_kegg_gsea_results) %in% paired_major_strains) > 1) {
temp_list <- list()
temp_kegg_gsea_results <- temp_kegg_gsea_results[names(temp_kegg_gsea_results) %in% paired_major_strains]    # Remove the non-major subunits
for (j in 1:length(temp_kegg_gsea_results)) {
temp_kegg_gsea_results[[j]] <- temp_kegg_gsea_results[[j]][order(temp_kegg_gsea_results[[j]]$padj),]       # Order by increasing p-adj
temp_kegg_gsea_results[[j]] <- temp_kegg_gsea_results[[j]][1:N,]                                         # Grab only the first N pathways
temp_list[[names(temp_kegg_gsea_results)[j]]] <- sort(temp_kegg_gsea_results[[j]]$pathway)               # Grab the pathway names and order there them                                                                                                                     alphabetically, which makes it easier to compare them                                                                                                             between KO strains
}
out_df <- data.frame(matrix(ncol = 0, nrow = max(sapply(temp_list, length))))
for (j in 1:length(temp_list)) {
new_col <- temp_list[[j]]
if (length(new_col) == max(sapply(temp_list, length))) {
out_df[,j] <- new_col
} else {
out_df[,j] <- c(new_col, rep(NA, max(sapply(temp_list, length))-length(new_col)))
}
}
colnames(out_df) <- names(temp_list)
print(xtable(out_df), include.rownames=FALSE)
}
}
N <- 10
# Load the GO GSEA results produced in that file
kegg_gsea_results <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/kegg_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), simplifyVector = T)
# For GO GSEA results
## Get the unique codons to iterate over
codons <- unique(sapply(names(kegg_gsea_results), extract_anticodon_from_trna_name))
# Iterate over codons and create a table for each pair of KOs (for those anticodons for which we have more than 1 KO)
for (i in 1:length(codons)) {
codon <- codons[i]
temp_kegg_gsea_results <- kegg_gsea_results[grepl(codon, names(kegg_gsea_results))]
# Proceed only if there are GSEA results for at least 2 KOs with this anticodon, and if at least 2 of them are major
if ((length(temp_kegg_gsea_results) > 1) & sum(names(temp_kegg_gsea_results) %in% paired_major_strains) > 1) {
temp_list <- list()
temp_kegg_gsea_results <- temp_kegg_gsea_results[names(temp_kegg_gsea_results) %in% paired_major_strains]    # Remove the non-major subunits
for (j in 1:length(temp_kegg_gsea_results)) {
temp_kegg_gsea_results[[j]] <- temp_kegg_gsea_results[[j]][order(temp_kegg_gsea_results[[j]]$padj),]       # Order by increasing p-adj
temp_kegg_gsea_results[[j]] <- temp_kegg_gsea_results[[j]][1:N,]                                         # Grab only the first N pathways
temp_list[[names(temp_kegg_gsea_results)[j]]] <- sort(temp_kegg_gsea_results[[j]]$pathway)               # Grab the pathway names and order there them                                                                                                                     alphabetically, which makes it easier to compare them                                                                                                             between KO strains
}
out_df <- data.frame(matrix(ncol = 0, nrow = max(sapply(temp_list, length))))
for (j in 1:length(temp_list)) {
new_col <- temp_list[[j]]
if (length(new_col) == max(sapply(temp_list, length))) {
out_df[,j] <- new_col
} else {
out_df[,j] <- c(new_col, rep(NA, max(sapply(temp_list, length))-length(new_col)))
}
}
colnames(out_df) <- names(temp_list)
print(xtable(out_df), include.rownames=FALSE)
}
}
View(master_dataset)
View(go_gsea_results_filtered)
go_gsea_results_filtered[["tA(AGC)M1"]][["pathway"]]
cat(go_gsea_results_filtered[["tA(AGC)M1"]][["pathway"]], sep =", ")
cat(go_gsea_results_filtered[["tA(AGC)M2"]][["pathway"]], sep=",")
cat(go_gsea_results_filtered[["tN(GUU)C"]][["pathway"]], sep="")
cat(go_gsea_results_filtered[["tN(GUU)O2"]][["pathway"]], sep="")
View(master_dataset)
# Basic volcano plot - FC vs. -log10(adj.p-value) - tag only significant p-values and FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total))) +
geom_point() +
geom_hline(yintercept = -log10(0.05), col = "red") +
geom_vline(xintercept = 0.5, col = "red") +
geom_vline(xintercept = -0.5, col = "red") +
theme_light() +
geom_text_repel(data = subset(test_codon_enrichment, (((logFC_total > 0.5 | logFC_total < -0.5) &
-log10(p.values.adj_total) > -log10(0.05)))|-log10(p.values.adj_total) > -log10(0.05)),
aes(x = logFC_total, y = -log10(p.values.adj_total), label = Strain.Name)) +
xlab("logFC") +
ylab("-log10(p-value)") +
labs(title = "Testing results for codon proportion in DE vs. non-DE proteins",
subtitle = "Each dot represents a strain")
# Basic volcano plot - FC vs. -log10(adj.p-value) - tag only significant p-values and FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total))) +
geom_point() +
geom_hline(yintercept = -log10(0.05), col = "red") +
geom_vline(xintercept = 0.5, col = "red") +
geom_vline(xintercept = -0.5, col = "red") +
theme_light() +
geom_text_repel(data = subset(test_codon_enrichment, (((logFC_total > 0.5 | logFC_total < -0.5) &
-log10(p.values.adj_total) > -log10(0.05)))|-log10(p.values.adj_total) > -log10(0.05)),
aes(x = logFC_total, y = -log10(p.values.adj_total), label = Strain.Name)) +
xlab("logFC") +
ylab("-log10(p-value)") +
labs(title = "Testing results for target codon proportion in DE vs. non-DE proteins",
subtitle = "Each dot represents a strain")
View(sample_layout)
View(responsiveness)
ggplot(data = responsiveness, aes(x = Strain.Name, y = nDEP, fill = Amino_acid_1_letter)) +
geom_col() +
theme_light() +
theme(axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.title = element_text(size=9),
legend.key.size = unit(0.5, 'cm')) +
xlab("KO strain") +
labs(fill = "Amino acid")
ggplot(data = responsiveness, aes(x = nDEP)) +
geom_density(fill="#77bd89",
color="#1f6e34",
alpha=0.8,
linewidth = 1) +
theme_light()
ggplot(data = responsiveness, aes(x = Amino_acid_1_letter, y = nDEP, fill = Amino_acid_1_letter)) +
geom_boxplot() +
theme_light() +
labs(fill = "Amino acid",
title = 'tRNA KOs Responsiveness per AA',
subtitle = 'Number of Differentially Expressed Proteins (DEPs)') +
xlab("Amino acid") +
theme(legend.title = element_text(size=9),
legend.key.size = unit(0.5, 'cm'))
ggplot(data = responsiveness, aes(x = Amino_acid_1_letter, y = nDEP, fill = Amino_acid_1_letter)) +
geom_boxplot(outliers = F) +
geom_jitter() +
theme_light() +
labs(fill = "Amino acid",
title = 'tRNA KOs Responsiveness per AA',
subtitle = 'Number of Differentially Expressed Proteins (DEPs) - truncated < 100 nDEP') +
xlab("Amino acid") +
theme(legend.title = element_text(size=9),
legend.key.size = unit(0.5, 'cm')) +
coord_cartesian(ylim = c(0, 100))
ggplot(data = responsiveness, aes(x = chromosome_letter, y = nDEP, fill = chromosome_letter)) +
geom_boxplot() +
theme_light() +
labs(fill = "Chromosome",
title = 'tRNA KOs Responsiveness per Chromosome',
subtitle = 'Number of Differentially Expressed Proteins (DEPs)') +
xlab("Chromosome") +
theme(legend.title = element_text(size=9),
legend.key.size = unit(0.5, 'cm'))
ggplot(data = responsiveness, aes(x = chromosome_letter, y = nDEP, fill = chromosome_letter)) +
geom_boxplot(outliers = F) +
geom_jitter() +
theme_light() +
labs(fill = "Chromosome",
title = 'tRNA KOs Responsiveness per Chromosome',
subtitle = 'Number of Differentially Expressed Proteins (DEPs) - truncated < 100 nDEP') +
xlab("Chromosome") +
theme(legend.title = element_text(size=9),
legend.key.size = unit(0.5, 'cm')) +
coord_cartesian(ylim = c(0, 100))
myLetters <- letters[1:26]              # Need this to be able to re-order anticodons by amino acid
ggplot(responsiveness, aes(x = fct_reorder(anticodon, match(tolower(Amino_acid_1_letter), myLetters)), y = nDEP, groupping = Amino_acid_1_letter, fill = Amino_acid_1_letter)) +
geom_boxplot() +
theme_light() +
xlab("Anticodon") +
labs(fill = "Amino acid") +
labs(title = 'tRNA KOs Responsiveness per Anticodon',
subtitle = 'Number of Differentially Expressed Proteins (DEPs)') +
theme(legend.title = element_text(size=9),
legend.key.size = unit(0.5, 'cm'),
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
ggplot(responsiveness, aes(x = fct_reorder(anticodon, match(tolower(Amino_acid_1_letter), myLetters)), y = nDEP, groupping = Amino_acid_1_letter, fill = Amino_acid_1_letter)) +
geom_boxplot(outliers = F) +
geom_jitter() +
theme_light() +
xlab("Anticodon") +
labs(fill = "Amino acid") +
coord_cartesian(ylim = c(0, 150)) +
labs(title = 'tRNA KOs Responsiveness per Anticodon',
subtitle = 'Number of Differentially Expressed Proteins (DEPs) - truncated < 150 nDEP') +
theme(legend.title = element_text(size=9),
legend.key.size = unit(0.5, 'cm'),
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
version
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(data.table)
library(limma)
library(ggplot2)
library(patchwork)
library(tidyr)
library(tibble)
library(stringr)
library(gprofiler2)
library(xlsx)
library(stringr)
library(gridExtra)
library(grid)
suppressPackageStartupMessages(library(ComplexHeatmap))
suppressPackageStartupMessages(library(circlize))
library(factoextra)
library(glue)
library(dendextend)
library(ggrepel)
library(ggvenn)
library(tidyr)
library(interactions)
library(performance)
library(MASS)
library(jsonlite)
library(UpSetR)
library(ComplexUpset)
library(wesanderson)
library(forcats)
library(ggpubr)
library(xtable)
library(clusterProfiler)
library(org.Sc.sgd.db)
library(fgsea)
library(limpa)
# Significance level to be used for all tests and plots in this file
alpha <- 0.05
# Significance level as a plain string to use when loading or writing files
alpha_plain <- str_replace(as.character(alpha), "\\.", "")
# Minimum threshold for the average log2-expression across all samples in order to keep a protein in the data before DE analysis
mean_log2_across_all_samples_threshold <- 2
# Minimum threshold for the variance of the log2-expression across all samples in order to keep a protein in the data before DE analysis
var_across_log2_all_samples_threshold <- 0.6
# Separate significance level, the one used for the enrichment analysis
alpha_enrichment <- 0.05
# Significance level above as a plain string to use when loading or writing files
alpha_enrichment_plain <- str_replace(as.character(alpha_enrichment), "\\.", "")
# Log-fold change limit to be considered "biologically significant"
lfc_threshold <- 0.5
# Set directories to be used
working_from = "charite"
if (working_from == "home") {
base_dir = "/home/alvaro/MyStuff/"
} else
if (working_from == "charite") {
base_dir = "C:/MyStuff/"
}
resp_and_expression <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/produced_during_analysis/resp_and_expression_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep="")))
# Set directories to be used
working_from = "home"
if (working_from == "home") {
base_dir = "/home/alvaro/MyStuff/"
} else
if (working_from == "charite") {
base_dir = "C:/MyStuff/"
}
resp_and_expression <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/produced_during_analysis/resp_and_expression_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep="")))
# Create a new version of the dataset with prettier names for the columns so the model summary is more readable
resp_and_expression_modelling <- resp_and_expression %>%
dplyr::rename(catalytic_constant = k_cat_value,
codon_frequency = codon_frequency_chu_2011,
tRNA_expression = mean_reads_per_tRNA,
synthetase_abundance_literature = synthetase_abundance,
synthetase_abundance_our_WTs = measured_proteomics_WTs_WT)
View(resp_and_expression)
resp_and_expression <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/produced_during_analysis/resp_and_expression_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep="")))
# Create a new version of the dataset with prettier names for the columns so the model summary is more readable
resp_and_expression_modelling <- resp_and_expression %>%
dplyr::rename(catalytic_constant = k_cat_value,
codon_frequency = codon_frequency_chu_2011,
tRNA_expression = mean_reads_per_tRNA,
synthetase_abundance_literature = synthetase_abundance,
synthetase_abundance_our_WTs = measured_proteomics_WTs)
resp_and_expression <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/produced_during_analysis/resp_and_expression_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep="")))
# Create a new version of the dataset with prettier names for the columns so the model summary is more readable
resp_and_expression_modelling <- resp_and_expression %>%
dplyr::rename(catalytic_constant = k_cat_value,
codon_frequency = codon_frequency_chu_2011,
tRNA_expression = mean_reads_per_tRNA,
synthetase_abundance_literature = synthetase_abundance,
synthetase_abundance_our_WTs = measured_proteomics_WT)
# Add info on U_34, A_34 from master_dataset
master_dataset <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/basic/master_tRNA_dataset.csv", sep=""))) %>%
dplyr::select(Strain.Name, A_34, U_34) %>%
mutate(A_34 = as.numeric(A_34),
U_34 = as.numeric(A_34))
resp_and_expression_modelling <- left_join(resp_and_expression_modelling, master_dataset, by = "Strain.Name")
resp_measure_corrs <- resp_and_expression_modelling %>%
dplyr::select_if(is.numeric)
cor_mat <- round(cor(resp_measure_corrs, use = "pairwise.complete.obs"), 2)
melted_corrs <- melt(cor_mat)
# Import the functions I have created in another file
source(paste(base_dir, "tRNA_KOs/Code/R/Mine/0.general_use_functions.R", sep=""))
resp_measure_corrs <- resp_and_expression_modelling %>%
dplyr::select_if(is.numeric)
cor_mat <- round(cor(resp_measure_corrs, use = "pairwise.complete.obs"), 2)
melted_corrs <- melt(cor_mat)
ggplot(data = melted_corrs, aes(x=Var1, y=Var2, fill=value)) +
geom_tile() +
geom_text(aes(Var2, Var1, label = value), size = 3) +
scale_fill_gradient2(low = "blue", high = "red",
limit = c(-1,1), name="Correlation") +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.background = element_blank(),
axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
# Remove unnecessary variables
rm(cor_mat, melted_corrs)
# With synthetase abundance from van der Haar, 2008
#fit <- glm.nb(data = resp_and_expression_modelling,
#              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
#              link = log)
#summary(fit)
#check_overdispersion(fit)
# I get a weird error here, which I think I got already at some point in my masters - it doesn't say it, but it is likely due to a convergence error? Last time, using this other package to fit the model worked. Got it from here in both cases: https://stats.stackexchange.com/questions/93352/error-in-fitting-negative-binomial-regression-model-in-r-when-replicating-publis
library(glmmADMB)
install.packages("R2admb")
install.packages("glmmADMB",
repos=c("http://glmmadmb.r-forge.r-project.org/repos",
getOption("repos")),
type="source")
# With synthetase abundance from van der Haar, 2008
#fit <- glm.nb(data = resp_and_expression_modelling,
#              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
#              link = log)
#summary(fit)
#check_overdispersion(fit)
# I get a weird error here, which I think I got already at some point in my masters - it doesn't say it, but it is likely due to a convergence error? Last time, using this other package to fit the model worked. Got it from here in both cases: https://stats.stackexchange.com/questions/93352/error-in-fitting-negative-binomial-regression-model-in-r-when-replicating-publis
library(glmmADMB)
fit <- glmmadmb(data = resp_and_expression_modelling,
formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
family = "nbinom")
summary(fit)
check_overdispersion(fit)
fit <- glm.nb(data = resp_and_expression_modelling,
formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
link = log)
summary(fit)
check_overdispersion(fit)
# What if I fit this model with the same function as above?
fit <- glmmadmb(data = resp_and_expression_modelling,
formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
family = "nbinom")
summary(fit)
# With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling,
formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
link = log)
summary(fit)
check_overdispersion(fit)
# I get a weird error here, which I think I got already at some point in my masters - it doesn't say it, but it is likely due to a convergence error? Last time, using this other package to fit the model worked. Got it from here in both cases: https://stats.stackexchange.com/questions/93352/error-in-fitting-negative-binomial-regression-model-in-r-when-replicating-publis
library(glmmADMB)
fit <- glmmadmb(data = resp_and_expression_modelling,
formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
family = "nbinom")
summary(fit)
# With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling,
formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
link = log)
