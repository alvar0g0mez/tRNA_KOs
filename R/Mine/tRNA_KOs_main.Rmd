---
title: "tRNAs"
author: "Álvaro Gómez Pérez"
date: "2024-11-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Packages
```{r}
library(dplyr)
library(data.table)
library(limma)
library(ggplot2)
library(patchwork)
library(tidyr)
library(tibble)
library(stringr)
library(gprofiler2)
library(xlsx)
library(stringr)
library(gridExtra)
library(grid)
suppressPackageStartupMessages(library(ComplexHeatmap))
suppressPackageStartupMessages(library(circlize))
suppressPackageStartupMessages(library(factoextra))
library(glue)
suppressPackageStartupMessages(library(dendextend))
library(ggrepel)
library(ggvenn)
library(tidyr)
library(interactions)
library(performance)
library(MASS)
library(jsonlite)
library(UpSetR)
library(ComplexUpset)
library(wesanderson)
library(forcats)
library(ggpubr)
library(xtable)
suppressPackageStartupMessages(library(clusterProfiler))
library(org.Sc.sgd.db)
library(fgsea)
library(limpa)
library(viridisLite)
library(staplr)                       # contains rotate_pdf
library(svglite)                      # to same images as .svg (vector based)
library(helperfunctions)
```

Set parameters
```{r}
# Significance level to be used for all tests and plots in this file
alpha <- 0.05

# Significance level as a plain string to use when loading or writing files
alpha_plain <- str_replace(as.character(alpha), "\\.", "")

# Minimum threshold for the average log2-expression across all samples in order to keep a protein in the data before DE analysis
mean_log2_across_all_samples_threshold <- 2

# Minimum threshold for the variance of the log2-expression across all samples in order to keep a protein in the data before DE analysis
var_across_log2_all_samples_threshold <- 0.6

# Separate significance level, the one used for the enrichment analysis
alpha_enrichment <- 0.05

# Significance level above as a plain string to use when loading or writing files
alpha_enrichment_plain <- str_replace(as.character(alpha_enrichment), "\\.", "")

# Log-fold change limit to be considered "biologically significant"
lfc_threshold <- 0.5
```





################################################################################
# 1. Load data and initial analysis
################################################################################
## 1.1. Load data
```{r}
# Proteomics data
proteomics_raw <- read.delim2("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/proteomics_data/AlternativeAAUsage-tRNA_peptidecentric_ProteinMaxLFQ_driftcorrected_batchcorrected_onWTs.tsv", header = T)

# Sample layout
metadata <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/metadata_alvaro.tsv"))

# The master tRNA dataset
master_dataset <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/master_tRNA_dataset.csv"))

# The ODs
od <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/OD_final.csv"))

# Phenotypic data
phenotypic_data <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/Articles/bloom_ackermann_2014/phenotypic_results_full.tsv"))

# UniProt dataset
uniprot_db <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv"))


# limpa output
dpcfit <- readRDS("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/limpa_analysis/dpcfit.rds")
y.protein <- readRDS("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/limpa_analysis/y.protein.rds")

## Set this so I don't have to change its name in the code below
trna_ko <- y.protein$E
```



## 1.2. Differential abundance analysis
```{r}
# Input only the sample layout for the samples present in the protein-level data
metadata_present <- metadata[metadata$final_proteomics_colnames %in% colnames(y.protein$E),]

# Run the DE analysis - generate da and responsiveness dataframes
de_analysis_results <- de_analysis(raw_data = y.protein,
                                   metadata = metadata_present,
                                   method = "limpa",
                                   strain_name_column = "Strain.Name",
                                   sample_name_column = "final_proteomics_colnames",
                                   reference_strain = "WT", 
                                   N = 10,
                                   lfc_threshold = lfc_threshold,
                                   alpha = alpha)

da <- de_analysis_results[["DE_df"]]
responsiveness <- create_responsiveness_df(da,
                                           alpha = alpha,
                                           lfc_threshold = lfc_threshold)
responsiveness <- responsiveness %>%
  dplyr::mutate(Amino_acid_1_letter = str_sub(Strain.Name, 2, 2),
                chromosome_letter = substr(Strain.Name, 8, 8),
                Anticodon = str_extract(Strain.Name, "(?<=\\.)[[:alpha:]]{3}(?=\\.)"),
                up_down_regulated_ratio_adjusted = Up_regulated_adjusted/Down_regulated_adjusted,
                up_down_regulated_ratio_non_adjusted = Up_regulated_non_adjusted/Down_regulated_non_adjusted) %>%
  dplyr::arrange(Amino_acid_1_letter) %>%
  dplyr::mutate(Anticodon = factor(Anticodon, levels = unique(Anticodon)))

# Add all amino acid names
amino_acids <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/databases/GtRNAdb/amino_acids.csv"))
responsiveness <- left_join(responsiveness, amino_acids, by = "Amino_acid_1_letter")

# Save DE proteins (up- and down-regulated separately) as list - NOT SURE IF THIS IS NECESSARY??? 
de_proteins_up_down <- list()
strains <- unique(da$Strain.Name)

for (i in 1:length(strains)) {
  strain <- strains[i]
  temp <- da %>%
    dplyr::filter(Strain.Name == strain)
  
  up_regulated <- temp$protein[temp$diffexpressed_adjusted == "Up_regulated"]
  down_regulated <- temp$protein[temp$diffexpressed_adjusted == "Down_regulated"]
  
  de_proteins_up_down[[strain]] <- list("Up" = up_regulated,
                                        "Down" = down_regulated)
}


# Save dataframes
fwrite(da, file = paste("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/enrichment_analysis/da_df_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv"))
fwrite(responsiveness, paste("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/produced_during_analysis/responsiveness_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv"))
write_json(de_proteins_up_down, path=paste("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/enrichment_analysis/de_proteins_list_up_down_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json"))
```


## 1.3. Basic plots for nDEP 
```{r}
ggplot(data = responsiveness, aes(x = Strain.Name, y = nDEP, fill = Amino_acid_1_letter)) +
  geom_col() +
  theme_light() +
  theme(axis.text.x = element_blank(), 
        axis.ticks.x = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.title = element_text(size=9),
        legend.key.size = unit(0.5, 'cm')) +
  xlab("KO strain") +
  labs(fill = "Amino acid")

ggplot(data = responsiveness, aes(x = nDEP)) +
  geom_density(fill="#77bd89",
               color="#1f6e34",
               alpha=0.8,
               linewidth = 1) +
  theme_light()

ggplot(data = responsiveness, aes(x = Amino_acid_1_letter, y = nDEP, fill = Amino_acid_1_letter)) +
  geom_boxplot() +
  theme_light() +
  labs(fill = "Amino acid",
       title = 'tRNA KOs Responsiveness per AA', 
       subtitle = 'Number of Differentially Expressed Proteins (DEPs)') +
  xlab("Amino acid") +
  theme(legend.title = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'))

ggplot(data = responsiveness, aes(x = Amino_acid_1_letter, y = nDEP, fill = Amino_acid_1_letter)) +
  geom_boxplot(outliers = F) +
  geom_jitter() +
  theme_light() +
  labs(fill = "Amino acid",
       title = 'tRNA KOs Responsiveness per AA', 
       subtitle = 'Number of Differentially Expressed Proteins (DEPs) - truncated < 250 nDEP') +
  xlab("Amino acid") +
  theme(legend.title = element_text(size=9),
        legend.key.size = unit(0.5, 'cm')) +
  coord_cartesian(ylim = c(0, 250))

ggplot(data = responsiveness, aes(x = chromosome_letter, y = nDEP, fill = chromosome_letter)) +
  geom_boxplot() +
  theme_light() +
  labs(fill = "Chromosome",
       title = 'tRNA KOs Responsiveness per Chromosome', 
       subtitle = 'Number of Differentially Expressed Proteins (DEPs)') +
  xlab("Chromosome") +
  theme(legend.title = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'))

ggplot(data = responsiveness, aes(x = chromosome_letter, y = nDEP, fill = chromosome_letter)) +
  geom_boxplot(outliers = F) +
  geom_jitter() +
  theme_light() +
  labs(fill = "Chromosome",
       title = 'tRNA KOs Responsiveness per Chromosome', 
       subtitle = 'Number of Differentially Expressed Proteins (DEPs) - truncated < 250 nDEP') +
  xlab("Chromosome") +
  theme(legend.title = element_text(size=9),
        legend.key.size = unit(0.5, 'cm')) +
  coord_cartesian(ylim = c(0, 250))


myLetters <- letters[1:26]              # Need this to be able to re-order Anticodons by amino acid
ggplot(responsiveness, aes(x = fct_reorder(Anticodon, match(tolower(Amino_acid_1_letter), myLetters)), y = nDEP, groupping = Amino_acid_1_letter, fill = Amino_acid_1_letter)) +
  geom_boxplot() +
  theme_light() +
  xlab("Anticodon") +
  labs(fill = "Amino acid") +
  labs(title = 'tRNA KOs Responsiveness per Anticodon', 
       subtitle = 'Number of Differentially Expressed Proteins (DEPs)') +
  theme(legend.title = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

ggplot(responsiveness, aes(x = fct_reorder(Anticodon, match(tolower(Amino_acid_1_letter), myLetters)), y = nDEP, groupping = Amino_acid_1_letter, fill = Amino_acid_1_letter)) +
  geom_boxplot(outliers = F) +
  geom_jitter() +
  theme_light() +
  xlab("Anticodon") +
  labs(fill = "Amino acid") +
  coord_cartesian(ylim = c(0, 250)) +
  labs(title = 'tRNA KOs Responsiveness per Anticodon', 
       subtitle = 'Number of Differentially Expressed Proteins (DEPs) - truncated < 250 nDEP') +
  theme(legend.title = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```



## 1.4. CV analysis
CV QC on the data for DE analysis
```{r}
# Calculate CV
proteomics <- as.data.frame(y.protein$E)
proteomics$protein <- rownames(proteomics)
proteomics_data_non_log2_long <- pivot_longer(proteomics, cols = !protein, names_to = "final_proteomics_colnames") %>%
  dplyr::mutate(value = 2^(value))
proteomics_layout <- metadata %>%
  dplyr::select(final_proteomics_colnames, Strain.Name)
proteomics_data_non_log2_long <- left_join(proteomics_data_non_log2_long, proteomics_layout, by = "final_proteomics_colnames") %>%
  group_by(Strain.Name, protein) %>%
  dplyr::mutate(CV_strain = helperfunctions::cv(value, method = "standard")) %>%                    # CV for each protein across samples of the same family (biological replicates)
  ungroup() %>%
  group_by(protein) %>%
  dplyr::mutate(CV_protein = helperfunctions::cv(value, method = "standard")) %>%                   # CV for a protein, across all samples
  ungroup()


# Prepare datasets for plotting
plot_cv_per_protein <- proteomics_data_non_log2_long %>%                       # dataset for plotting CV per protein
  dplyr::select(protein, CV_protein) %>%
  dplyr::distinct(protein, .keep_all = T)

plot_cv_per_strain <- proteomics_data_non_log2_long %>%                        # dataset for plotting CV per sample
  dplyr::select(Strain.Name, CV_strain) %>%
  group_by(Strain.Name) %>%
  summarise_at(vars(CV_strain), list(CV_strain = mean))


# Plots
ggplot(data = plot_cv_per_protein, aes(x = protein, y = CV_protein)) +
  geom_point() +
  theme_light() +
  theme(panel.grid.major.x = element_blank(),                              # remove the vertical grid lines
        panel.grid.major.y = element_line(linewidth = .1, color="black"),  # explicitly set the horizontal lines (or they will disappear too)
        axis.text.x=element_blank(),                                       # remove x axis labels
        axis.ticks.x=element_blank()) +                                    # remove x axis ticks
  xlab("Proteins") +
  ylab("CV per protein") +
  labs(title = "Coefficient of variation (CV) per protein",
       subtitle = "Across all samples") +
  geom_text_repel(data = subset(plot_cv_per_protein, CV_protein > 1),
                  aes(x = protein, y = CV_protein, label = protein),
                  size = 4)
ggsave(paste("/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/CV/CV_per_protein_across_all_strains_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".png", sep = ""),
       dpi = 600)
proteins_with_high_CV <- plot_cv_per_protein$protein[plot_cv_per_protein$CV_protein > 1]

ggplot(data = plot_cv_per_strain, aes(x = Strain.Name, y = CV_strain)) +
  geom_point() +
  theme_light() +
  theme(panel.grid.major.x = element_blank(),                              # remove the vertical grid lines
        panel.grid.major.y = element_line(linewidth=.1, color="black"),    # explicitly set the horizontal lines (or they will disappear too)
        axis.text.x=element_blank(),                                       # remove x axis labels
        axis.ticks.x=element_blank()) +                                    # remove x axis ticks
  xlab("Strains") +
  ylab("CV per strain") +
  labs(title = "Coefficient of variation (CV) per strain",
       subtitle = "Across all proteins") +
  geom_text_repel(data = subset(plot_cv_per_strain, CV_strain > 0.3 | CV_strain < 0.1),
                  aes(x = Strain.Name, y = CV_strain, label = Strain.Name),
                  size = 4)
ggsave(paste("/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/CV/CV_averaged_per_strain_protein_level", alpha_plain, "_logFC_", as.character(lfc_threshold), ".png", sep = ""),
       dpi = 600)
strains_with_high_CV <- plot_cv_per_strain$Strain.Name[plot_cv_per_strain$CV_strain > 0.25]
```

CV vs. nDEP - are the strains with flat volcano plots due to high CVs?
```{r}
resp_temp <- responsiveness %>%
  dplyr::select(Strain.Name, nDEP)

plot_cv_per_strain_vs_ndep <- left_join(plot_cv_per_strain, resp_temp, by = "Strain.Name")

ggplot(data = plot_cv_per_strain_vs_ndep, aes(x = CV_strain, y = nDEP)) +
  geom_point() +
  theme_light() +
  xlab("Average CV per strain") +
  ylab("nDEP") +
  labs(title = "Average CV per strain (at protein level) vs. nDEP") +
  geom_text_repel(data = subset(plot_cv_per_strain_vs_ndep, nDEP > 500|CV_strain > 0.4), 
                  aes(x = CV_strain, y = nDEP, label = Strain.Name))
ggsave(paste("/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/CV/CV_vs_nDEP_per_strain_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".png", sep = ""),
       dpi = 600)
```

Look at expression of each of the proteins with the high CV in detail
```{r}
proteomics_no_repeated_columns <- proteomics

# Create dataset for ploting
temp_layout <- metadata %>%
  dplyr::select(final_proteomics_colnames, Strain.Name, Anticodon, Amino_acid_1_letter)
high_cv_proteins_proteomics <- proteomics_no_repeated_columns %>%
  dplyr::filter(protein %in% proteins_with_high_CV) %>%
  pivot_longer(cols = !protein, names_to = "final_proteomics_colnames") %>%
  left_join(temp_layout, by = "final_proteomics_colnames") %>%
  dplyr::mutate(Anticodon = case_when(Strain.Name == "WT" ~ "WT",
                                      TRUE ~ Anticodon),
                Amino_acid_1_letter = case_when(Strain.Name == "WT" ~ "WT",
                                                            TRUE ~ Amino_acid_1_letter))

# Plot
proteins <- unique(high_cv_proteins_proteomics$protein)

## Iterate over the proteins and make the same plots for all of them
for (i in 1:length(proteins)) {
  protein_selected <- proteins[i]
  
  # Plot abundance of the protein per amino acid carried 
  plot <- ggplot(data = subset(high_cv_proteins_proteomics, protein == protein_selected), aes(x = Amino_acid_1_letter, y = value)) +
          geom_boxplot(fill = "grey") +
          theme_light() +
          xlab("Amino acid") +
          ylab("log2(protein abundance)") +
          labs(title = glue("Abundance of {protein_selected} by amino acid carried by the KOd tRNA"))
  print(plot)
  
  myLetters <- letters[1:26]                            # Need this to be able to re-order Anticodons by amino acid
  myLetters <- c(myLetters, "wt")                       # Need to add this so it doesn't break down because "WT" is not a letter
  
  # Plot abundance of the protein per Anticodon (tRNA family)
  plot_2 <- ggplot(data = subset(high_cv_proteins_proteomics, protein == protein_selected), 
                   aes(x = fct_reorder(Anticodon, match(tolower(Amino_acid_1_letter), myLetters)), y = value, fill = Amino_acid_1_letter)) +
            geom_boxplot() +
            theme_light() +
            theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
          xlab("Anticodon") +
          ylab("log2(protein abundance)") +
          labs(title = glue("Abundance of {protein_selected} by Anticodon in the KOd tRNA"),
               fill = "Amino acid")
  print(plot_2)
}
```



## 1.5. Volcano plots for the differential expression
```{r}
# One plot per KO and save them to a PDF - for all KOs
## Come up with the list of plots
plot_list <- list()
for (i in 1:length(levels(as.factor(da$Strain.Name)))) {
  trna <- levels(as.factor(da$Strain.Name))[i]
  temp <- da %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = glue("{trna} - {unique(temp$Replicate_num)} replicates")) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste("/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/Volcano_plots/volcano_plots_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep="")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)




# One plot per KO and save them to a PDF - for all KOs
## Come up with the list of plots
plot_list <- list()
for (i in 1:length(levels(as.factor(da$Strain.Name)))) {
  trna <- levels(as.factor(da$Strain.Name))[i]
  temp <- da %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(P.Value), col = diffexpressed_non_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = trna) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste("/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/Volcano_plots/volcano_plots_per_KO_all_KOs_non_adjusted_p_values_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep="")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)




# One plot per KO and save them to a PDF - only for KOs with at least 1 DE protein
## Remove KOs with 0 DE proteins
KOs_with_DE_proteins <- responsiveness$Strain.Name[responsiveness$nDEP > 0]
da_only_KOs_with_DE_proteins <- da[da$Strain.Name %in% KOs_with_DE_proteins,]

## Come up with the list of plots
plot_list <- list()
for (i in 1:length(KOs_with_DE_proteins)) {
  trna <- KOs_with_DE_proteins[i]
  temp <- da_only_KOs_with_DE_proteins %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = trna) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste("/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/Volcano_plots/volcano_plots_per_KO_KOs_with_DE_proteins_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep="")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)
```

Volcano plot for all KO strains together
```{r}
ggplot(data = da, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = "Volcano plot for all KO strains together",
         subtitle = "Adjusted p-values") +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))


ggplot(data = da, aes(x = logFC, y = -log10(P.Value), col = diffexpressed_non_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = "Volcano plot for all KO strains together",
         subtitle = "Raw p-values") +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))


# Remove unused objects
#rm(list = c("my_grobs", "plot_list", "KOs_with_DE_proteins", "temp", "da_only_KOs_with_DE_proteins", "trna", "i", "output_file"))
```

Evaluate distribution of p-values and fold-changes
```{r}
ggplot(data = da, aes(x = P.Value)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = "Distribution of raw p-values for DE", 
       subtitle = "All KO strains") +
  xlab("p-value") +
  ylab("Count")

ggplot(data = da, aes(x = adj.P.Val)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = "Distribution of adjusted p-values for DE", 
       subtitle = "All KO strains") +
  xlab("p-value") +
  ylab("Count")

ggplot(data = da, aes(x = logFC)) +
  geom_histogram(col = "black", fill = "grey", binwidth = 0.2) +
  theme_light() +
  labs(title = "Distribution of logFC values for DE", 
       subtitle = "All KO strains") +
  xlab("logFC") +
  ylab("Count")
```
--> Did this because we were a bit suspicious about how flat some of the volcano plots looked, but I am pretty sure that it's okay, some of them just become totally flat because they don't have any p-value that is small enough to survive BH correction. 



## 1.6. Check number of DE proteins and also volcano plots for the UCU family - minor vs. major members
```{r}
# Just number of DE proteins
UCU_major_minor <- phenotypic_data %>% 
  filter(UCU_family != "No") %>%
  dplyr::select(Strain.Name, UCU_family)

UCU_responsiveness <- responsiveness%>% filter(Anticodon == "UCU")

UCU_family <- full_join(UCU_major_minor, UCU_responsiveness, by = "Strain.Name")


# Volcano plots
## Keep only KOs in UCU family
KOs_in_UCU_family <- UCU_family$Strain.Name
da_only_KOs_from_UCU_family <- da[da$Strain.Name %in% KOs_in_UCU_family,]


## Come up with the list of plots
plot_list <- list()
for (i in 1:length(KOs_in_UCU_family)) {
  trna <- KOs_in_UCU_family[i]
  plot_title <- paste(trna, UCU_family$UCU_family[UCU_family$Strain.Name == trna], sep = "_")
  temp <- da_only_KOs_from_UCU_family %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = plot_title) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_location <- paste("/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/Volcano_plots/volcano_plots_per_KO_UCU_family_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep="")
ggsave(
   filename = output_location, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)


# Remove unused objects
rm(list = c("my_grobs", "plot_list", "KOs_in_UCU_family", "temp", "da_only_KOs_from_UCU_family", "trna", "plot_title", "UCU_major_minor", "UCU_responsiveness", "i", "UCU_family", "output_location"))
```



## 1.7. Check number of DE proteins vs. replicates per KO
```{r}
ggplot(data = responsiveness, aes(x = as.factor(Replicate_num), y = nDEP, col = as.factor(Replicate_num))) +
  geom_boxplot() +
  geom_jitter(position=position_jitter(0.2)) +
  theme_light() +
  xlab("Number of replicates")

replicate_num_vs_nDEP_cor <- cor(responsiveness$nDEP, responsiveness$Replicate_num)
replicate_num_vs_nDEP_cor

# Remove unnecessary objects
rm(replicate_num_vs_nDEP_cor)
```
--> The point with this was that maybe a larger number of replicates causes more nDEP just because it provides more statistical power and hence it's easier to achieve significance. However, there seems to be no correlation at all, I think that's actually good because it means that the nDEP will be only influenced by what is going on with the tRNA KOs? Even though that effect could be already confounding my results in this boxplot



## 1.8. Identify major and minor tRNA genes myself for all strains
Prepare data
```{r}
# Define a column with "minor"-"major", so that I can check how many major and minor ones there are per family (I could also do this directly based on the avg_nDEP tbh but oh well)
responsiveness <- responsiveness %>%
  dplyr::group_by(Anticodon) %>%
  dplyr::mutate(family_max = max(nDEP)) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(Gene_type = case_when(nDEP <= 20 ~ "-",
                               nDEP > 0.55*family_max ~ "Major",                      
                               TRUE ~ "Minor")) %>%
  dplyr::group_by(Anticodon) %>%
  dplyr::summarize(Major_count = sum(Gene_type == "Major"), across()) %>%
  dplyr::ungroup() %>%
  dplyr::select(-family_max)

# Save this new version of responsiveness
fwrite(responsiveness, paste("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/produced_during_analysis/responsiveness_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep=""))

# Get a dataframe with the size of each family, the number of those genes we have as KOs in the experiment, and how many of them are major, and plot this
# I think the way I am going to do this, is to add these as new columns to master_dataset: this is because the family size can only be directly calculated there (not all members of all families are present in responsiveness, because they were not all included in the experiment). 
colnames(master_dataset)[colnames(master_dataset) == "family_size"] <- "Family_size"
responsiveness <- responsiveness %>%
  dplyr::group_by(Anticodon) %>% 
  dplyr::summarize(Family_count = n(), across()) %>%
  dplyr::ungroup()
resp_temp <- responsiveness %>%
  dplyr::select(Major_count, Family_count, Strain.Name)
master_dataset <- left_join(master_dataset, resp_temp, by = c("Strain.Name"))
```

### 1.8.2. Lollipop plot
Prepare data
```{r}
# Get a column classifiying the tRNA genes into types of families, so I can sort by that and have them ordered in the plot
responsiveness <- responsiveness %>%
  dplyr::mutate(Family_type = case_when(Major_count == 1 & Family_count > 1 ~ "One major tRNA",
                                        Major_count == 1 & Family_count == 1 ~ "Single tRNA family",
                                        Major_count > 1 ~ "Multiple major tRNAs",
                                        Major_count < 1 ~ "All minor tRNAs"))
responsiveness <- responsiveness %>%                    # This sadly doesn't change the order in the plot :( - that's why I need to turn columns into factors with a certain order
  dplyr::arrange(Family_type, Anticodon, nDEP)

responsiveness$Anticodon <- factor(responsiveness$Anticodon, levels = unique(responsiveness$Anticodon))
responsiveness$Strain.Name <- factor(responsiveness$Strain.Name, levels = unique(responsiveness$Strain.Name))

# Add this Family_type variable to the master_dataset as well just in case
resp_temp <- responsiveness %>%
  dplyr::distinct(Strain.Name, .keep_all = T) %>%
  dplyr::select(Strain.Name, Family_type)
master_dataset <- left_join(master_dataset, resp_temp, by = "Strain.Name")
```

Plot
```{r}
tile_x <- -50

# Try to order based on amino acid instead
responsiveness <- responsiveness %>%
  dplyr::arrange(desc(Amino_acid_1_letter), Family_type, Anticodon, nDEP)
responsiveness$Anticodon <- factor(responsiveness$Anticodon, levels = unique(responsiveness$Anticodon))

# Create background annotation data - for colored sidebar
annotation_data <- responsiveness %>%
  dplyr::select(Amino_acid_1_letter , Anticodon, Family_type) %>%
  dplyr::distinct()


# Define grid lines
## Define the y-values where you want horizontal lines
grid_lines_y <- seq(0.5, 35.5, by = 2.5)

## Create a dataframe for horizontal line segments
grid_lines_df <- data.frame(
  x = 0,
  xend = 1750,
  y = grid_lines_y,
  yend = grid_lines_y
)

# First, calculate y-coordinates for each amino acid group
bracket_data <- annotation_data %>%
  dplyr::arrange(desc(Amino_acid_1_letter)) %>%
  group_by(Amino_acid_1_letter) %>%
  summarise(
    y_min = min(as.numeric(factor(Anticodon, levels = unique(responsiveness$Anticodon)))),
    y_max = max(as.numeric(factor(Anticodon, levels = unique(responsiveness$Anticodon)))),
    .groups = 'drop'
  )

# Add bracket lines to left side (adjust x as needed)
lollipop_plot_final <- ggplot(data = responsiveness, aes(x = nDEP, y = Anticodon)) +
  # Background color block
  geom_tile(data = annotation_data, aes(x = tile_x, fill = Family_type),  width = 30, height = 0.8) +
  
  # Lollipop line and point
  geom_line(aes(group = Anticodon), color = "grey70") +
  geom_point(color = "black",
             fill = "white",
             alpha = 0.5,
             size = 3) +
  
  # Scales and labels
  scale_fill_viridis_d(name = "Family type") +
  
  labs(
    title = "DE Proteins per tRNA KO (Grouped by Family Type)",
    x = "Number of Differentially Expressed Proteins",
    y = "tRNA Family",
    color = "# DE Proteins",
    fill = "Family Type"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    legend.position = "right",
    plot.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    plot.title = element_text(size = 20, face = "bold"),
    axis.title = element_text(size = 16),
    axis.text = element_text(size = 14),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12)
  ) +
  geom_segment(data = bracket_data,
               aes(x = -90, xend = -90, y = y_min, yend = y_max),
               inherit.aes = FALSE, linewidth = 1) +
  geom_segment(data = bracket_data,
               aes(x = -90, xend = -82, y = y_min, yend = y_min),
               inherit.aes = FALSE) +
  geom_segment(data = bracket_data,
               aes(x = -90, xend = -82, y = y_max, yend = y_max),
               inherit.aes = FALSE) +
  geom_text(data = bracket_data,
          aes(x = -105, y = (y_min + y_max) / 2, label = Amino_acid_1_letter),
          inherit.aes = FALSE, hjust = 1) +
  geom_segment(data = grid_lines_df,
               aes(x = x, xend = xend, y = y, yend = yend),
               color = "gray80", 
               linetype = "solid",
               alpha = 0.5)

#ggsave(filename = "lollipop.svg",
#       plot = lollipop_plot_final,
#       path = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/nDEP_per_families/",
#       width = 10, height = 8, units = "in",       
#       dpi = 600)

ggsave(filename = "lollipop.png",
       plot = lollipop_plot_final,
       path = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/nDEP_per_families/",
       width = 10, height = 8, units = "in",       
       dpi = 600,
       bg = "white")
```


### 1.8.3. Relating family size, members of family in the experiment, and % of major members
This used to be in section 2, but I think it's better here.
Sadly, I do need to create the corresponding resp_and_expression dataset before I can run the following chunk. In order to create this dataset, I merge information from quite a few sources:
  - I start from the responsiveness dataframe that I have been working with until now
  - Add the mean_reads_per_tRNA from Cozen et al., 2015
  - Add the information on tRNA synthetase abundance and catalytic constant (k_cat) from Chu et al., 2011
  - Add the synthetase abundance that we detect in WT samples in our proteomics data
  - Add the codon frequency data from Chu et al., 2011 - in a separate SI file from what we added above
  - 
```{r}
# 1. Add the mean_reads_per_tRNA from Cozen et al., 2015
## tRNA expression data from Cozen et al., 2015 - keep only genomic rows
cozen <- read.xlsx("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/tRNA_expression_comparative/cozen_et_al_2015.xlsx", 1) %>%
  dplyr::filter(read.mapping..genomic.sequence.or.mature.tRNA. == "genomic")

cozen_to_merge <- cozen %>%
  dplyr::filter(saccaromyces.genome.datasbase..sgd..tRNA.name != "NA" &
           mean.normalized.ReadCount..AlkB != "NA") %>%
  dplyr::select(name, tRNA.group, chromosome, chromosome.start, chromosome.end, chromosome.start,
         saccaromyces.genome.datasbase..sgd..tRNA.name, mean.normalized.ReadCount..AlkB, read.mapping..genomic.sequence.or.mature.tRNA.) %>%
  group_by(saccaromyces.genome.datasbase..sgd..tRNA.name) %>%
  mutate(mean_reads_per_tRNA = sum(as.numeric(mean.normalized.ReadCount..AlkB), na.rm = T)) %>%
  dplyr::rename(Strain.Name = saccaromyces.genome.datasbase..sgd..tRNA.name) %>%
  dplyr::select(Strain.Name, mean_reads_per_tRNA)

## Merge with resp
resp_and_expression <- left_join(responsiveness, cozen_to_merge, by = "Strain.Name")

# Remove unnecessary variables
rm(cozen, cozen_to_merge)



# 2. Add the information on tRNA synthetase abundance and catalytic constant (k_cat) from Chu et al., 2011
## Load data
chu_synths <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/Articles/chu_2011/S3.csv")) %>%
  dplyr::select(-k_cat_ref)

## Join the synthetase data to the resp_and_expression dataset
resp_and_expression <- left_join(resp_and_expression, chu_synths, by = "Amino_acid_3_letter")



# 3. Add the synthetase abundance that we detect in WT samples in our proteomics data
## Load data
synthetases <- fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/trna_synthetases.csv")

## Remove those synthetases we didn't detect in our data, as well as GRS2 (only active under stress)
temp <- synthetases %>%
  filter(Gene.symbol != "GRS2",
         !is.na(measured_proteomics_WT)) %>%
  dplyr::select(Amino_acid_1_letter, measured_proteomics_WT)
  
## So, at this point I have each synthetase we detect matched to the amino acid it attaches. Now, since there are a couple synthetases which work for more than one amino acid, I end up with multiple rows for the same amino acid, with different synthetase abundances for the same amino acid. In these cases, I decide to keep the limiting one, this is, the one we detect the least of (even though I don't even know if they join 1:1 to form the complex?).
synthetases_to_merge <- data.frame(matrix(ncol = ncol(synthetases), nrow = 0))
aas <- unique(synthetases$Amino_acid_1_letter)
for (i in 1:length(aas)) {
  aa <- aas[i]
  temp_2 <- temp %>%
    filter(Amino_acid_1_letter == aa)
  temp_2 <- temp_2[which.min(temp_2$measured_proteomics_WT),]
  synthetases_to_merge <- rbind(synthetases_to_merge, temp_2)
}

## Add this information of how much we measure of each synthetase in our data to the resp_and_expression dataset
resp_and_expression <- left_join(resp_and_expression, synthetases_to_merge, by = "Amino_acid_1_letter")

# Remove unnecessary variables
rm(chu_synths, synthetases, temp, temp_2, synthetases_to_merge, aa, aas, i)



# 4. Add the codon frequency data from Chu et al., 2011
## Get Anticodon from codon and rename columns
Anticodon_freq <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/Articles/chu_2011/S1.csv"))
Anticodon_freq$Anticodon <- lapply(Anticodon_freq[,colnames(Anticodon_freq) == "Codon"], codon_to_anticodon)
Anticodon_freq$Anticodon <- as.factor(as.character(Anticodon_freq$Anticodon))
Anticodon_freq <- Anticodon_freq %>%
  dplyr::rename(codon_frequency_chu_2011 = Frequency)

## Merge to resp_and_expression
resp_and_expression <- left_join(resp_and_expression, Anticodon_freq, by = "Anticodon")


# Save the dataset
fwrite(resp_and_expression, paste("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/produced_during_analysis/resp_and_expression_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep=""))
```

Get the plots
```{r}
# Family_count vs. major_count, as in 1.11., but color by amino acid carried - TODO
resp_and_expression <- resp_and_expression %>%
  dplyr::select(Anticodon, Amino_acid_1_letter, Family_count, Major_count, Strain.Name)
temp <- master_dataset %>%
  dplyr::distinct(Strain.Name, .keep_all = T) %>%
  dplyr::select(Family_size, Anticodon, Strain.Name)
resp_and_expression <- left_join(resp_and_expression, temp, by = c("Anticodon", "Strain.Name")) %>%
  dplyr::distinct(Anticodon, .keep_all = T)

ggplot(data = resp_and_expression, aes(x = Family_count, y = Major_count, col = Amino_acid_1_letter)) +
  geom_point() +
  geom_abline() +
  theme_light() +
  xlab("Genes in this family in the experiment") +
  ylab("Major genes detected in the family") +
  geom_text_repel(data = subset(resp_and_expression, Major_count/Family_count == 1 | Major_count/Family_count < 0.3),
                  aes(x = Family_count, y = Major_count, label = Anticodon),
                  size = 4, 
                  max.overlaps = 100)

# Same, but use in the y axis the % of major tRNAs instead of the count
ggplot(data = resp_and_expression, aes(x = Family_count, y = Major_count/Family_count)) +
  geom_point() +
  geom_smooth(method='lm') +
  theme_light() +
  xlab("Genes in this family in the study") +
  ylab("% of major genes detected in the family") +
  geom_text_repel(data = subset(resp_and_expression, Major_count/Family_count >= 1 | Major_count/Family_count < 0.3| Anticodon == "CAA"),
                  aes(x = Family_count, y = Major_count/Family_count, label = Anticodon, col = Amino_acid_1_letter),
                  size = 4)

# Same, but use in the y axis the % of major tRNAs instead of the count, and color by aa
ggplot(data = resp_and_expression, aes(x = Family_size, y = Major_count/Family_count)) +
  geom_point() +
  geom_smooth(method='lm') +
  theme_light() +
  xlab("Genes in this family in total") +
  ylab("% of major genes detected in the family") +
  geom_text_repel(data = subset(resp_and_expression, Major_count/Family_count >= 1 | Major_count/Family_count < 0.3 | Anticodon == "CAA"),
                  aes(x = Family_size, y = Major_count/Family_count, label = Anticodon, col = Amino_acid_1_letter),
                  size = 4)
```



## 1.9. Number of DE proteins per family, coloring by number of tRNAs in the family
```{r}
ggplot(data = responsiveness, aes(x = Anticodon, y = nDEP, fill = Family_count)) +
  geom_boxplot() +
  theme_light() +
  xlab("Anticodon") +
  labs(fill = "Genes in\nfamily",
       title = "Number of DE proteins per family",
       subtitle = "Colored by number of tRNA genes in the family") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

ggplot(data = responsiveness, aes(x = Anticodon, y = nDEP, fill = Family_count)) +
  geom_boxplot() +
  theme_light() +
  xlab("Anticodon") +
  labs(fill = "Genes in\nfamily",
       title = "Number of DE proteins per family",
       subtitle = "Colored by number of tRNA genes in the family - nDEP < 150") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  coord_cartesian(ylim = c(0, 150))


# Correlation between nDEP and tRNA family size
resp_summarized_by_family <- aggregate(responsiveness$nDEP, list(responsiveness$Anticodon), mean)
colnames(resp_summarized_by_family) <- c("Anticodon", "nDEP")
resp_summarized_by_family <- merge(resp_summarized_by_family, responsiveness[, c("Anticodon", "Family_count")], by = "Anticodon", all.x = T)
resp_summarized_by_family <- resp_summarized_by_family %>%
  distinct(Anticodon, .keep_all = T)
cor(resp_summarized_by_family$nDEP, resp_summarized_by_family$Family_count)


# Remove unnecessary variables
rm(resp_summarized_by_family)
```
--> The boxplot is not particularly illustrative, but the correlation is pretty meaningful I think? Looks like larger families show, on average over all tRNAs in them, less DE proteins, which makes sense with their hypothesis I think? If there are a couple major tRNA genes per family, larger families are going to have a lot of minor ones, while small families will be mostly major ones. Here I am also assuming that there are only a couple major copies per family, which I don't think they said at any point? But I guess makes sense with this. 

More plots to look into this:
```{r}
# Add Family_size and Family_count to responsiveness dataframe
temp <- master_dataset %>%
  dplyr::distinct(Strain.Name, .keep_all = T) %>%
  dplyr::select(Strain.Name, Family_size)
resp_to_plot <- left_join(responsiveness, temp, by = "Strain.Name") 
resp_to_plot <- resp_to_plot %>%
  dplyr::mutate(perc_family = Family_count/Family_size)


# nDEP vs. family size
ggplot(data = resp_to_plot, aes(x = as.factor(Family_size), y = nDEP)) +
  geom_boxplot() +
  theme_light() +
  xlab("Family size") +
  ylab("nDEP") +
  labs(title = "nDEPs based on the number of tRNA genes in each family")

ggplot(data = resp_to_plot, aes(x = as.factor(Family_size), y = nDEP)) +
  geom_boxplot() +
  theme_light() +
  xlab("Family size") +
  ylab("nDEP") +
  coord_cartesian(ylim = c(0, 150)) +
  labs(title = "nDEPs based on the number of tRNA genes in each family",
       subtitle = "Truncated at nDEP < 150")

ggplot(data = resp_to_plot, aes(x = as.factor(Family_size), y = nDEP, fill = perc_family)) +
  geom_boxplot() +
  theme_light() +
  xlab("Family size") +
  ylab("nDEP") +
  coord_cartesian(ylim = c(0, 150)) +
  labs(title = "nDEPs based on the number of tRNA genes in each family",
       subtitle = "Truncated at nDEP < 150",
       fill = "% of genes in family\nincluded in experiment")
```



## 1.10. Do all tRNAs with the same anticodon have exactly the same sequence throughout their whole structure?
So basically what I check here is, for each anticodon (family), whether there is a single mature tRNA seq and a single DNA seq for the whole family, in some cases there is (I get a 1 in the table I produce below, there is 1 single such sequence for that family) but in other cases there is more than 1, this just tells me there are differences at least among one of the tRNAs in the family and the others. In any case, should look deeper into this elsewhere. 
Also worth noting that for all families, there is either the same number of unique DNA sequences and of actual mature tRNA sequences, or there are more unique DNA sequences that mature to be the same one (or less unique ones, for example let's say there are 5 unique DNA sequences, but at the tRNA level there are only 2 different sequences across the family). 

--> No, they do not! Look further into this elsewhere
```{r}
num_of_tRNA_versions_DNA <- c()
num_of_tRNA_versions_mature <- c()
Anticodons <- unique(master_dataset$Anticodon)
for (i in 1:length(Anticodons)) {
  anticodon <- Anticodons[i]
  temp <- master_dataset %>%
    dplyr::filter(Anticodon == anticodon)
  num_of_tRNA_versions_DNA <- c(num_of_tRNA_versions_DNA, length(unique(temp$DNA_sequence)))
  num_of_tRNA_versions_mature <- c(num_of_tRNA_versions_mature, length(unique(temp$mature_sequence)))
}

check <- data.frame(Anticodons, num_of_tRNA_versions_DNA, num_of_tRNA_versions_mature)
sum(check$num_of_tRNA_versions_DNA >= check$num_of_tRNA_versions_mature)

# Remove unnecessary variables
rm(temp, anticodon, Anticodons, i, num_of_tRNA_versions_DNA, num_of_tRNA_versions_mature)
```



## 1.11. Explore correlation between the number of tRNA genes for a certain amino acid (or anticodon) that couldn't be KOd, and the number of genes with that amino acid/anticodon
```{r}
# Plots by anticodon
master_by_anticodon <- master_dataset %>%
  dplyr::distinct(Anticodon, .keep_all = T)

## Just the percentage of KOd genes per Anticodon
ggplot(data = master_by_anticodon, aes(x = Anticodon, y = Perc_KOd_genes_per_anticodon)) +
  geom_point() +
  theme_light() +
  geom_text_repel(data = subset(master_by_anticodon, Perc_KOd_genes_per_anticodon < 0.7), aes(x = Anticodon, y = Perc_KOd_genes_per_anticodon, label = Anticodon)) +
  theme(axis.text.x = element_blank()) +
  labs(title = "% of tRNA-genes with each Anticodon that were KOd") +
  ylab("% of genes KOd")



# Plots by amino acid - for some reason distinct() is not working???
master_by_amino_acid <- master_dataset[!duplicated(master_dataset$Amino_acid_1_letter),]

## Just the percentage of KOd genes per amino acid
ggplot(data = master_by_amino_acid, aes(x = Amino_acid_1_letter, y = Perc_KOd_genes_per_amino_acid, col = Number_of_tRNAs_loading_this_aa)) +
  geom_point() +
  theme_light() +
  geom_text_repel(data = subset(master_by_amino_acid, Perc_KOd_genes_per_amino_acid < 0.8), aes(x = Amino_acid_1_letter, y = Perc_KOd_genes_per_amino_acid, label = Amino_acid_1_letter)) +
  theme(axis.text.x = element_blank()) +
  xlab("Amino acid") +
  ylab("% of genes KOd") +
  labs(title = "% of tRNA-genes carrying each amino acid that were KOd",
       col = "Number of tRNAs\nloading this aa")

# How many tRNA genes are there for each amino acid?
ggplot(data = master_by_amino_acid, aes(x = Amino_acid_1_letter, y = Number_of_tRNAs_loading_this_aa)) +
  geom_col() +
  theme_light() +
  labs(title = "Number of tRNA genes carrying each amino acid") +
  xlab("Amino acid") +
  ylab("Number of genes") 

# Family sizes of the genes that couldn't be KOd
not_included_genes <- master_dataset %>%
  filter(KOd == "No")

# Barplot for family sizes
ggplot(data = not_included_genes, aes(x = Family_size)) +
  geom_bar() +
  theme_light() +
  xlab("Family size") +
  ylab("Count") +
  labs(title = "Distribution of family sizes across genes that couldn't be KOd")

# Barplots for number of tRNA genes carrying that amino acid
ggplot(data = not_included_genes, aes(x = Number_of_tRNAs_loading_this_aa)) +
  geom_bar() +
  theme_light() +
  xlab("Number of genes for tRNAs carrying the same amino acid") +
  ylab("Count") +
  labs(title = "Distribution of the number of genes for tRNAs carrying the same amino acid",
       subtitle = "Across genes that couldn't be KOd")

# Remove unnecessary variables
rm(master_by_amino_acid, master_by_anticodon)
```



## 1.12. Quick look at the OD
Join OD and responsiveness dataframes
```{r}
resp_temp <- responsiveness %>%
  dplyr::select(Strain.Name, nDEP, up_down_regulated_ratio_adjusted, up_down_regulated_ratio_non_adjusted)
od_and_nDEP <- left_join(od, resp_temp, by = "Strain.Name")
```

Plot just OD histograms
```{r}
ggplot(data = od, aes(x = OD_processed)) +
  geom_histogram(binwidth = 0.1, fill = "grey", col = "black") +
  theme_light() +
  labs(title = "Processed ODs for tRNA KO strains",
       subtitle = "For the following 96-well plates: 2.1., 2.2., 2.3.") +
  ylab("Frequency") +
  xlab("OD")

# Color by empty wells
ggplot(data = od, aes(x = OD_processed, fill = Empty_well)) +
  geom_histogram(binwidth = 0.03, col = "black") +
  theme_light() +
  labs(title = "Processed ODs for tRNA KO strains",
       subtitle = "For the following 96-well plates: 2.1., 2.2., 2.3.",
       fill = "Empty well?") +
  ylab("Frequency") +
  xlab("OD")
```

OD boxplots per anticodon and amino acid
```{r}
# Boxplot by Anticodon, color by amino acid
temp_plot <- od %>%
  filter(Anticodon != "")
myLetters <- letters[1:26]              # Need this to be able to re-order Anticodons by amino acid
ggplot(data = temp_plot, aes(x = fct_reorder(Anticodon, match(tolower(Amino_acid_1_letter), myLetters)), y = OD_processed, fill = Amino_acid_1_letter)) +
  geom_boxplot() +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 8)) +
  xlab("Anticodon") +
  ylab("OD") +
  labs(title = "OD boxplots per anticodon",
       subtitle = "Ordered and colored by amino acid carried", 
       fill = "Amino acid") +
  guides(fill=guide_legend(ncol=2))

# Boxplot by amino acid
ggplot(data = temp_plot, aes(x = Amino_acid_1_letter, y = OD_processed)) +
  geom_boxplot(fill = "grey") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 8)) +
  xlab("Anticodon") +
  ylab("OD") +
  labs(title = "OD boxplots per amino acid")

# Boxplot by whether a strain is WT, KO, or empty well - was going to do it for every single Strain.Name, but you cannot really see anything
# I could still do that and just divide it across a few plots, but I can also just compare the WTs here to the plots above
od <- od %>%
  mutate(Strain.Type = case_when(Strain.Name == "WT" ~ "WT",
                                 Strain.Name == "" ~ "Empty",
                                 TRUE ~ "KO"))
ggplot(data = od, aes(x = Strain.Type, y = OD_processed)) +
  geom_boxplot() +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 8)) +
  xlab("Strain type") +
  ylab("OD") +
  labs(title = "OD boxplots per strain type")
```

OD vs. nDEP
```{r}
# OD vs. nDEP
ggplot(data = od_and_nDEP, aes(x = OD_processed, y = nDEP)) +
  geom_point() +
  theme_light()

# OD vs. nDEP - y axis cut off at 200 nDEP
ggplot(data = od_and_nDEP, aes(x = OD_processed, y = nDEP)) +
  geom_point() +
  theme_light() +
  coord_cartesian(ylim = c(0, 200))

cor(od_and_nDEP$OD_processed, od_and_nDEP$nDEP, use = "pairwise.complete.obs")
```

Up_regulated/Down_regulated proteins per strain vs. OD - #TODO: THESE PLOTS HAVE THE WEIRD THING OF DOTS AT THE TOP BORDER!
```{r}
ggplot(data = od_and_nDEP, aes(x = OD_processed, y = up_down_regulated_ratio_non_adjusted)) +
  geom_point() +
  theme_light() + 
  labs(title = "Up-regulated protein count/down-regulated protein count vs. OD",
       subtitle = "Un-adjusted p-values") +
  xlab("OD") +
  ylab("Up-regulated proteins/Down-regulated proteins")

ggplot(data = od_and_nDEP, aes(x = OD_processed, y = up_down_regulated_ratio_adjusted)) +
  geom_point() +
  theme_light() + 
  labs(title = "Up-regulated protein count/down-regulated protein count vs. OD",
       subtitle = "Adjusted p-values") +
  xlab("OD") +
  ylab("Up-regulated proteins/Down-regulated proteins")
```



## 1.13. Explore phenotypic results (GR and GY)
Compare the phenotypic results from 2014 and 2020 - pretty comparable, going to be using the 2014 ones since they are the published ones
```{r}
ggplot(data = phenotypic_data, aes(x = GR_YPD_2014, y = GR_YPD_2020)) +
  geom_point() +
  theme_light() +
  labs(title = "Growth rates in YPD")

ggplot(data = phenotypic_data, aes(x = GR_SDC_2014, y = GR_SDC_2020)) +
  geom_point() +
  theme_light() +
  labs(title = "Growth rates in SDC")

ggplot(data = phenotypic_data, aes(x = GY_YPD_2014, y = GY_YPD_2020)) +
  geom_point() +
  theme_light() +
  labs(title = "Growth yields in YPD")

ggplot(data = phenotypic_data, aes(x = GY_SDC_2014, y = GY_SDC_2020)) +
  geom_point() +
  theme_light() +
  labs(title = "Growth yields in SDC")
```

Compare phenotypic results to OD
```{r}
# Join the 2 datasets
temp_od <- od %>%
  dplyr::select(OD_processed, Strain.Name)
temp_phenotypic <- phenotypic_data %>%
  dplyr::select(Strain.Name, starts_with("GR"), starts_with("GY"))

od_and_phenotypic_data <- left_join(temp_phenotypic, temp_od, by = "Strain.Name")

# Plot
ggplot(data = od_and_phenotypic_data, aes(x = OD_processed, y = GR_low_glucose_2014)) +
  geom_point() +
  theme_light()

# After talking to Julia I decided to get rid of the 2020 values, since they strongly correlate with the 2014 ones and they don't provide any new insight, seemingly it's always better to use published data
od_and_phenotypic_data <- od_and_phenotypic_data %>%
  dplyr::select(!contains("2020"))

# Get correlations - actually let me add nDEP here and get a more complete view
temp_resp <- responsiveness %>%
  dplyr::select(Strain.Name, nDEP)
od_and_phenotypic_data_for_corr <- od_and_phenotypic_data %>%
  left_join(temp_resp, by = "Strain.Name") %>%
  dplyr::select(-Strain.Name) %>%
  na.omit()
cor_mat <- round(cor(od_and_phenotypic_data_for_corr), 2)
melted_cormat <- melt(cor_mat)
ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  geom_text(aes(Var2, Var1, label = value), size = 3) +
  scale_fill_gradient2(low = "blue", high = "red",
                       limit = c(-1,1), name="Correlation") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```




## 1.14. Correlation analysis
Load necessary data
```{r}
# Protein abundances - limpa output 
y.protein <- readRDS("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/limpa_analysis/y.protein.rds")
trna_ko <- as.data.frame(y.protein$E)
rm(y.protein)

# Sample layout
metadata <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/metadata_alvaro.tsv"))

# Import the functions I have created in another file
source("/home/alvaro/MyStuff/Projects/tRNA_KOs/Code/R/Mine/0.general_use_functions.R")
```

Correlate the protein abundance across all samples in the study
```{r}
# Set the columns in the order I want to have them - by amino acid loaded and by Anticodon
metadata <- metadata %>%
  dplyr::arrange(Amino_acid_1_letter, Anticodon)
desired_order <- as.character(metadata$final_proteomics_colnames)
desired_order <- desired_order[desired_order %in% colnames(trna_ko)]
trna_ko <- trna_ko %>%
  dplyr::select(desired_order)

# Remove highly unvariable proteins - NOT SURE IF THIS IS A GOOD IDEA, I'M JUST TRYING TO GET SOME LOWER CORRELATIONS
protein_variability <- apply(trna_ko, 1, function(x) var(x, na.rm = T))
hist(protein_variability)
most_variable_proteins <- rownames(trna_ko)[protein_variability > 0.4]
trna_ko_high_var <- trna_ko[rownames(trna_ko) %in% most_variable_proteins,]

# Prepare heatmap data: correlation and melt
## Standard, full dataset
cormat <- cor(trna_ko)
melted_cormat <- melt(cormat)

## Keeping only highly variable proteins
cormat_high_var <- cor(trna_ko_high_var)
melted_cormat_high_var <- melt(cormat_high_var)


# All correlations are extremely high, I guess this is why we use Z-scores or whatever for clustering and heatmaps with the whole dataset?? Because all correlations are really high because the vast majority of proteins will have similar abundances across all samples??

# Plot - full dataset
ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  scale_fill_gradient2(low = "blue", high = "red",
                       limit = c(min(melted_cormat$value),max(melted_cormat$value)), 
                       name="Correlation",
                       midpoint = mean(c(min(melted_cormat$value),max(melted_cormat$value)))) +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 0.1),
        axis.text.y = element_text(vjust = 1, hjust = 1, size = 0.1)) +
  labs(title = "Correlation matrix between full proteomes",
       subtitle = "With full dataset")

# Look at the distribution of the correlations - full dataset
ggplot(data = melted_cormat, aes(x = value)) +
  geom_histogram(fill = "grey", col = "black") +
  theme_light() +
  labs(title = "Distribution of the correlation scores between full proteome of all pairs of samples",
       subtitle = "With full dataset") +
  xlab("Correlation") +
  ylab("Count")


# Plot - only highly variable proteins
ggplot(data = melted_cormat_high_var, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  scale_fill_gradient2(low = "blue", high = "red",
                       limit = c(min(melted_cormat_high_var$value),max(melted_cormat_high_var$value)), 
                       name="Correlation",
                       midpoint = mean(c(min(melted_cormat_high_var$value),max(melted_cormat_high_var$value)))) +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 0.1),
        axis.text.y = element_text(vjust = 1, hjust = 1, size = 0.1)) +
  labs(title = "Correlation matrix between full proteomes",
       subtitle = "With only highly variable proteins")

# Look at the distribution of the correlations - only highly variable proteins
ggplot(data = melted_cormat_high_var, aes(x = value)) +
  geom_histogram(fill = "grey", col = "black") +
  theme_light() +
  labs(title = "Distribution of the correlation scores between full proteome of all pairs of samples",
       subtitle = "With only highly variable proteins") +
  xlab("Correlation") +
  ylab("Count")

# Actually probably better to get the average correlation for each strain with all others?
melted_cormat_high_var_avg <- melted_cormat_high_var %>%
  group_by(Var1) %>%
  summarise_at(vars(value), list(avg_corr_strain_1 = mean))

# Fix colnames to take a screenshot
colnames(melted_cormat_high_var_avg) <- c("Strain", "Average correlation")

# Get a histogram of the averages
ggplot(data = melted_cormat_high_var_avg, aes(x = `Average correlation`)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = "Histogram of average correlations betweeen each strain and all others",
       subtitle = "Only using high-variability proteins") +
  xlab("Correlation")
```

Look into the strains showing low correlation with others in general
```{r}
# Look at the top 15 strains that show up the most among pairs with correlation less than 0.6
melted_cormat_low_cor <- melted_cormat_high_var %>%
  dplyr::filter(value < 0.6)
low_cor_strains <- c(as.character(melted_cormat_low_cor$Var1), as.character(melted_cormat_low_cor$Var2))
head(sort(table(low_cor_strains), decreasing = T), 15)

# Grab the names of strains with an average correlation to all others below 0.6
low_avg_cor_strains <- melted_cormat_high_var_avg %>%
  dplyr::filter(`Average correlation` < 0.6) %>%
  dplyr::pull(Strain)

# Check the correlations of these strains to each other - see if they are high, this is, if this strains are somehow a subgroup with something special (probably not, but need to check it)
## Filter trna_ko to only have this strains
trna_ko_low_cor_strains <- trna_ko[, colnames(trna_ko) %in% low_avg_cor_strains]

## Keeping only highly variable proteins
cormat_low_corr <- cor(trna_ko_low_cor_strains)
melted_cormat_low_corr <- melt(cormat_low_corr)

# Get a histogram 
ggplot(data = melted_cormat_low_corr, aes(x = value)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = "Histogram of correlations between rare strains (low correlation to others)",
       subtitle = "Only using high-variability proteins") +
  xlab("Correlation")


## --> Huh, they actually do have high correlations to each other?? Need to make sure I did this properly but I guess this is nice? 
## --> They are all WTs :(
```



## 1.15. Clustering analysis
Perform hierarchical clustering
```{r}
# Elbow method - try to figure out what number of clusters is appropriate 
clust_df <- trna_ko
clust_df <- as.data.frame(t(clust_df))         
clust_df <- scale(clust_df)

fviz_nbclust(clust_df, kmeans, method = "wss", k.max = 15)

# Perform the clustering with the selected number of clusters
my_clusters <- perform_hierarchical_clustering(clust_df, "euclidean", "complete", 5)
```

Clustering to save dendrogram to PDF
```{r}
# Set up parameters
distance_method <- "euclidean"
clustering_method <- "complete"

# Perform clustering and create dendrogram - CLUST_DF IS SCALED IN THE PREVIOUS CHUNK! IS THAT OKAY???
dist_mat <- dist(clust_df, method = distance_method)
tree <- hclust(dist_mat, method = clustering_method)
plot(tree, cex = 0.3)
hcd <- as.dendrogram(tree)

# Open a PDF for plotting; units are inches by default
pdf("/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/dendrograms/dist_method_",  distance_method, "_clust_method_", clustering_method, ".pdf", width=40, height=15)

# Plot the tree into the PDF
plot(tree, cex = 0.3)

# Close the PDF file's associated graphics device (necessary to finalize the output)
dev.off()

# Rotate PDF
rotate_pdf(
  page_rotation = 90,
  input_filepath = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/dendrograms/dist_method_",  distance_method, "_clust_method_", clustering_method, ".pdf",
  output_filepath = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/dendrograms/dist_method_",  distance_method, "_clust_method_", clustering_method, ".pdf",
  overwrite = TRUE
)
```

Filter out proteins with low variability, towards the heatmaps
```{r}
protein_variability <- apply(trna_ko, 1, function(x) var(x, na.rm = T))
hist(protein_variability)
most_variable_proteins <- rownames(trna_ko)[protein_variability > 0.4]
trna_ko_high_var <- trna_ko[rownames(trna_ko) %in% most_variable_proteins,]
```



## 1.16. Heatmaps
For now I am only doing heatmaps using the Z-score per protein.
So this is basically focusing on the variability of each protein across all the samples - removing the basal "effect" of that protein?
```{r}
# Without sample grouping
create_heatmap(protein_mat = trna_ko,
               annotation = "none",
               metadata = metadata,
               metadata_column_for_sample_name = "final_proteomics_colnames",
               heatmap_type = "z-score",
               z_score_type = "standard",
               location_to_save = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/Heatmaps/",
               save_as = "png",
               plot_name = "default",
               heatmap_title = "Z-score tRNA KOs heatmap, full proteomes, no grouping")

# Grouping on WT vs. all others
create_heatmap(protein_mat = trna_ko,
               annotation = "single",
               metadata = metadata,
               metadata_column_for_sample_name = "final_proteomics_colnames",
               metadata_column_for_annotation = "Strain.Type",
               heatmap_type = "z-score",
               z_score_type = "standard",
               color_palette = "viridis",
               location_to_save = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/Heatmaps/",
               save_as = "png",
               plot_name = "default",
               heatmap_title = "Z-score tRNA KOs heatmap, full proteomes")

# Grouping on how they grew in DTT in the original article
create_heatmap(protein_mat = trna_ko,
               annotation = "single",
               metadata = metadata,
               metadata_column_for_sample_name = "final_proteomics_colnames",
               metadata_column_for_annotation = "GR_in_DTT_compared_to_WT",
               heatmap_type = "z-score",
               z_score_type = "standard",
               color_palette = "viridis",
               location_to_save = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/Heatmaps/",
               save_as = "png",
               plot_name = "default",
               heatmap_title = "Z-score tRNA KOs heatmap, full proteomes")
```



## 1.17. PCA
Prepare PCA label based on outlying strains
```{r}
# Load the sample layout and add a column that allows us to tag our strains of interest in the PCA
metadata <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/metadata_alvaro.tsv")) %>%
  dplyr::mutate(outlying_strains = case_when(Strain.Name == "tR(CCU)J" ~ "tR(CCU)J",
                                                Strain.Name == "tA(UGC)L" ~ "tA(UGC)L",
                                                Strain.Name == "tE(UUC)G1" ~ "tE(UUC)G1",
                                                Strain.Name == "tR(ACG)L" ~ "tR(ACG)L",
                                                TRUE ~ "Other"))
```

Run and plot PCA
```{r}
# Label by outlying strains
do_pca(trna_ko,
       metadata,
       metadata_column_for_annotation = "outlying_strains",
       metadata_column_for_sample_name = "final_proteomics_colnames",
       location_to_save = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/PCA/",
       save_as = "png")
```




## 1.18. Clean up environment
Next section loads all the data it needs, so I can delete everything except the system/set up parameters
```{r}
rm(da, master_dataset, responsiveness, metadata)
```












########################################################################################
# 2. Compare to data from the literature that might explain the nDEP for each KO strain:
########################################################################################
  - tRNA expression data from Cozen et al., 2015
  - tRNA synthetase abundance data from Chu et al., 2011
  - Anticodon frequency in the genome from van der Haar, 2008


## 2.1. tRNA expression data from Cozen et al., 2015
The main issue with this dataset (apart from the fact that they are read counts) is that in many rows, the counts are not assigned to a single tRNA gene, but they can come from any tRNA gene with a certain Anticodon. Actually, these are the reads that come from sequencing the actual, mature tRNAs, seemingly these are very hard to differentiate. Also, there are extremely high counts for these ones, so they are pretty uninformative and make it complicated to interpret when summing them up with the read counts that are for each tRNA gene specifically (because it seems like all those that are counted together as the mature tRNA have basically the same level of expression). Hence, I decided to only use the rows which have one single tRNA identified per row, this is, the genomic rows: these are the ones where the information comes from sequencing the tRNA just after it has been transcribed, before maturation or anything, which allows to identify exactly which gene they are coming from (all of this is kind of my interpretation, not 100% sure of it, but I think this is it). 

Load data
```{r}
# tRNa expression data from Cozen et al., 2015 - keep only genomic rows
cozen <- read.xlsx("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/tRNA_expression_comparative/cozen_et_al_2015.xlsx", 1) %>%
  filter(read.mapping..genomic.sequence.or.mature.tRNA. == "genomic")

# Load responsiveness dataset
responsiveness <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/produced_during_analysis/responsiveness_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv"))
```

Remove rows with NAs in relevant columns, select columns of interest, get the sum of reads per tRNA (since there are several rows for the same tRNA), and rename to merge with responsiveness dataframe
```{r}
cozen_to_merge <- cozen %>%
  dplyr::filter(saccaromyces.genome.datasbase..sgd..tRNA.name != "NA" &
           mean.normalized.ReadCount..AlkB != "NA") %>%
  dplyr::select(name, tRNA.group, chromosome, chromosome.start, chromosome.end, chromosome.start,
         saccaromyces.genome.datasbase..sgd..tRNA.name, mean.normalized.ReadCount..AlkB, read.mapping..genomic.sequence.or.mature.tRNA.) %>%
  group_by(saccaromyces.genome.datasbase..sgd..tRNA.name) %>%
  dplyr::mutate(mean_reads_per_tRNA = sum(as.numeric(mean.normalized.ReadCount..AlkB), na.rm = T)) %>%
  dplyr::rename(Strain.Name = saccaromyces.genome.datasbase..sgd..tRNA.name) %>%
  dplyr::select(Strain.Name, mean_reads_per_tRNA) %>%
  dplyr::mutate(Strain.Name = str_replace(Strain.Name, "\\(", ".")) %>%
  dplyr::mutate(Strain.Name = str_replace(Strain.Name, "\\)", "."))

## Merge with resp
resp_and_expression <- left_join(responsiveness, cozen_to_merge, by = "Strain.Name")


# Remove unnecessary variables
rm(cozen, cozen_to_merge)
```

Plots - nDEP vs. tRNA expression from Cozen et al., 2015
```{r}
# Plot average nDEP vs. avg expression - genomic tRNA sequences
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP)) +
  geom_point() +
  theme_light() + 
  labs(title = "nDEP vs. tRNA expression") +
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")

# Same, but color by number of tRNA genes in family
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = Family_count)) +
  geom_point() +
  theme_light() + 
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")
```


## 2.2. Integrate data from tRNA synthetase abundance and tRNA abundance (van der Haar et al., 2008) 
Load and prepare data
```{r}
# Load data
chu_synths <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/Articles/chu_2011/S3.csv")) %>%
  dplyr::select(-k_cat_ref)
chu_trnas <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/Articles/chu_2011/S2.csv"))
# The problem with these abundances for tRNAs is that they are for each family, not for each tRNA concretely, so I don't really know if they will be useful to me. I could collapse those from Cozen et al. by family and compare them to this to see if they point in the same direction, but might be a bit of a time waste

# Join the synthetase data to the resp_and_expression dataset
resp_and_expression <- left_join(resp_and_expression, chu_synths, by = "Amino_acid_3_letter")

# Add also the synthetase abundance we detect in our WTs
## Remove those synthetases we didn't detect in our data, as well as GRS2 (only active under stress)
synthetases <- fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/trna_synthetases.csv")
temp <- synthetases %>%
  filter(Gene.symbol != "GRS2",
         !is.na(measured_proteomics_WT)) %>%
  dplyr::select(Amino_acid_1_letter, measured_proteomics_WT)
  

# For the rows for each amino acid, select the limiting one, the one we detect the least of (even though I don't even know if they join 1:1 to form the complex?)
synthetases_to_merge <- data.frame(matrix(ncol = ncol(synthetases), nrow = 0))
aas <- unique(synthetases$Amino_acid_1_letter)
for (i in 1:length(aas)) {
  aa <- aas[i]
  temp_2 <- temp %>%
    filter(Amino_acid_1_letter == aa)
  temp_2 <- temp_2[which.min(temp_2$measured_proteomics_WT),]
  synthetases_to_merge <- rbind(synthetases_to_merge, temp_2)
}

resp_and_expression <- left_join(resp_and_expression, synthetases_to_merge, by = "Amino_acid_1_letter")


# Remove unnecessary variables
rm(chu_synths, chu_trnas, synthetases, temp, temp_2, synthetases_to_merge, aa, aas, i)
```

Plots - nDEP vs. tRNA expression from Cozen et al., 2015 (coloring by amino acid characteristics)
```{r}
# Plot average nDEP vs. avg expression - color by amino acid type
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = amino_acid_type)) +
  geom_point() +
  theme_light() + 
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")

# Plot average nDEP vs. avg expression - color by amino acid charge
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = amino_acid_charge)) +
  geom_point() +
  theme_light() + 
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")

# Plot average nDEP vs. avg expression - color by amino acid weight
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = molecular_weight_Da)) +
  geom_point() +
  theme_light() + 
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")
```

Plots - tRNA expression from Cozen et al., 2015 vs. tRNA synthetase abundance from van der Haar, 2008
```{r}
# tRNA abundance from Cozen et al., vs. log2 tRNA synthetase abundance from Chu et al.
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA)) +
  geom_point() +
  theme_light()

# Same, but color by major and minor based on our proteomics
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA, col = Gene_type)) +
  geom_point() +
  theme_light()

# Plot average nDEP vs. avg expression, but color by tRNA synthetase abundance from van der Haar, 2008
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = synthetase_abundance)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid type
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA, col = amino_acid_type)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid charge
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA, col = amino_acid_charge)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid weight
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA, col = molecular_weight_Da)) +
  geom_point() +
  theme_light()
```

Plots - tRNA expression from Cozen et al., 2015 vs. tRNA synthetase abundance from our WTs
```{r}
# tRNA abundance from Cozen et al., vs. log2 tRNA synthetase abundance from Chu et al.
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WT), y = mean_reads_per_tRNA)) +
  geom_point() +
  theme_light()

# Same, but color by major and minor based on our proteomics
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WT), y = mean_reads_per_tRNA, col = Gene_type)) +
  geom_point() +
  theme_light()

# Plot average nDEP vs. avg expression, but color by tRNA synthetase abundance from our WT samples
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = measured_proteomics_WT)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid type
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WT), y = mean_reads_per_tRNA, col = amino_acid_type)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid charge
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WT), y = mean_reads_per_tRNA, col = amino_acid_charge)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid weight
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WT), y = mean_reads_per_tRNA, col = molecular_weight_Da)) +
  geom_point() +
  theme_light()
```

Plots - nDEP vs. synthetase abundance - from van der Haar, 2008
```{r}
# nDEP vs. synthetase abundance
ggplot(data = resp_and_expression, aes(x = synthetase_abundance, y = nDEP)) +
  geom_point()

# nDEP vs. log2-synthetase abundance
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (from von der Haar, 2008)") +
  xlab("log2-tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO")

ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (from von der Haar, 2008)",
       subtitle = "Truncated nDEP < 150") +
  xlab("log2-tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO") +
  coord_cartesian(ylim = c(0, 150))

# nDEP vs. log2-synthetase abundance - color by family size
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = Family_count)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by chromosome
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = chromosome_letter)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid type
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = amino_acid_type)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid charge
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = amino_acid_charge)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid weight
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = molecular_weight_Da)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")
```

Plots - nDEP vs. synthetase abundance - from our WTs
```{r}
# nDEP vs. synthetase abundance
ggplot(data = resp_and_expression, aes(x = measured_proteomics_WT, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (measured in WTs)") +
  xlab("tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO")

ggplot(data = resp_and_expression, aes(x = measured_proteomics_WT, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (measured in WTs)",
       subtitle = "Truncated nDEP < 150") +
  xlab("tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO") +
  coord_cartesian(ylim = c(0, 150))
  

# nDEP vs. log2-synthetase abundance
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WT), y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (measured in WTs)") +
  xlab("log2-tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by family size
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WT), y = nDEP, col = Family_count)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (measured in WTs)") +
  xlab("log2-tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by chromosome
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WT), y = nDEP, col = chromosome_letter)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (measured in WTs)") +
  xlab("log2-tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid type
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WT), y = nDEP, col = amino_acid_type)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (measured in WTs)") +
  xlab("log2-tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid charge
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WT), y = nDEP, col = amino_acid_charge)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (measured in WTs)") +
  xlab("log2-tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid weight
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WT), y = nDEP, col = molecular_weight_Da)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (measured in WTs)") +
  xlab("log2-tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO")
```

Plots - nDEP vs. synthetase k_cat - from van der Haar, 2008
```{r}
# nDEP vs. log2-synthetase k_cat
ggplot(data = resp_and_expression, aes(x = log2(k_cat_value), y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. log2(synthetase catalytic constant) - from van der Haar, 2008") +
  xlab(bquote(log2-k["cat"]))

# The synthetases for W seem to have a k_cat more than 10x those of other amino acids, so I am going to get rid of that one then repeat the plot
ggplot(data = resp_and_expression, aes(x = k_cat_value, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. synthetase catalytic constant - from van der Haar, 2008")

ggplot(data = resp_and_expression, aes(x = k_cat_value, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. synthetase catalytic constant - from van der Haar, 2008",
       subtitle = "Truncated at catalytic constant < 150") +
  coord_cartesian(xlim = c(0, 150))

ggplot(data = resp_and_expression, aes(x = k_cat_value, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. synthetase catalytic constant - from van der Haar, 2008",
       subtitle = "Truncated at catalytic constant < 40") +
  coord_cartesian(xlim = c(0, 40))

# Not really a pattern I think, let's try synthetase abundance*k_cat
ggplot(data = resp_and_expression, aes(x = k_cat_value*synthetase_abundance, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. synthetase catalytic constant * synthetase abundance - from van der Haar, 2008") +
  coord_cartesian(xlim = c(0, 500000))
```



## 2.3. Add information about codon frequency as well
Load and prepare data
```{r}
# Get Anticodon from codon and rename columns
Anticodon_freq <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/Articles/chu_2011/S1.csv"))
Anticodon_freq$Anticodon <- lapply(Anticodon_freq[,colnames(Anticodon_freq) == "Codon"], codon_to_Anticodon)
Anticodon_freq$Anticodon <- as.character(Anticodon_freq$Anticodon)
Anticodon_freq$Anticodon <- as.factor(Anticodon_freq$Anticodon)
Anticodon_freq <- Anticodon_freq %>%
  dplyr::rename(codon_frequency_chu_2011 = Frequency)

# Merge to resp_and_expression
resp_and_expression <- left_join(resp_and_expression, Anticodon_freq, by = "Anticodon")
```

Plots - nDEP vs. codon frequency (from van der Haar, 2008)
```{r}
# Codon frequency vs. nDEP
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency (from van der Haar, 2008)") +
  xlab("Codon frequency") +
  ylab("nDEP per tRNA KO")

ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency (from van der Haar, 2008)",
       subtitle = "Truncated nDEP < 150") +
  xlab("Codon frequency") +
  ylab("nDEP per tRNA KO") +
  coord_cartesian(ylim = c(0, 150))

# Codon frequency vs. nDEP - color by tRNA abundance from Cozen et al.
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = mean_reads_per_tRNA)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency (from van der Haar, 2008)") +
  xlab("Codon frequency") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by log2 tRNA synthetase abundance from Chu et al.
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = log2(synthetase_abundance))) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency (from van der Haar, 2008)") +
  xlab("Codon frequency") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by family size
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = Family_count)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency (from van der Haar, 2008)") +
  xlab("Codon frequency") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by amino acid type
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = amino_acid_type)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency (from van der Haar, 2008)") +
  xlab("Codon frequency") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by amino acid charge
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = amino_acid_charge)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency (from van der Haar, 2008)") +
  xlab("Codon frequency") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by amino acid weight
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = molecular_weight_Da)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency (from van der Haar, 2008)") +
  xlab("Codon frequency") +
  ylab("nDEP per tRNA KO")
```


## 2.4. Save the resp_and_expression dataset as it is at this point, and clean up the environment
```{r}
fwrite(resp_and_expression, "/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/produced_during_analysis/resp_and_expression_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv")
rm(Anticodon_freq, resp_and_expression, responsiveness)
```




################################################################################
# 3. Modelling
################################################################################
## 3.0. Load data - so I don't have to run everything above
```{r}
resp_and_expression <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/produced_during_analysis/resp_and_expression_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv"))

# Create a new version of the dataset with prettier names for the columns so the model summary is more readable
resp_and_expression_modelling <- resp_and_expression %>%
  dplyr::rename(catalytic_constant = k_cat_value,
                codon_frequency = codon_frequency_chu_2011,
                tRNA_expression = mean_reads_per_tRNA,
                synthetase_abundance_literature = synthetase_abundance,
                synthetase_abundance_our_WTs = measured_proteomics_WT)

# Add info on U_34, A_34 from master_dataset
master_dataset <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/master_tRNA_dataset.csv")) %>%
  dplyr::select(Strain.Name, A_34, U_34) %>%
  mutate(A_34 = as.numeric(A_34),
         U_34 = as.numeric(A_34))
resp_and_expression_modelling <- left_join(resp_and_expression_modelling, master_dataset, by = "Strain.Name")
```


## 3.1. Get correlations between all the possible numerical variables used for modelling, and represent them in a heatmap
```{r}
resp_measure_corrs <- resp_and_expression_modelling %>%
  dplyr::select_if(is.numeric) %>%
  dplyr::select(-contains("regulated"))

cor_mat <- round(cor(resp_measure_corrs, use = "pairwise.complete.obs"), 2)

melted_corrs <- melt(cor_mat)

ggplot(data = melted_corrs, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  geom_text(aes(Var2, Var1, label = value), size = 3) +
  scale_fill_gradient2(low = "blue", high = "red",
                       limit = c(-1,1), name="Correlation") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))


# Remove unnecessary variables
rm(cor_mat, melted_corrs)
```


## 3.2. Evaluate missingness before model fitting
Methods to fit GLMs use na.omit() before fitting the model! So they are getting rid of all rows with a NA anywhere, which will strongly affect my model

How many rows do we end up with after na.omit() in each case?
```{r}
# Without tRNA expression
check_lit <- resp_and_expression_modelling %>%
  dplyr::select(nDEP, synthetase_abundance_literature, catalytic_constant, codon_frequency) %>%
  na.omit()
nrow(check_lit)
(nrow(check_lit)/nrow(resp_and_expression_modelling))*100
check_WTs <- resp_and_expression_modelling %>%
  dplyr::select(nDEP, synthetase_abundance_our_WTs, catalytic_constant, codon_frequency) %>%
  na.omit()
nrow(check_WTs)
(nrow(check_WTs)/nrow(resp_and_expression_modelling))*100

# With tRNA expression
check_lit <- resp_and_expression_modelling %>%
  dplyr::select(nDEP, tRNA_expression, synthetase_abundance_literature, catalytic_constant, codon_frequency) %>%
  na.omit()
nrow(check_lit)
(nrow(check_lit)/nrow(resp_and_expression_modelling))*100
check_WTs <- resp_and_expression_modelling %>%
  dplyr::select(nDEP, tRNA_expression, synthetase_abundance_our_WTs, catalytic_constant, codon_frequency) %>%
  na.omit()
nrow(check_WTs)
(nrow(check_WTs)/nrow(resp_and_expression_modelling))*100
```

Which are the columns introducing these NAs?
```{r}
sum(is.na(resp_and_expression_modelling$nDEP))
sum(is.na(resp_and_expression_modelling$tRNA_expression))
sum(is.na(resp_and_expression_modelling$synthetase_abundance_literature))
sum(is.na(resp_and_expression_modelling$catalytic_constant))
sum(is.na(resp_and_expression_modelling$codon_frequency))
sum(is.na(resp_and_expression_modelling$synthetase_abundance_our_WTs))
```

Can we fix this in any way? Input the NAs in our measurements for synthetase abundance? - Tbh I don't think that's a great idea 
```{r}
ggplot(data = resp_and_expression_modelling, aes(x = synthetase_abundance_literature, y = synthetase_abundance_our_WTs)) +
  geom_point() +
  geom_abline(col = "red", slope = 0.1) +
  theme_light()
```


## 3.3. Model the data with a GLM 
Poisson - way too much overdispersion
```{r}
# Poisson model
fit <- glm(data = resp_and_expression_modelling,
           formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
           family = poisson)
summary(fit)

# Check overdispersion - seems like there is, unsurprisingly
check_overdispersion(fit)

# Actually in the fit for the Poisson model we can already get an idea of if there is overdispersion or not: we do this by looking at the residual deviance and at the corresponding degrees of freedom, if the ratio between them is roughly 1, there is no overdispersion. If it is larger, there is overdispersion. So yeah, we see that we indeed have it here. 
```

Negative binomial - with 3 variables
```{r}
# With synthetase abundance from van der Haar, 2008
#fit <- glm.nb(data = resp_and_expression_modelling, 
#              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
#              link = log)
#summary(fit)
#check_overdispersion(fit)

# I get a weird error here, which I think I got already at some point in my masters - it doesn't say it, but it is likely due to a convergence error? Last time, using this other package to fit the model worked. Got it from here in both cases: https://stats.stackexchange.com/questions/93352/error-in-fitting-negative-binomial-regression-model-in-r-when-replicating-publis
library(glmmADMB)
fit <- glmmadmb(data = resp_and_expression_modelling,
                formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
                family = "nbinom")
summary(fit)
#check_overdispersion(fit)




# With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)

# What if I fit this model with the same function as above?
fit <- glmmadmb(data = resp_and_expression_modelling,
                formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
                family = "nbinom")
summary(fit)
```

Negative binomial - with 4 variables
```{r}
# With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)

# I get a weird error here, which I think I got already at some point in my masters - it doesn't say it, but it is likely due to a convergence error? Last time, using this other package to fit the model worked. Got it from here in both cases: https://stats.stackexchange.com/questions/93352/error-in-fitting-negative-binomial-regression-model-in-r-when-replicating-publis
library(glmmADMB)
fit <- glmmadmb(data = resp_and_expression_modelling,
                formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
                family = "nbinom")
summary(fit)





# With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)
```

Negative binomial - with 3 variables - remove strains below certain numbers of nDEPs - NOT USING THIS ANYMORE
```{r}
# nDEP > 0
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 0)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 1
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 1)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 2
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 2)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 3
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 3)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 4
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 4)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 5
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 5)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 10
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 10)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)
```

Negative binomial - with 4 variables - remove strains below certain numbers of nDEPs - NOT USING THIS ANYMORE
```{r}
# nDEP > 0
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 0)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 1
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 1)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 2
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 2)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 3
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 3)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 4
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 4)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 5
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 5)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 10
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 10)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)
```


## 3.4. Log-transform nDEP and use a Gaussian model - HONESTLY NOT SURE IF THIS IS WORTH IT
Prepare data
```{r}
gaussian_modelling_df <- resp_and_expression_modelling %>%
  mutate(nDEP = ifelse(nDEP == 0, 0, log2(nDEP)))
```

Very simple linear model
```{r}
fit <- lm(data = gaussian_modelling_df, nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency)
summary(fit)
```




Remove unnecessary variables
```{r}
rm(check_lit, check_WTs, fit, resp_and_expression, resp_and_expression_modelling, resp_measure_corrs, measured_proteomics_WTs)
```








################################################################################
# 4. Evaluate codon enrichment in DEPs sequences
################################################################################
## 4.1. In full sequences

SHOULD I CONSIDER SOME GROUPING BY CODON HERE? LIKE, THE DIFFERENT TRNAS THAT HAVE THE SAME CODON?
Load data (generated in Python script "check_codon_enrichment_in_DEPs_sequences.py")
```{r}
# Load list
codon_ratios_list <- fromJSON(txt = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/check_codon_enrichment_in_protein_sequences/codon_counts.json")

# Remove from the list those strains where there aren't at least 4 DE proteins
bool <- c()
for (i in 1:length(codon_ratios_list)) {
  bool <- c(bool, length(codon_ratios_list[[i]][["DE_up_regulated"]])+length(codon_ratios_list[[i]][["DE_down_regulated"]]) > 4)
}
codon_ratios_list <- codon_ratios_list[bool]


# Load master dataset
master_dataset <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/master_tRNA_dataset.csv"))

# Load resp_and_expression dataset
resp_and_expression <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/produced_during_analysis/resp_and_expression_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv"))
```

Iterate over the strains and perform a test for each, testing the mean counts of DE vs. that of non_DE
```{r}
strains <- names(codon_ratios_list)
p.values_wmw_total <- c()
p.values_wmw_up_non <- c()
p.values_wmw_up_down <- c()
p.values_wmw_down_non <- c()
mean_de_total <- c()
mean_de_up <- c()
mean_de_down <- c()
mean_non_de <- c()
num_de_total <- c()
num_de_up <- c()
num_de_down <- c()
num_non_de <- c()
for (i in 1:length(codon_ratios_list)) {
  # Grab data for this strain
  strain_name <- names(codon_ratios_list)[i]
  de_up <- codon_ratios_list[[strain_name]][["DE_up_regulated"]]
  de_down <- codon_ratios_list[[strain_name]][["DE_down_regulated"]]
  de_total <- c(as.numeric(de_up), as.numeric(de_down))
  non_de <- codon_ratios_list[[strain_name]][["non_DE"]]
  de_df_up <- data.frame(codon_ratios_list[[strain_name]][["DE_up_regulated"]])
  de_df_down <- data.frame(codon_ratios_list[[strain_name]][["DE_down_regulated"]])
  de_df_total <- data.frame(de_total)
  non_de_df <- data.frame(codon_ratios_list[[strain_name]][["non_DE"]])
  print(strain_name)
  
  # It's possible that either de_up or de_down (and hence de_df_up or de_df_down) are empty, so I need to account for that if I don't want to get an error
  de_up_empty <- length(de_up) == 0
  de_down_empty <- length(de_down) == 0
  
  if (de_up_empty) {
    # Plot overlapping histograms - not worth it I think
    ggplot() +
      geom_histogram(data = de_df_down, aes(x = log2(codon_ratios_list..strain_name.....DE...)), fill = "blue", alpha = 0.9)
      geom_histogram(data = non_de_df, aes(x = log2(codon_ratios_list..strain_name.....non_DE...)), fill = "orange", alpha = 0.4)
    
    # Test - WMW
    p.values_wmw_total <- c(p.values_wmw_total, wilcox.test(de_total, non_de)$p.value)
    p.values_wmw_up_non <- c(p.values_wmw_up_non, NA)
    p.values_wmw_up_down <- c(p.values_wmw_up_down, NA)
    p.values_wmw_down_non <- c(p.values_wmw_down_non, wilcox.test(de_down, non_de)$p.value)
    
    # Test - log2 transform and t-test (need to take care of 0s) and use t-test - is this worth doing?
    
    
    # Save the mean of each group to the output vectors as well
    mean_de_total <- c(mean_de_total, mean(de_total))
    mean_de_up <- c(mean_de_up, NA)
    mean_de_down <- c(mean_de_down, mean(de_down))
    mean_non_de <- c(mean_non_de, mean(non_de))
    
    # Save the number of proteins in each of the two groups - probably will explain the significance bc of low power with small DE protein counts
    num_de_total <- c(num_de_total, length(de_total))
    num_de_up <- c(num_de_up, length(de_up))
    num_de_down <- c(num_de_down, length(de_down))
    num_non_de <- c(num_non_de, length(non_de))
  }
  else if (de_down_empty) {
    # Plot overlapping histograms - not worth it I think
    ggplot() +
      geom_histogram(data = de_df_up, aes(x = log2(codon_ratios_list..strain_name.....DE...)), fill = "red", alpha = 0.9) +
      geom_histogram(data = non_de_df, aes(x = log2(codon_ratios_list..strain_name.....non_DE...)), fill = "orange", alpha = 0.4)
    
    # Test - WMW
    p.values_wmw_total <- c(p.values_wmw_total, wilcox.test(de_total, non_de)$p.value)
    p.values_wmw_up_non <- c(p.values_wmw_up_non, wilcox.test(de_up, non_de)$p.value)
    p.values_wmw_up_down <- c(p.values_wmw_up_down, NA)
    p.values_wmw_down_non <- c(p.values_wmw_down_non, NA)
    
    # Test - log2 transform and t-test (need to take care of 0s) and use t-test - is this worth doing?
    
    
    # Save the mean of each group to the output vectors as well
    mean_de_total <- c(mean_de_total, mean(de_total))
    mean_de_up <- c(mean_de_up, mean(de_up))
    mean_de_down <- c(mean_de_down, NA)
    mean_non_de <- c(mean_non_de, mean(non_de))
    
    # Save the number of proteins in each of the two groups - probably will explain the significance bc of low power with small DE protein counts
    num_de_total <- c(num_de_total, length(de_total))
    num_de_up <- c(num_de_up, length(de_up))
    num_de_down <- c(num_de_down, length(de_down))
    num_non_de <- c(num_non_de, length(non_de))
  }
  else {
    # Plot overlapping histograms - not worth it I think
    ggplot() +
      geom_histogram(data = de_df_up, aes(x = log2(codon_ratios_list..strain_name.....DE...)), fill = "red", alpha = 0.9) +
      geom_histogram(data = de_df_down, aes(x = log2(codon_ratios_list..strain_name.....DE...)), fill = "blue", alpha = 0.9)
      geom_histogram(data = non_de_df, aes(x = log2(codon_ratios_list..strain_name.....non_DE...)), fill = "orange", alpha = 0.4)
    
    # Test - WMW
    p.values_wmw_total <- c(p.values_wmw_total, wilcox.test(de_total, non_de)$p.value)
    p.values_wmw_up_non <- c(p.values_wmw_up_non, wilcox.test(de_up, non_de)$p.value)
    p.values_wmw_up_down <- c(p.values_wmw_up_down, wilcox.test(de_up, de_down)$p.value)
    p.values_wmw_down_non <- c(p.values_wmw_down_non, wilcox.test(de_down, non_de)$p.value)
    
    # Test - log2 transform and t-test (need to take care of 0s) and use t-test - is this worth doing?
    
    
    # Save the mean of each group to the output vectors as well
    mean_de_total <- c(mean_de_total, mean(de_total))
    mean_de_up <- c(mean_de_up, mean(de_up))
    mean_de_down <- c(mean_de_down, mean(de_down))
    mean_non_de <- c(mean_non_de, mean(non_de))
    
    # Save the number of proteins in each of the two groups - probably will explain the significance bc of low power with small DE protein counts
    num_de_total <- c(num_de_total, length(de_total))
    num_de_up <- c(num_de_up, length(de_up))
    num_de_down <- c(num_de_down, length(de_down))
    num_non_de <- c(num_non_de, length(non_de))
  }
}

p.values.adj_total <- p.adjust(p.values_wmw_total, method = "fdr")
p.values.adj_up_non <- p.adjust(p.values_wmw_up_non, method = "fdr")
p.values.adj_up_down <- p.adjust(p.values_wmw_up_down, method = "fdr")
p.values.adj_down_non <- p.adjust(p.values_wmw_down_non, method = "fdr")

test_codon_enrichment <- data.frame(Strain.Name = strains, p.values_wmw_up_non, p.values.adj_up_non, p.values_wmw_total, p.values.adj_total,
                                    p.values_wmw_up_down, p.values.adj_up_down, p.values_wmw_down_non, p.values.adj_down_non,
                                    mean_de_total, mean_de_up, mean_de_down, mean_non_de, num_de_total, num_de_up, num_de_down, num_non_de) %>%
  dplyr::mutate(direction_up_non = case_when(mean_de_up > mean_non_de ~ "DE_up",
                                      TRUE ~ "non_DE"),
         direction_up_down = case_when(mean_de_up > mean_de_down ~ "DE_up",
                                       TRUE ~ "DE_down"),
         direction_down_non = case_when(mean_de_down > mean_non_de ~ "DE_down",
                                        TRUE ~ "non_DE"),
         FC_total = mean_de_total/mean_non_de,
         FC_up_non = mean_de_up/mean_non_de,
         FC_up_down = mean_de_up/mean_de_down,
         FC_down_non = mean_de_down/mean_non_de,
         logFC_total = log2(FC_total),
         logFC_up_non = log2(FC_up_non),
         logFC_up_down = log2(FC_up_down),
         logFC_down_non = log2(FC_down_non))


# Remove unnecessary variables
#rm(bool, strains, p.values_wmw, mean_de, mean_non_de, p.values.adj, logFC, FC, out, num_de, num_non_de)
```

Add some information to this plot to be able to color plots by it (amino acid, codon, etc.)
```{r}
temp <- master_dataset %>%
  dplyr::select(Strain.Name, Anticodon, Best_isotype_model_1_letter, Family_size) %>%
  dplyr::rename(AA = Best_isotype_model_1_letter)
test_codon_enrichment <- left_join(test_codon_enrichment, temp, by = "Strain.Name")

temp <- resp_and_expression %>%
  dplyr::select(Strain.Name, codon_frequency_chu_2011)
test_codon_enrichment <- left_join(test_codon_enrichment, temp, by = "Strain.Name")
rm(temp)
```

"Volcano plot" - total DE proteins vs. non-DE proteins
```{r}
# Basic volcano plot - FC vs. -log10(adj.p-value) - tag only significant p-values and FCs
p <- ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total))) +
  geom_point(size = 3) +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light() +
  geom_text_repel(data = subset(test_codon_enrichment, (((logFC_total > 0.5 | logFC_total < -0.5) &
                                                           -log10(p.values.adj_total) > -log10(0.05)))|-log10(p.values.adj_total) > -log10(0.05)),
                  aes(x = logFC_total, y = -log10(p.values.adj_total), label = Strain.Name)) +
  xlab("logFC") +
  ylab("-log10(p-value)") +
  labs(title = "Target codon proportion in DE vs. non-DE proteins",
       subtitle = "Each dot represents a strain")

ggsave(filename = "target_codon_proportion_volcano_plot.svg",
       plot = p,
       path = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/compare_codon_content/",
       width = 12, height = 8, units = "in",       
       dpi = 600)

# Basic volcano plot - FC vs. -log10(adj.p-value) - tag all significant FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light() +
  geom_label_repel(data = subset(test_codon_enrichment, abs(logFC_total) > 0.5), 
                  aes(x = logFC_total, y = -log10(p.values.adj_total), label = Strain.Name)) +
  labs(title = "DE proteins vs. non-DE proteins")

# Color by count of DE proteins
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total), col = num_de_total)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by family
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total), col = Anticodon)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by family size
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total), col = Family_size)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by amino acid
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total), col = AA)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by codon frequency
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total), col = codon_frequency_chu_2011)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()
```

"Volcano plot" - up-regulated vs. non-DE proteins
```{r}
# Basic volcano plot - FC vs. -log10(adj.p-value) - tag only significant p-values and FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_up_non, y = -log10(p.values.adj_up_non))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light() +
  geom_label_repel(data = subset(test_codon_enrichment, abs(logFC_up_non) > 0.5 & p.values.adj_up_non < 0.05), 
                  aes(x = logFC_up_non, y = -log10(p.values.adj_up_non), label = Strain.Name),
                  size = 2.5) +
  labs(title = "Up-regulated proteins vs. non-DE proteins")

# Basic volcano plot - FC vs. -log10(adj.p-value) - tag all significant FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_up_non, y = -log10(p.values.adj_up_non))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light() +
  geom_text_repel(data = subset(test_codon_enrichment, logFC_up_non > 0.5 | logFC_up_non < -0.5), 
                  aes(x = logFC_up_non, y = -log10(p.values.adj_up_non), label = Strain.Name))

# Color by count of DE proteins
ggplot(data = test_codon_enrichment, aes(x = logFC_up_non, y = -log10(p.values.adj_up_non), col = num_de_up)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by family
ggplot(data = test_codon_enrichment, aes(x = logFC_up_non, y = -log10(p.values.adj_up_non), col = Anticodon)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by family size
ggplot(data = test_codon_enrichment, aes(x = logFC_up_non, y = -log10(p.values.adj_up_non), col = Family_size)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by amino acid
ggplot(data = test_codon_enrichment, aes(x = logFC_up_non, y = -log10(p.values.adj_up_non), col = AA)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by codon frequency
ggplot(data = test_codon_enrichment, aes(x = logFC_up_non, y = -log10(p.values.adj_up_non), col = codon_frequency_chu_2011)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()
```

"Volcano plot" - down-regulated vs. non-DE proteins
```{r}
# Basic volcano plot - FC vs. -log10(adj.p-value) - tag only significant p-values and FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_down_non, y = -log10(p.values.adj_down_non))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light() +
  geom_label_repel(data = subset(test_codon_enrichment, abs(logFC_down_non) > 0.5 & p.values.adj_down_non < 0.05), 
                  aes(x = logFC_down_non, y = -log10(p.values.adj_down_non), label = Strain.Name)) +
  labs(title = "Down-regulated proteins vs. non-DE proteins")

# Basic volcano plot - FC vs. -log10(adj.p-value) - tag all significant FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_down_non, y = -log10(p.values.adj_down_non))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light() +
  geom_text_repel(data = subset(test_codon_enrichment, logFC_down_non > 0.5 | logFC_down_non < -0.5), 
                  aes(x = logFC_down_non, y = -log10(p.values.adj_down_non), label = Strain.Name))

# Color by count of DE proteins
ggplot(data = test_codon_enrichment, aes(x = logFC_down_non, y = -log10(p.values.adj_down_non), col = num_de_down)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by family
ggplot(data = test_codon_enrichment, aes(x = logFC_down_non, y = -log10(p.values.adj_down_non), col = Anticodon)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by family size
ggplot(data = test_codon_enrichment, aes(x = logFC_down_non, y = -log10(p.values.adj_down_non), col = Family_size)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by amino acid
ggplot(data = test_codon_enrichment, aes(x = logFC_down_non, y = -log10(p.values.adj_down_non), col = AA)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by codon frequency
ggplot(data = test_codon_enrichment, aes(x = logFC_down_non, y = -log10(p.values.adj_down_non), col = codon_frequency_chu_2011)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()
```

"Volcano plot" - up-regulated vs. down-regulated proteins
```{r}
# Basic volcano plot - FC vs. -log10(adj.p-value) - tag only significant p-values and FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_up_down, y = -log10(p.values.adj_up_down))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light() +
  geom_label_repel(data = subset(test_codon_enrichment, (abs(logFC_up_down) > 0.5 & p.values.adj_up_down < 0.05) | abs(logFC_up_down) > 1.5), 
                  aes(x = logFC_up_down, y = -log10(p.values.adj_up_down), label = Strain.Name),
                  size = 2.5) +
  labs(title = "Up-regulated proteins vs. down-regulated proteins")

# Basic volcano plot - FC vs. -log10(adj.p-value) - tag all significant FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_up_down, y = -log10(p.values.adj_up_down))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light() +
  geom_text_repel(data = subset(test_codon_enrichment, logFC_up_down > 0.5 | logFC_up_down < -0.5), 
                  aes(x = logFC_up_down, y = -log10(p.values.adj_up_down), label = Strain.Name))

# Color by count of DE proteins
#ggplot(data = test_codon_enrichment, aes(x = logFC_up_down, y = -log10(p.values.adj_up_down), col = num_de_total)) +
#  geom_point() +
#  geom_hline(yintercept = -log10(alpha), col = "red") +
#  geom_vline(xintercept = 0.5, col = "red") +
#  geom_vline(xintercept = -0.5, col = "red") +
#  theme_light()

# Color by family
ggplot(data = test_codon_enrichment, aes(x = logFC_up_down, y = -log10(p.values.adj_up_down), col = Anticodon)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by family size
ggplot(data = test_codon_enrichment, aes(x = logFC_up_down, y = -log10(p.values.adj_up_down), col = Family_size)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by amino acid
ggplot(data = test_codon_enrichment, aes(x = logFC_up_down, y = -log10(p.values.adj_up_down), col = AA)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by codon frequency
ggplot(data = test_codon_enrichment, aes(x = logFC_up_down, y = -log10(p.values.adj_up_down), col = codon_frequency_chu_2011)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()
```

Create fake data that follows our hypothesis - for comparison to the real results, for the poster - WHY THE FLIP IS THERE A PROBLEM HERE NOW :(
```{r}
# Create fake data
fake_data <- list()
for (i in 1:length(codon_ratios_list)) {
  strain <- names(codon_ratios_list)[i]
  length_up <- length(codon_ratios_list[[strain]][["DE_up_regulated"]])
  length_down <- length(codon_ratios_list[[strain]][["DE_down_regulated"]])
  length_non <- length(codon_ratios_list[[strain]][["non_DE"]])
  
  # Up-regulated proteins
  ## If there are no such proteins - return empty vector
  if (length_up == 0) {
    fake_data[[strain]][["DE_up_regulated"]] <- c()
  }
  
  ## If there is only one such protein
  else if (length_up == 1) {
    # If I try to generate a distribution when I only have ratios = 0, I get NaN
    ifelse(mean(codon_ratios_list[[strain]][["DE_up_regulated"]]) == 0,
       fake_data[[strain]][["DE_up_regulated"]] <- rnorm(length_up, 
                                                         0.05, 
                                                         0.05),
       
       # If there is only one observation, I have to calculate the SD differently
       fake_data[[strain]][["DE_up_regulated"]] <- rnorm(length_up, 
                                                         mean(codon_ratios_list[[strain]][["DE_up_regulated"]], na.omit = T)*1.5, 
                                                         mean(codon_ratios_list[[strain]][["DE_up_regulated"]], na.omit = T)))
  }
  
  ## If there are 2 such proteins or more
  else if (length_up > 1) {
    # If I try to generate a distribution when I only have ratios = 0, I get NaN
    ifelse(mean(codon_ratios_list[[strain]][["DE_up_regulated"]]) == 0,
           fake_data[[strain]][["DE_up_regulated"]] <- rnorm(length_up, 
                                                             0.05, 
                                                             0.05),
           fake_data[[strain]][["DE_up_regulated"]] <- rnorm(length_up, 
                                                             mean(codon_ratios_list[[strain]][["DE_up_regulated"]], na.omit = T)*1.5, 
                                                             sd(codon_ratios_list[[strain]][["DE_up_regulated"]])*1.5))
  }

  
  # Down-regulated proteins
  ## If there are no such proteins - return empty vector
  if (length_down == 0) {
    fake_data[[strain]][["DE_down_regulated"]] <- c()
  }
  
  ## If there is only one such protein
  else if (length_down == 1) {
    # If I try to generate a distribution when I only have ratios = 0, I get NaN
    ifelse(mean(codon_ratios_list[[strain]][["DE_down_regulated"]]) == 0,
       fake_data[[strain]][["DE_down_regulated"]] <- rnorm(length_down, 
                                                           0.05, 
                                                           0.05),
       
       # If there is only one observation, I have to calculate the SD differently
       fake_data[[strain]][["DE_down_regulated"]] <- rnorm(length_down, 
                                                           mean(codon_ratios_list[[strain]][["DE_down_regulated"]], na.omit = T)*1.5, 
                                                           mean(codon_ratios_list[[strain]][["DE_down_regulated"]], na.omit = T)))
  }
  
  ## If there are 2 such proteins or more
  else if (length_down > 1) {
    # If I try to generate a distribution when I only have ratios = 0, I get NaN
    ifelse(mean(codon_ratios_list[[strain]][["DE_down_regulated"]]) == 0,
           fake_data[[strain]][["DE_down_regulated"]] <- rnorm(length_down, 
                                                               0.05, 
                                                               0.05),
           fake_data[[strain]][["DE_down_regulated"]] <- rnorm(length_down, 
                                                               mean(codon_ratios_list[[strain]][["DE_down_regulated"]], na.omit = T)*1.5, 
                                                               sd(codon_ratios_list[[strain]][["DE_down_regulated"]])*1.5))
  }
  
  # Non DE proteins
  if (length_non > 0) {
    fake_data[[strain]][["non_DE"]] <- codon_ratios_list[[strain]][["non_DE"]]
  }
  else {
    fake_data[[strain]][["non_DE"]] <- c()
  }
}


# Test and get p-values and logFC for fake data
strains <- names(fake_data)
p.values_wmw_total <- c()
p.values_wmw_up_non <- c()
p.values_wmw_up_down <- c()
p.values_wmw_down_non <- c()
mean_de_total <- c()
mean_de_up <- c()
mean_de_down <- c()
mean_non_de <- c()
num_de_total <- c()
num_de_up <- c()
num_de_down <- c()
num_non_de <- c()
for (i in 1:length(fake_data)) {
  # Grab data for this strain
  strain_name <- names(fake_data)[i]
  de_up <- fake_data[[strain_name]][["DE_up_regulated"]]
  de_down <- fake_data[[strain_name]][["DE_down_regulated"]]
  de_total <- c(as.numeric(de_up), as.numeric(de_down))
  non_de <- fake_data[[strain_name]][["non_DE"]]
  de_df_up <- data.frame(fake_data[[strain_name]][["DE_up_regulated"]])
  de_df_down <- data.frame(fake_data[[strain_name]][["DE_down_regulated"]])
  de_df_total <- data.frame(de_total)
  non_de_df <- data.frame(fake_data[[strain_name]][["non_DE"]])
  print(strain_name)
  
  # It's possible that either de_up or de_down (and hence de_df_up or de_df_down) are empty, so I need to account for that if I don't want to get an error
  de_up_empty <- length(de_up) == 0
  de_down_empty <- length(de_down) == 0
  
  if (de_up_empty) {
    # Plot overlapping histograms - not worth it I think
    ggplot() +
      geom_histogram(data = de_df_down, aes(x = log2(fake_data..strain_name.....DE...)), fill = "blue", alpha = 0.9)
      geom_histogram(data = non_de_df, aes(x = log2(fake_data..strain_name.....non_DE...)), fill = "orange", alpha = 0.4)
    
    # Test - WMW
    p.values_wmw_total <- c(p.values_wmw_total, wilcox.test(de_total, non_de)$p.value)
    p.values_wmw_up_non <- c(p.values_wmw_up_non, NA)
    p.values_wmw_up_down <- c(p.values_wmw_up_down, NA)
    p.values_wmw_down_non <- c(p.values_wmw_down_non, wilcox.test(de_down, non_de)$p.value)
    
    # Test - log2 transform and t-test (need to take care of 0s) and use t-test - is this worth doing?
    
    
    # Save the mean of each group to the output vectors as well
    mean_de_total <- c(mean_de_total, mean(de_total))
    mean_de_up <- c(mean_de_up, NA)
    mean_de_down <- c(mean_de_down, mean(de_down))
    mean_non_de <- c(mean_non_de, mean(non_de))
    
    # Save the number of proteins in each of the two groups - probably will explain the significance bc of low power with small DE protein counts
    num_de_total <- c(num_de_total, length(de_total))
    num_de_up <- c(num_de_up, length(de_up))
    num_de_down <- c(num_de_down, length(de_down))
    num_non_de <- c(num_non_de, length(non_de))
  }
  else if (de_down_empty) {
    # Plot overlapping histograms - not worth it I think
    ggplot() +
      geom_histogram(data = de_df_up, aes(x = log2(fake_data..strain_name.....DE...)), fill = "red", alpha = 0.9) +
      geom_histogram(data = non_de_df, aes(x = log2(fake_data..strain_name.....non_DE...)), fill = "orange", alpha = 0.4)
    
    # Test - WMW
    p.values_wmw_total <- c(p.values_wmw_total, wilcox.test(de_total, non_de)$p.value)
    p.values_wmw_up_non <- c(p.values_wmw_up_non, wilcox.test(de_up, non_de)$p.value)
    p.values_wmw_up_down <- c(p.values_wmw_up_down, NA)
    p.values_wmw_down_non <- c(p.values_wmw_down_non, NA)
    
    # Test - log2 transform and t-test (need to take care of 0s) and use t-test - is this worth doing?
    
    
    # Save the mean of each group to the output vectors as well
    mean_de_total <- c(mean_de_total, mean(de_total))
    mean_de_up <- c(mean_de_up, mean(de_up))
    mean_de_down <- c(mean_de_down, NA)
    mean_non_de <- c(mean_non_de, mean(non_de))
    
    # Save the number of proteins in each of the two groups - probably will explain the significance bc of low power with small DE protein counts
    num_de_total <- c(num_de_total, length(de_total))
    num_de_up <- c(num_de_up, length(de_up))
    num_de_down <- c(num_de_down, length(de_down))
    num_non_de <- c(num_non_de, length(non_de))
  }
  else {
    # Plot overlapping histograms - not worth it I think
    ggplot() +
      geom_histogram(data = de_df_up, aes(x = log2(fake_data..strain_name.....DE...)), fill = "red", alpha = 0.9) +
      geom_histogram(data = de_df_down, aes(x = log2(fake_data..strain_name.....DE...)), fill = "blue", alpha = 0.9)
      geom_histogram(data = non_de_df, aes(x = log2(fake_data..strain_name.....non_DE...)), fill = "orange", alpha = 0.4)
    
    # Test - WMW
    p.values_wmw_total <- c(p.values_wmw_total, wilcox.test(de_total, non_de)$p.value)
    p.values_wmw_up_non <- c(p.values_wmw_up_non, wilcox.test(de_up, non_de)$p.value)
    p.values_wmw_up_down <- c(p.values_wmw_up_down, wilcox.test(de_up, de_down)$p.value)
    p.values_wmw_down_non <- c(p.values_wmw_down_non, wilcox.test(de_down, non_de)$p.value)
    
    # Test - log2 transform and t-test (need to take care of 0s) and use t-test - is this worth doing?
    
    
    # Save the mean of each group to the output vectors as well
    mean_de_total <- c(mean_de_total, mean(de_total))
    mean_de_up <- c(mean_de_up, mean(de_up))
    mean_de_down <- c(mean_de_down, mean(de_down))
    mean_non_de <- c(mean_non_de, mean(non_de))
    
    # Save the number of proteins in each of the two groups - probably will explain the significance bc of low power with small DE protein counts
    num_de_total <- c(num_de_total, length(de_total))
    num_de_up <- c(num_de_up, length(de_up))
    num_de_down <- c(num_de_down, length(de_down))
    num_non_de <- c(num_non_de, length(non_de))
  }
}

p.values.adj_total <- p.adjust(p.values_wmw_total, method = "fdr")
p.values.adj_up_non <- p.adjust(p.values_wmw_up_non, method = "fdr")
p.values.adj_up_down <- p.adjust(p.values_wmw_up_down, method = "fdr")
p.values.adj_down_non <- p.adjust(p.values_wmw_down_non, method = "fdr")

test_codon_enrichment_fake <- data.frame(Strain.Name = strains, p.values_wmw_up_non, p.values.adj_up_non, p.values_wmw_total, p.values.adj_total,
                                    p.values_wmw_up_down, p.values.adj_up_down, p.values_wmw_down_non, p.values.adj_down_non,
                                    mean_de_total, mean_de_up, mean_de_down, mean_non_de, num_de_total, num_de_up, num_de_down, num_non_de) %>%
  dplyr::mutate(direction_up_non = case_when(mean_de_up > mean_non_de ~ "DE_up",
                                      TRUE ~ "non_DE"),
         direction_up_down = case_when(mean_de_up > mean_de_down ~ "DE_up",
                                       TRUE ~ "DE_down"),
         direction_down_non = case_when(mean_de_down > mean_non_de ~ "DE_down",
                                        TRUE ~ "non_DE"),
         FC_total = mean_de_total/mean_non_de,
         FC_up_non = mean_de_up/mean_non_de,
         FC_up_down = mean_de_up/mean_de_down,
         FC_down_non = mean_de_down/mean_non_de,
         logFC_total = log2(FC_total),
         logFC_up_non = log2(FC_up_non),
         logFC_up_down = log2(FC_up_down),
         logFC_down_non = log2(FC_down_non))
```

Barplot - better version of these "volcano plots" - includes the simulated data in a lighter shade
```{r}
# Sort real data
test_codon_enrichment <- test_codon_enrichment %>%
  dplyr::arrange(logFC_total)
test_codon_enrichment$Strain.Name <- factor(test_codon_enrichment$Strain.Name, levels = unique(test_codon_enrichment$Strain.Name))

# Sort fake data
test_codon_enrichment_fake <- test_codon_enrichment_fake %>%
  dplyr::arrange(logFC_total)
test_codon_enrichment_fake$Strain.Name <- factor(test_codon_enrichment_fake$Strain.Name, levels = unique(test_codon_enrichment_fake$Strain.Name))

horizontal_barplot <- ggplot(data = test_codon_enrichment, aes(x = Strain.Name, y = logFC_total, fill = p.values.adj_total)) +
  geom_col(col = "black") +
  geom_col(data = test_codon_enrichment_fake,
           aes(x = Strain.Name, y = logFC_total, fill = p.values.adj_total),
           alpha = 0.4) +
  scale_fill_viridis_c(name = "Adj. p-value") +
  theme_light() +
  ylab("logFC") +
  xlab("Strain") +
  labs(fill = "Adjusted p-value",
       title = "Ratios between target codon content",
       subtitle = "In DE vs. non-DE proteins") +
  coord_flip() +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank())

ggsave(filename = "christmas_tree_barplot.svg",
       plot = horizontal_barplot,
       path = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/compare_codon_content/",
       width = 5, height = 4, units = "in",       
       dpi = 600)
```

Check codon enrichment in tRNAs in singleton families
```{r}
# Get names of tRNAs in singleton families
singleton_family_tRNAs <- master_dataset$Strain.Name[master_dataset$Family_size == 1]

# Look at the target codon enrichment in these families
test_codon_single_families <- test_codon_enrichment %>%
  dplyr::filter(Strain.Name %in% singleton_family_tRNAs)
```

Remove unnecessary variables
```{r}
rm(codon_ratios_list, de_df, master_dataset, non_de_df, resp_and_expression, test_codon_enrichment, de, i, non_de, strain_name)
```


## 4.2. In the 5' end - about ribosome queueing, based on Kemp et al., 2012
### 4.2.1. Some required previous stuff
Need to save a list of the codons (in DNA code) to iterate over them in the Python script
```{r}
# Load responsiveness dataset
responsiveness <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/produced_during_analysis/responsiveness_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv"))

# The master tRNA dataset
master_dataset <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/master_tRNA_dataset.csv"))

# Grab unique codons (mRNA codons in DNA letters, that's how they come in the CDS from SGD)
Anticodons <- unique(responsiveness$Anticodon)
codons <- master_dataset %>%
  dplyr::filter(Anticodon %in% Anticodons) %>%
  dplyr::distinct(Codon) %>%
  dplyr::pull(Codon)

# Save this to load it in Python
write_json(codons, 
           path = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/check_codon_enrichment_in_protein_sequences/check_in_5_prime_end/unique_target_codons.json")
```

Have a quick look at the translation initiation rate I got from Riba et al., 2019 before I use it
```{r}
# Estimated using one method, oligoDT something
initiation_rate_oligo_dt <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/Articles/riba_2019/sup_dataset_1.tsv"))

ggplot(data = initiation_rate_oligo_dt, aes(x = real_protein_synthesis_per_mrna)) +
  geom_histogram(fill = "grey", col = "black", binwidth = 0.5) +
  theme_light() 

ggplot(data = initiation_rate_oligo_dt, aes(x = real_protein_synthesis_per_mrna)) +
  geom_histogram(fill = "grey", col = "black", binwidth = 0.1) +
  theme_light() +
  coord_cartesian(xlim = c(0, 2))


# Estimated using a different method, ribo-zero, supposed to avoid poly(A) bias, sometimes better for low abundance transcripts
initation_rate_ribo_zero <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/Articles/riba_2019/sup_dataset_2.tsv"))

ggplot(data = initation_rate_ribo_zero, aes(x = real_protein_synthesis_per_mrna)) +
  geom_histogram(fill = "grey", col = "black", binwidth = 0.5) +
  theme_light() 

ggplot(data = initation_rate_ribo_zero, aes(x = real_protein_synthesis_per_mrna)) +
  geom_histogram(fill = "grey", col = "black", binwidth = 0.1) +
  theme_light() +
  coord_cartesian(xlim = c(0, 2))

# --> I think for now I will select the ones with high initiation rate based on the first one, they don't seem too different
```


### 4.2.2. Create the lists of DE proteins in our tRNA KOs and in the 5k based on the codons at the beginning 
Load the data
```{r}
# In how many of the first codons from the 5' end do we want to check? (either 30 or 50)
initial_codons_num <- 10

# Codon content produced with Python
codon_enrichment_initial_codons <- as.data.frame(fread(paste(base_dir, 
                                                             "tRNA_KOs/Data/check_codon_enrichment_in_protein_sequences/check_in_5_prime_end/codon_proportions_first_",
                                                             initial_codons_num, 
                                                             "_codons.csv",
                                                             sep = "")))

# The master tRNA dataset
master_dataset <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/master_tRNA_dataset.csv"))

# Load p-values dataframe from Messner et al., 2023
messner_5k <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/5k/yeast5k_stat_DE.csv"))

# UniProt dataset (rows in Messner et al., 2023 dataset are UniProt IDs)
uniprot_db <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv"))

# DE proteins in tRNA_KOs
de_proteins_list_tRNAs <- fromJSON("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/enrichment_analysis/de_proteins_list_up_down_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", )
de_proteins_list_tRNAs <- Filter(function(x) length(x) > 0, de_proteins_list_tRNAs)

# Load DE proteins from my DE analysis of the 5k data
logFC_for_5k <- 0.5
de_proteins_list_5k <- readRDS("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/5k/de_proteins_list_up_down_", alpha_plain, "_logFC_", as.character(logFC_for_5k), ".RData")
de_proteins_list_5k <- Filter(function(x) length(x) > 0, de_proteins_list_5k)
```

Some initial checks, manipulate the data obtained in Python and add information from Messner et al., 2023
```{r}
# Set protein names as rownames - create only numerical dataframe to make some histograms, then delete
codon_enrichment_initial_codons_numerical <- codon_enrichment_initial_codons
rownames(codon_enrichment_initial_codons_numerical) <- codon_enrichment_initial_codons_numerical$Protein
codon_enrichment_initial_codons_numerical <- codon_enrichment_initial_codons_numerical %>%
  dplyr::select(-Protein)

# Look at distribution
hist(as.matrix(codon_enrichment_initial_codons_numerical))
sum(as.matrix(codon_enrichment_initial_codons_numerical > 0.2))
rm(codon_enrichment_initial_codons_numerical)

# Pivot longer, add information from master_dataset and Messner et al., 2023, filter for high proportion of target codon
codon_enrichment_initial_codons_long <- pivot_longer(data = codon_enrichment_initial_codons, 
                                                     cols = -Protein,
                                                     names_to = "Codon",
                                                     values_to = "Percentage") 
temp_master <- master_dataset %>%
  dplyr::select(Codon, Amino_acid_1_letter, Anticodon, Family_size)

codon_enrichment_initial_codons_long <- left_join(codon_enrichment_initial_codons_long, temp_master, by = "Codon") %>%
  dplyr::distinct(Protein, Codon, Amino_acid_1_letter, Anticodon, Family_size, .keep_all = T) %>%
  dplyr::mutate(KOd_in_5k = case_when(Protein %in% colnames(messner_5k) ~ "Yes",
                                      TRUE ~ "No"))

codon_enrichment_initial_codons_long <- codon_enrichment_initial_codons_long %>%
  dplyr::filter(Percentage > 0.2) %>%
  dplyr::arrange(desc(Percentage), Anticodon)

length(unique(codon_enrichment_initial_codons_long$Codon))
sum(codon_enrichment_initial_codons_long$KOd_in_5k == "Yes")

# Keep only those rows where the protein was KOd in the 5k paper, since now I'm going to compare the DE proteins there and in my proteomics data
codon_enrichment_initial_codons_long <- codon_enrichment_initial_codons_long %>%
  dplyr::filter(KOd_in_5k == "Yes")
```
--> 37 of the 59 proteins I want to check were KOd in the 5k paper, that's something I guess


Build a list to compare DE proteins between the 5k and the tRNA KOs. The structure of the list will be the following: 
- Codon: The main entry is named after the codon we are looking at
  - 5k:
    - 1st protein whose 5' end is rich in this codon and which was KOd in the 5k: the DE proteins in this KO in the 5k
    - 2nd ''
    - ...
    - Total: concatenation of the above lists in this 5k entry
  
  - tRNA_KOs:
    - 1st tRNA whose Anticodon matches this codon: DE proteins found for the KO of this tRNA
    - 2nd ''
    - ...
    - Total: concatenation of the above lists in this tRNA_KOs entry
    
There will be 3 lists like this: one with all the DE proteins for that codon (as illustrated here), then 2 other versions where in one there's only the up-regulated proteins, and the down-regulated proteins in the other one. Think that should do it :)
```{r}
de_proteins_per_target_codon_all <- list()
de_proteins_per_target_codon_up <- list()
de_proteins_per_target_codon_down <- list()
codons <- unique(codon_enrichment_initial_codons_long$Codon)

for (i in 1:length(codons)) {
  # Grab the target codon we are evaluating in this iteration
  codon <- codons[i]
  list_for_this_codon_all <- list()
  list_for_this_codon_up <- list()
  list_for_this_codon_down <- list()
  
  # For the 5k data
  list_5k_all <- list()
  all_5k_de_proteins_all <- c()
  list_5k_up <- list()
  all_5k_de_proteins_up <- c()
  list_5k_down <- list()
  all_5k_de_proteins_down <- c()
  
  ## Get the names of the proteins whose 5' end is rich in this target codon
  proteins_of_interest <- codon_enrichment_initial_codons_long %>%
    dplyr::filter(Codon == codon) %>%
    dplyr::pull(Protein)
  
  ## Grab the proteins that are DE when each of these proteins is KOd in the 5k
  for (j in 1:length(proteins_of_interest)) {
    protein_of_interest <- proteins_of_interest[j]
    list_5k_up[[protein_of_interest]] <- unlist(de_proteins_list_5k[[protein_of_interest]][["Up"]])
    all_5k_de_proteins_up <- c(all_5k_de_proteins_up, list_5k_up[[protein_of_interest]])
    
    list_5k_down[[protein_of_interest]] <- unlist(de_proteins_list_5k[[protein_of_interest]][["Down"]])
    all_5k_de_proteins_down <- c(all_5k_de_proteins_down, list_5k_down[[protein_of_interest]])
    
    list_5k_all[[protein_of_interest]] <- c(list_5k_up[[protein_of_interest]], list_5k_down[[protein_of_interest]])
    all_5k_de_proteins_all <- c(all_5k_de_proteins_all, list_5k_all[[protein_of_interest]])
  }
  list_5k_up[["All_5k"]] <- unique(all_5k_de_proteins_up)
  list_5k_down[["All_5k"]] <- unique(all_5k_de_proteins_down)
  list_5k_all[["All_5k"]] <- unique(all_5k_de_proteins_all)
  
  ## Add the 5k list to the overall list for this target codon
  list_for_this_codon_up[["list_5k"]] <- list_5k_up[unlist(lapply(list_5k_up, function(x) length(x))) > 0]
  list_for_this_codon_down[["list_5k"]] <- list_5k_down[unlist(lapply(list_5k_down, function(x) length(x))) > 0]
  list_for_this_codon_all[["list_5k"]] <- list_5k_all[unlist(lapply(list_5k_all, function(x) length(x))) > 0]
  
  
  
  # For the tRNA KOs data
  list_trna_kos_all <- list()
  all_trna_ko_de_proteins_all <- c()
  list_trna_kos_up <- list()
  all_trna_ko_de_proteins_up <- c()
  list_trna_kos_down <- list()
  all_trna_ko_de_proteins_down <- c()
  
  ## Get the names of the tRNA KOs whose Anticodon matches the target codon
  Anticodon <- unique(codon_enrichment_initial_codons_long$Anticodon[codon_enrichment_initial_codons_long$Codon == codon])
  trna_kos <- names(de_proteins_list_tRNAs)[grepl(Anticodon, names(de_proteins_list_tRNAs))]
  
  ## Grab the proteins that are DE in each of these tRNA KOs
  for (j in 1:length(trna_kos)) {
    trna <- trna_kos[j]
    list_trna_kos_up[[trna]] <- unlist(de_proteins_list_tRNAs[[trna]][["Up"]])
    all_trna_ko_de_proteins_up <- c(all_trna_ko_de_proteins_up, list_trna_kos_up[[trna]])
    
    list_trna_kos_down[[trna]] <- unlist(de_proteins_list_tRNAs[[trna]][["Down"]])
    all_trna_ko_de_proteins_down <- c(all_trna_ko_de_proteins_down, list_trna_kos_down[[trna]])
    
    list_trna_kos_all[[trna]] <- c(unlist(de_proteins_list_tRNAs[[trna]][["Up"]]), unlist(de_proteins_list_tRNAs[[trna]][["Down"]]))
    all_trna_ko_de_proteins_all <- c(all_trna_ko_de_proteins_all, list_trna_kos_all[[trna]])
  }
  list_trna_kos_up[["All_tRNA_KOs"]] <- unique(all_trna_ko_de_proteins_up)
  list_trna_kos_down[["All_tRNA_KOs"]] <- unique(all_trna_ko_de_proteins_down)
  list_trna_kos_all[["All_tRNA_KOs"]] <- unique(all_trna_ko_de_proteins_all)
  
  ## Add the tRNA KO list to the overall list for this target codon
  list_for_this_codon_up[["list_tRNA_KO"]] <- list_trna_kos_up[unlist(lapply(list_trna_kos_up, function(x) length(x))) > 0]
  list_for_this_codon_down[["list_tRNA_KO"]] <- list_trna_kos_down[unlist(lapply(list_trna_kos_down, function(x) length(x))) > 0]
  list_for_this_codon_all[["list_tRNA_KO"]] <- list_trna_kos_all[unlist(lapply(list_trna_kos_all, function(x) length(x))) > 0]
  
  
  
  # Now that the list for this target codon is finished, we append it to the final list
  de_proteins_per_target_codon_up[[codon]] <- list_for_this_codon_up
  de_proteins_per_target_codon_down[[codon]] <- list_for_this_codon_down
  de_proteins_per_target_codon_all[[codon]] <- list_for_this_codon_all
}
```

Investigate the Jaccard indexes for these lists of proteins
For each codon, I'm going to calculate the Jaccard index between all lists of proteins and plot them in a heatmap I think
```{r}
# Function that calculates Jaccard indexes and generates heatmaps of them - so I can apply it to the lists of all proteins, of up-regulated ones and of down-regulates ones
jaccard_indexes_and_heatmaps <- function(de_proteins_per_target_codon) {
  list_of_Jaccard_mats <- list()
  plot_list <- list()
  codons <- names(de_proteins_per_target_codon)
  
  for (i in 1:length(codons)) {
    codon <- codons[i]
    
    # Get the Jaccard matrix for all the lists of DE proteins for a certain codon and save it to a list
    list_all_DE_proteins_for_this_codon <- c(de_proteins_per_target_codon[[codon]][["list_5k"]], de_proteins_per_target_codon[[codon]][["list_tRNA_KO"]])
    Jaccard_mat <- get_jaccad_index_matrix(list_all_DE_proteins_for_this_codon, names(list_all_DE_proteins_for_this_codon))
    list_of_Jaccard_mats[[codon]] <- Jaccard_mat
    
        # Get a heatmap from this matrix and also save it to a list
    ## Melt matrix and make sure to specify to keep the order of the samples as it is there
    melt_mat <- helperfunctions::melt(Jaccard_mat)
    melt_mat$Var1 <- factor(melt_mat$Var1, levels = rownames(Jaccard_mat))
    melt_mat$Var2 <- factor(melt_mat$Var2, levels = colnames(Jaccard_mat))
    
    ## Create the annotation rectangles for the heatmap
    highlight_rect_large <- annotate("rect",
                                     xmin = 0,
                                     xmax = which(levels(melt_mat$Var1) == "All_5k") + 0.5,
                                     ymin = which(levels(melt_mat$Var2) == "All_5k") + 0.5,
                                     ymax = which(levels(melt_mat$Var2) == "All_tRNA_KOs") + 0.5,
                                     color = "darkblue",
                                     fill = NA,
                                     linewidth = 2)
    highlight_rect_small <- annotate("rect",
                                     xmin = which(levels(melt_mat$Var1) == "All_5k") - 0.5,
                                     xmax = which(levels(melt_mat$Var1) == "All_5k") + 0.5,              
                                     ymin = which(levels(melt_mat$Var2) == "All_tRNA_KOs") - 0.5,
                                     ymax = which(levels(melt_mat$Var2) == "All_tRNA_KOs") + 0.5,        
                                     color = "darkgreen",
                                     fill = NA,
                                     linewidth = 2)
    
    ## Create the heatmap and add the annotation rectangles created above
    plot_list[[codon]] <- ggplot(melt_mat, aes(Var1, Var2)) +
                              geom_tile(aes(fill = value), colour = "white") +
                              scale_fill_gradient(low = "white", high = "red") +
                              coord_fixed() +
                              xlab("") +
                              ylab("") +
                              labs(title = glue("{codon}")) +
                              theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
                              highlight_rect_large +
                              highlight_rect_small
    print(plot_list[[codon]])
  }
  out <- list(list_of_Jaccard_mats, plot_list)
  return(out)
}
```

- For all DE proteins
```{r}
output_list <- jaccard_indexes_and_heatmaps(de_proteins_per_target_codon_all)
list_of_Jaccard_mats <- output_list[[1]]
plot_list <- output_list[[2]]

# Save the plots to a PDF
my_grobs <- lapply(plot_list, ggplotGrob)
output_file <- "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/compare_codon_content/check_in_5_prime_end/Jaccard_index_heatmaps_5k_vs_tRNA_KOs_all_DE_proteins_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf"
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=2, ncol=2), 
   width = 15, height = 9
)
```

- For up-regulated proteins
```{r}
output_list <- jaccard_indexes_and_heatmaps(de_proteins_per_target_codon_up)
list_of_Jaccard_mats <- output_list[[1]]
plot_list <- output_list[[2]]

# Save the plots to a PDF
my_grobs <- lapply(plot_list, ggplotGrob)
output_file <- "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/compare_codon_content/check_in_5_prime_end/Jaccard_index_heatmaps_5k_vs_tRNA_KOs_up_proteins_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf"
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=2, ncol=2), 
   width = 15, height = 9
)
```

- For down-regulated proteins
```{r}
output_list <- jaccard_indexes_and_heatmaps(de_proteins_per_target_codon_down)
list_of_Jaccard_mats <- output_list[[1]]
plot_list <- output_list[[2]]

# Save the plots to a PDF
my_grobs <- lapply(plot_list, ggplotGrob)
output_file <- "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/compare_codon_content/check_in_5_prime_end/Jaccard_index_heatmaps_5k_vs_tRNA_KOs_down_proteins_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf"
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=2, ncol=2), 
   width = 15, height = 9
)
```


### 4.2.3. Grab the lists of DE proteins generated above, but keep only those where the KO/high target codon concentration in 5' end protein is a high-initiation rate protein
Grab the names of the proteins with high initiation rates
```{r}
median_initiation_rate <- median(initiation_rate_oligo_dt$real_protein_synthesis_per_mrna)           # just as a reference, I'm using a higher value anyway
genes_with_high_initiation_rate <- initiation_rate_oligo_dt$ensembl_gene_id[initiation_rate_oligo_dt$real_protein_synthesis_per_mrna > 0.1]
```

Filter out the DE proteins lists created in previous section
```{r}
filter_list <- function(my_list) {
  # Go through the KOd proteins in 5k and the high target codon 5' proteins in tRNA KO (for each of them we have the list of DE proteins as a consequence of them), and keep only those which have a high initiation rate. For those lists in which there is no protein with no high initiation rate, I set the list to NULL and filter it afterwards
  list_names_1 <- names(my_list)
  for (i in 1:length(list_names_1)) {
    name_1 <- list_names_1[i]
    list_names_2 <- names(my_list[[name_1]])
    temp_list <- my_list[[name_1]][["list_5k"]]
    if (sum(names(temp_list) %in% genes_with_high_initiation_rate) > 0) {
      my_list[[name_1]][["list_5k"]] <- temp_list[names(temp_list) %in% genes_with_high_initiation_rate]
      my_list[[name_1]][["list_5k"]][["All_5k"]] <- unique(unlist(my_list[[name_1]][["list_5k"]]))
    }
    else {
      my_list[[name_1]][["list_5k"]] <- NULL
    }
  }
  
  # Filter out the NULL lists - I remove the entry for any codon for which either the 5k or tRNA KO list is NULL - bc I won't be able to do anything with it
  for (i in 1:length(list_names_1)) {
    name_1 <- list_names_1[i]
    if (is.null(my_list[[name_1]][["list_5k"]])) {
      my_list <- my_list[names(my_list) != name_1]
    }
  }
  
  return(my_list)
}

de_proteins_per_target_codon_all_high_initiation_rate <- filter_list(de_proteins_per_target_codon_all)
de_proteins_per_target_codon_down_high_initiation_rate <- filter_list(de_proteins_per_target_codon_down)
de_proteins_per_target_codon_up_high_initiation_rate <- filter_list(de_proteins_per_target_codon_up)
```

Investigate the Jaccard indexes for these lists of proteins
For each codon, I'm going to calculate the Jaccard index between all lists of proteins and plot them in a heatmap I think
```{r}
# Function that calculates Jaccard indexes and generates heatmaps of them - so I can apply it to the lists of all proteins, of up-regulated ones and of down-regulates ones
jaccard_indexes_and_heatmaps <- function(de_proteins_per_target_codon) {
  list_of_Jaccard_mats <- list()
  plot_list <- list()
  codons <- names(de_proteins_per_target_codon)
  
  for (i in 1:length(codons)) {
    codon <- codons[i]
    
    # Get the Jaccard matrix for all the lists of DE proteins for a certain codon and save it to a list
    list_all_DE_proteins_for_this_codon <- c(de_proteins_per_target_codon[[codon]][["list_5k"]], de_proteins_per_target_codon[[codon]][["list_tRNA_KO"]])
    Jaccard_mat <- get_jaccad_index_matrix(list_all_DE_proteins_for_this_codon, names(list_all_DE_proteins_for_this_codon))
    list_of_Jaccard_mats[[codon]] <- Jaccard_mat
    
    # Get a heatmap from this matrix and also save it to a list
    ## Melt matrix and make sure to specify to keep the order of the samples as it is there
    melt_mat <- helperfunctions::melt(Jaccard_mat)
    melt_mat$Var1 <- factor(melt_mat$Var1, levels = rownames(Jaccard_mat))
    melt_mat$Var2 <- factor(melt_mat$Var2, levels = colnames(Jaccard_mat))
    
    ## Create the annotation rectangles for the heatmap
    highlight_rect_large <- annotate("rect",
                                     xmin = 0,
                                     xmax = which(levels(melt_mat$Var1) == "All_5k") + 0.5,
                                     ymin = which(levels(melt_mat$Var2) == "All_5k") + 0.5,
                                     ymax = which(levels(melt_mat$Var2) == "All_tRNA_KOs") + 0.5,
                                     color = "darkblue",
                                     fill = NA,
                                     linewidth = 2)
    highlight_rect_small <- annotate("rect",
                                     xmin = which(levels(melt_mat$Var1) == "All_5k") - 0.5,
                                     xmax = which(levels(melt_mat$Var1) == "All_5k") + 0.5,              
                                     ymin = which(levels(melt_mat$Var2) == "All_tRNA_KOs") - 0.5,
                                     ymax = which(levels(melt_mat$Var2) == "All_tRNA_KOs") + 0.5,        
                                     color = "darkgreen",
                                     fill = NA,
                                     linewidth = 2)
    
    ## Create the heatmap and add the annotation rectangles created above
    plot_list[[codon]] <- ggplot(melt_mat, aes(Var1, Var2)) +
                              geom_tile(aes(fill = value), colour = "white") +
                              scale_fill_gradient(low = "white", high = "red") +
                              coord_fixed() +
                              xlab("") +
                              ylab("") +
                              labs(title = glue("{codon}")) +
                              theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
                              highlight_rect_large +
                              highlight_rect_small
    print(plot_list[[codon]])
  }
  out <- list(list_of_Jaccard_mats, plot_list)
  return(out)
}
```

- For all DE proteins
```{r}
output_list <- jaccard_indexes_and_heatmaps(de_proteins_per_target_codon_all_high_initiation_rate)
list_of_Jaccard_mats <- output_list[[1]]
plot_list <- output_list[[2]]

# Save the plots to a PDF
my_grobs <- lapply(plot_list, ggplotGrob)
output_file <- "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/compare_codon_content/check_in_5_prime_end/Jaccard_index_heatmaps_high_initiation_rate_5k_vs_tRNA_KOs_all_DE_proteins_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf"
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=2, ncol=2), 
   width = 15, height = 9
)
```

- For up-regulated proteins
```{r}
output_list <- jaccard_indexes_and_heatmaps(de_proteins_per_target_codon_up_high_initiation_rate)
list_of_Jaccard_mats <- output_list[[1]]
plot_list <- output_list[[2]]

# Save the plots to a PDF
my_grobs <- lapply(plot_list, ggplotGrob)
output_file <- "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/compare_codon_content/check_in_5_prime_end/Jaccard_index_heatmaps_high_initiation_rate_5k_vs_tRNA_KOs_up_proteins_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf"
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=2, ncol=2), 
   width = 15, height = 9
)
```

- For down-regulated proteins
```{r}
output_list <- jaccard_indexes_and_heatmaps(de_proteins_per_target_codon_down_high_initiation_rate)
list_of_Jaccard_mats <- output_list[[1]]
plot_list <- output_list[[2]]

# Save the plots to a PDF
my_grobs <- lapply(plot_list, ggplotGrob)
output_file <- "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/compare_codon_content/check_in_5_prime_end/Jaccard_index_heatmaps_high_initiation_rate_5k_vs_tRNA_KOs_down_proteins_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf"
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=2, ncol=2), 
   width = 15, height = 9
)
```







################################################################################
# 5. Look for the expression of the tRNA synthetases in my proteomics data
################################################################################
## 5.0. Load data
```{r}
# List of dataframes with the proteins that were DE in each KO strain
de_proteins_list <- fromJSON("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/enrichment_analysis/de_proteins_list_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json")

## Remove WT dataframe
de_proteins_list <- de_proteins_list[names(de_proteins_list) != "WT"]

# Synthetase information
chu_synths <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/Articles/chu_2011/S3.csv"))[1:20,] 
synthetases <- fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/trna_synthetases.csv")

# UniProt dataset
uniprot_db <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv"))

# Yeastmine
yeastmine <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/databases/alliancemine_results_2024-11-20T11-19-04.tsv"))

# Responsiveness
responsiveness <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/produced_during_analysis/responsiveness_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv"))

# limpa output
dpcfit <- readRDS("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/limpa_analysis/dpcfit.rds")
y.protein <- readRDS("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/limpa_analysis/y.protein.rds")

## Set this so I don't have to change its name in the code below
trna_ko <- y.protein$E

# da
da <- read_json(path="/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/enrichment_analysis/da_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", simplifyVector = T)

# Import the functions I have created in another file
source("/home/alvaro/MyStuff/Projects/tRNA_KOs/Code/R/Mine/0.general_use_functions.R")
```


## 5.1. Evaluate some basic stuff about synthetases: how many there are, how many do I detect, etc.
Check how many synthetases exist in Sc
```{r}
# How many tRNA synthases
sum(grepl("trna synthase", synthetases$Gene.name, ignore.case = T))

# How many tRNA synthetases 
sum(grepl("trna synthetase", synthetases$Gene.name, ignore.case = T))

# How many are mitochondrial?
sum(grepl("mitochondrial", synthetases$Gene.name, ignore.case = T))
```

Check how many of them we detect in our dataset
```{r}
# Get all the proteins we detect into systematic notation
detected_proteins <- match_systematic_and_standard_protein_names(data = rownames(trna_ko),
                                                                 uniprot = uniprot_db,
                                                                 input = "standard",
                                                                 output = "systematic",
                                                                 simplify = T)

# See how many tRNA synthetases are in there: 18, 67% of them
sum(detected_proteins %in% synthetases$Gene.secondaryIdentifier)
sum(detected_proteins %in% synthetases$Gene.secondaryIdentifier)/length(unique(synthetases$Gene.secondaryIdentifier))

# Check which ones: only 1 is mitochondrial, all others are cytosolic - so I think we are mainly interested in cytosolic, we detect 17 of the 18 there are, the one we don't detect is YPL040C
synths_detected <- synthetases[synthetases$Gene.secondaryIdentifier %in% detected_proteins,]
sum(synths_detected$mitochondrial == "Yes")
sum(synthetases$mitochondrial == "No")
temp <- synthetases$Gene.secondaryIdentifier[synthetases$mitochondrial == "No"]
synthetases$Gene.secondaryIdentifier[!(synthetases$Gene.secondaryIdentifier %in% synths_detected$Gene.secondaryIdentifier) & (synthetases$mitochondrial == "No")]
```

Check how much of each we detect across WTs, add that information to the dataset and save the dataset
```{r}
# Prepare
WTs <- trna_ko[, grepl("WT", colnames(trna_ko))]
KOs <- trna_ko[, !grepl("WT", colnames(trna_ko))]
rownames(WTs) <- match_systematic_and_standard_protein_names(as.vector(rownames(WTs)),
                                                             uniprot = uniprot_db, 
                                                             input = "standard",
                                                             output = "systematic",
                                                             simplify = T)

# Actually check and save it to a new column in the dataframe
measured_proteomics_WTs <- c()
quantified_in_how_many_WTs <- c()
quantified_in_how_many_KO_samples <- c()
for (i in 1:nrow(synthetases)) {
  synth <- synthetases$Gene.secondaryIdentifier[i]
  synth_definition <- synthetases$Gene.name[i]
  
  # If the synthetase is detected at all, present in the dataset
  if (synth %in% rownames(WTs)) {
    ## Get the average expression of this synthetase across WTs
    synth_quant_across_WTs <- as.numeric(WTs[rownames(WTs) == synth,])
    measured_proteomics_WTs <- c(measured_proteomics_WTs, mean(synth_quant_across_WTs, na.rm = T))
    hist(as.numeric(WTs[rownames(WTs) == synth,]),
         main = glue("{synth} - {synth_definition}"),
         xlab = "log2(Abundance)")
    
    ## In how many WT samples is this synthetase actually detected? (value != 0)
    quantified_in_how_many_WTs <- c(quantified_in_how_many_WTs, sum(synth_quant_across_WTs != 0))
    
    ## In how many samples in total is this synthetase actually detected? (value != 0)
    synth_quant_across_KO_samples <- as.numeric(KOs[rownames(KOs) == synth,])
    quantified_in_how_many_KO_samples <- c(quantified_in_how_many_KO_samples, sum(synth_quant_across_KO_samples != 0))
  }
  
  # If it is not
  else {
    measured_proteomics_WTs <- c(measured_proteomics_WTs, NA)
    quantified_in_how_many_WTs <- c(quantified_in_how_many_WTs, NA)
    quantified_in_how_many_KO_samples <- c(quantified_in_how_many_KO_samples, NA)
  }
}
synthetases$measured_proteomics_WTs_WT <- measured_proteomics_WTs
synthetases$quantified_in_how_many_WTs <- quantified_in_how_many_WTs
synthetases$quantified_in_how_many_KO_samples <- quantified_in_how_many_KO_samples


# Add columns with all other amino acid information
temp <- fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/databases/GtRNAdb/amino_acids.csv") %>%
  dplyr::select(-molecular_weight_Da)
synthetases <- left_join(synthetases, temp, by = "Amino_acid_3_letter")


# One final thing - add information of which ones are included in the TS library, and which ones are included in the GFP/RFP data
ts_metadata <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/TSSC/Data/Boone_lab/metadata.csv"))
ts_fluorescence_raw_1 <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/TSSC/Data/Boone_lab/Fluorescence/raw_1.csv"))

synthetases <- synthetases %>%
  dplyr::mutate(in_ts_library = case_when(Gene.secondaryIdentifier %in% ts_metadata$Sys.Name ~ "Yes",
                                          TRUE ~ "No"),
                in_fluorescence_data = case_when(Gene.symbol %in% ts_fluorescence_raw_1$Gene ~ "Yes",
                                                 TRUE ~ "No"))

# Get a subset of this for a screenshot for a slide
temp <- synthetases %>%
  dplyr::select(Gene.name, Gene.symbol, Gene.secondaryIdentifier, mitochondrial, Amino_acid_3_letter, in_ts_library, in_fluorescence_data)


# Save this dataset
fwrite(synthetases, "/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/trna_synthetases.csv")
```


## 5.2. Go over the KO strains and see if any of the synthetases are DE in any of them - get this information into a dataframe
```{r}
strains_for_df <- c()
synths_for_df <- c()
status_for_df <- c()

de_synthetases_df <- as.data.frame(matrix(nrow = 0, ncol = 3))
synthetase_names <- synthetases$Gene.secondaryIdentifier

# Iterate over strains - check DE proteins for each
for (i in 1:length(de_proteins_list)) {
  strain <- names(de_proteins_list)[i]                                            # Grab the name of the strain
  de_proteins <- de_proteins_list[[strain]]                                       # Grab the proteins that are DE in this strain
  de_synthetases_this_strain <- de_proteins[de_proteins %in% synthetase_names]    # Grab the synthetases that are DE in this strain
  
  # If this strain has DE proteins
  if (length(de_synthetases_this_strain) > 0) {
    for (j in 1:length(synthetase_names)) {                                       # Iterate over the names of the synthetases        
      protein <- synthetase_names[j]                                              # For each of them, add a row to the output df, 
      strains_for_df <- c(strains_for_df, strain)
      synths_for_df <- c(synths_for_df, protein)
      
      if (protein %in% da$protein & strain %in% da$Strain.Name) {
        status_for_df <- c(status_for_df, da$diffexpressed_adjusted[da$protein == protein & da$Strain.Name == strain])
      } else {
        status_for_df <- c(status_for_df, "Not_detected")
      }
    }
  }
  
  # If this strain doesn't have any DE proteins
  else {
    for (j in 1:length(synthetase_names)) {
      protein <- synthetase_names[j]   
      strains_for_df <- c(strains_for_df, strain)
      synths_for_df <- c(synths_for_df, protein)
      if (protein %in% da$protein & strain %in% da$Strain.Name) {
        status_for_df <- c(status_for_df, da$diffexpressed_adjusted[da$protein == protein & da$Strain.Name == strain])
      } else {
        status_for_df <- c(status_for_df, "Not_detected")
      }
    }
  }
}
de_synthetases_df <- data.frame(strains_for_df, synths_for_df, status_for_df)
colnames(de_synthetases_df) <- c("Strain", "Synthetase", "Expression")

# Get a heatmap from this
ggplot(de_synthetases_df, aes(Strain, Synthetase)) +
                      geom_tile(aes(fill = Expression)) +
                      scale_fill_viridis_d() +
                      xlab("") +
                      ylab("") +
                      labs(title = glue("")) +
                      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))


# Remove unnecessary variables - NEED TO UPDATE THIS
rm(de_proteins, temp)
```
--> At alpha = 0.05 and logFC = 0 I think --> All the DE synthetases I observe are in 33 (or something like that) out of the 197 KO strains! That's gotta mean something, I have to check what is special about those strains (maybe they are just the ones with the most DE proteins or something like that, who knows, but still, need to check if there is something special about the amino acid they carry or whatever)

--> At alpha = 0.05 and logFC = 0.5 --> 


## 5.3. Use the information obtained in the previous chunk, of which synthetases are DE in which KO strains, to capture the information from those genes in those strains
```{r}
grab_de_synthetases_dfs <- function(da, de_synthetases, yeastmine) {
  de_synthetases_dfs <- list()
  for (i in 1:length(da)) {
    strain_name <- names(da)[[i]]
    strains_with_de_synths <- names(de_synthetases)
    if (strain_name %in% strains_with_de_synths) {
      temp <- da[[i]]
      rownames(temp) <- match_systematic_and_standard_protein_names(data = rownames(temp),
                                                                       yeastmine = yeastmine,
                                                                       input = "standard",
                                                                       simplify = T) 
      temp <- temp[rownames(temp) %in% de_synthetases[[strain_name]],]
      temp$Synthetase <- rownames(temp)
      temp$Strain.Name <- strain_name
      de_synthetases_dfs[[strain_name]] <- temp
    }
  }
  
  # Turn the resulting list into a single dataframe
  de_synthetases_df <- bind_rows(de_synthetases_dfs)
  rownames(de_synthetases_df) <- NULL
  
  # Add a column with the standard names for the tRNA synthetase genes
  temp <- match_systematic_and_standard_protein_names(data = as.character(de_synthetases_df$Synthetase),
                                                      yeastmine = yeastmine, 
                                                      input = "systematic",
                                                      simplify = T)
  de_synthetases_df$Synthetase_standard <- temp
  de_synthetases_df <- de_synthetases_df %>%
    dplyr::rename(Synthetase_systematic = Synthetase)
  
  return(de_synthetases_df)
}


da <- read_json(path="/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/enrichment_analysis/da_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", simplifyVector = T)

de_synthetases_df <- grab_de_synthetases_dfs(da, de_synthetases, yeastmine)
```

Add 2 columns: one for the amino acid which the KOd tRNA carries, another for the the amino acid that is loaded by the synthetase found to be DE
```{r}
add_2_columns <- function(de_synthetases_df) {
  # Amino acid carried by the KOd tRNA
  temp <- master_dataset %>%
    dplyr::select(Strain.Name, Amino_acid_1_letter, Anticodon, codon, chromosome, Family_size)
  de_synthetases_df <- left_join(de_synthetases_df, temp, by = "Strain.Name") 
  
  temp <- amino_acids %>%
    dplyr::select(Amino_acid_1_letter, amino_acid_charge, amino_acid_type) %>%
    dplyr::rename(AA_charge_tRNA = amino_acid_charge,
           AA_type_tRNA = amino_acid_type)
  de_synthetases_df <- left_join(de_synthetases_df, temp, by = "Amino_acid_1_letter") %>%
    dplyr::rename(AA_carried_by_tRNA = Amino_acid_1_letter)
  
  # Amino acid loaded by the synthetase
  temp <- amino_acids %>%
    dplyr::select(Amino_acid_name, Amino_acid_1_letter, Amino_acid_3_letter, amino_acid_charge, amino_acid_type) %>%
    dplyr::rename(AA_loaded_by_synthetase = Amino_acid_1_letter,
           AA_charge_synth = amino_acid_charge,
           AA_type_synth = amino_acid_type)
  
  temp_2 <- left_join(chu_synths_new, temp, by = "Amino_acid_3_letter") %>%
    dplyr::select(Gene.secondaryIdentifier, AA_charge_synth, AA_type_synth) %>%
    dplyr::rename(Synthetase = Gene.secondaryIdentifier)
  
  temp_3 <- temp_2 %>%
    group_by(Synthetase) %>%
    summarise(text=paste(AA_charge_synth, collapse = ",")) %>%
    dplyr::rename(AA_charge_synth = text,
           Synthetase_systematic = Synthetase)
  
  temp_4 <- temp_2 %>%
    group_by(Synthetase) %>%
    summarise(text=paste(AA_type_synth, collapse = ",")) %>%
    dplyr::rename(AA_type_synth = text,
           Synthetase_systematic = Synthetase)
  
  de_synthetases_df <- left_join(de_synthetases_df, temp_3, by = "Synthetase_systematic")
  de_synthetases_df <- left_join(de_synthetases_df, temp_4, by = "Synthetase_systematic")
  
  temp <- left_join(chu_synths_new, temp, by = "Amino_acid_3_letter") %>%
    dplyr::select(Gene.secondaryIdentifier, AA_loaded_by_synthetase) %>%
    dplyr::rename(Synthetase = Gene.secondaryIdentifier) %>%
    group_by(Synthetase) %>%
    summarise(text=paste(AA_loaded_by_synthetase, collapse = ",")) %>%
    dplyr::rename(AA_loaded_by_synthetase = text,
           Synthetase_systematic = Synthetase)
  de_synthetases_df <- left_join(de_synthetases_df, temp, by = "Synthetase_systematic") 
  
  return(de_synthetases_df)
}

amino_acids <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/databases/GtRNAdb/amino_acids.csv")) 
master_dataset <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/master_tRNA_dataset.csv"))

de_synthetases_df <- add_2_columns(de_synthetases_df)


# Also add a column which counts how many DE synthetases there are in each strain, and also another one with in how many strains each synthetase is DE
de_synthetases_df <- de_synthetases_df %>%
  group_by(Strain.Name) %>%
  mutate(DE_synths_per_strain = n()) %>%
  ungroup() %>%
  group_by(Synthetase_systematic) %>%
  mutate(strains_per_synth = n())

# Add the information from the synthetases dataframe of in how many total samples and in how many WT samples each synthetase is detected
temp <- synthetases %>%
  dplyr::select(Gene.secondaryIdentifier, measured_proteomics_WTs_WT, quantified_in_how_many_WTs, quantified_in_how_many_KO_samples) %>%
  dplyr::rename(Synthetase_systematic = Gene.secondaryIdentifier)
de_synthetases_df<- de_synthetases_df %>%
  left_join(temp, by = "Synthetase_systematic")


# Remove unnecessary variables
rm(chu_synths, chu_synths_new, de_proteins_list, new_row, trna_ko, yeastmine,
   std_name, std_names, i, j, check, detected_proteins, de_synthetases,
   grab_de_synthetases_dfs, da, amino_acids, add_2_columns, synths_detected)
```


## 5.4. Check how many synthetases we have TS alleles for in the Boone library
There are 13 of them, none of them mitochondrial, none of them the ARC1 cofactor, one of them a synthase - 2 of them were sick when sent and did not grow
```{r}
ts_library <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/TSSC/Data/Boone_lab/Growth/Mine/Processed_by_them/growth_agar_matched.tsv"))
ts_library_synths <- ts_library[ts_library$Systematic_name %in% synthetases$Gene.secondaryIdentifier,]
synths_in_ts_library_info <- synthetases[synthetases$Gene.secondaryIdentifier %in% ts_library$Systematic_name,] 
```


## 5.5. There are only 33 strains with DE synthetases - is there anything special about them?
```{r}
unique(de_synthetases_df$AA_carried_by_tRNA)
unique(de_synthetases_df$Anticodon)
unique(de_synthetases_df$chromosome)

length(unique(de_synthetases_df$AA_carried_by_tRNA))
length(unique(de_synthetases_df$Anticodon))
length(unique(de_synthetases_df$chromosome))
```

```{r}
sort(table(de_synthetases_df$AA_loaded_by_synthetase))

# Rank the 33 KO strains based on AA_type_synth
sort(table(de_synthetases_df$AA_type_synth))

# Rank the 33 KO strains based on how many DE synthetases there are in each of them

```

More plots
```{r}
# Boxplots for the number of DE synthetases per amino acid carried
ggplot(data = de_synthetases_df, aes(x = AA_carried_by_tRNA, y = DE_synths_per_strain)) +
  geom_boxplot(col = "black") +
  theme_light() +
  labs(title = "Number of DE synthetases by the amino acid carried by the KOd tRNA") +
  xlab("Amino acid carried by the tRNA") +
  ylab("Count of DE synthetases")

# Scatter plot for the number of strains in which each synthetase is DE
ggplot(data = de_synthetases_df, aes(x = Synthetase_standard, y = strains_per_synth, col = AA_loaded_by_synthetase)) +
  geom_point(size = 3) +
  theme_light() +
  labs(title = "Number of strains in which each synthetase is DE",
       col = "AA loaded by synthetase") +
  xlab("Synthetase") +
  ylab("Strain count") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  guides(col=guide_legend(ncol=2))

# Scatter plot: number of strains in which each synthetase is DE vs. number of samples in which that synthetase is detected
ggplot(data = de_synthetases_df, aes(x = Synthetase_standard, y = strains_per_synth, col = AA_loaded_by_synthetase)) +
  geom_point(size = 3) +
  theme_light() +
  labs(title = "Number of strains in which each synthetase is DE",
       col = "AA loaded by synthetase") +
  xlab("Synthetase") +
  ylab("Strain count") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  guides(col=guide_legend(ncol=2))
```


## 5.6. Save the dataframes with the information on the DE synthetases and remove everything
```{r}
# Save them
fwrite(de_synthetases_df_001, "/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/synthetases/de_synthetases_df_001.tsv")
fwrite(de_synthetases_df_005, "/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/synthetases/de_synthetases_df_005.tsv")

# Remove everything
rm(de_synthetases_df_001, de_synthetases_df_005, ts_library, synths_in_ts_library_info, ts_library_synths, synthetases, WTs, master_dataset, synth, measured_proteins)
```







######################################################################################
# 6. Check if different KOs with the same Anticodon cause the same proteins to be DE
######################################################################################
## 6.0. Load data
```{r}
# List of dataframes with the proteins that were DE in each KO strain
de_proteins_list <- fromJSON("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/enrichment_analysis/de_proteins_list_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json")

## Remove WT dataframe
de_proteins_list <- de_proteins_list[names(de_proteins_list) != "WT"]

# Load responsiveness dataset
responsiveness <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/produced_during_analysis/responsiveness_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv"))

# Master dataset
master_dataset <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/master_tRNA_dataset.csv"))
```




## 6.1. Jaccard index heatmaps - KOs with no DEPs are ignored here, not included in the plots!
Heatmaps by Anticodon - without NAs
```{r}
# Preparations: remove KOs with 0 DE proteins from list, grab Anticodon names, create empty list to put Jaccard index matrices there
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list)
Anticodons <- unique(responsiveness$Anticodon)
jaccard_matrices_list <- list()

# Iterate over the Anticodons and get a Jaccard index matrix for each of them
for (i in 1:length(Anticodons)) {
  # For each Anticodon, grab the tRNAs that contain it, and get a matrix with the Jaccard index across them
  Anticodon <- Anticodons[i]
  KOs_with_Anticodon <- names(de_protein_list)[grepl(Anticodon, names(de_protein_list))]
  
  # This is so I don't end up with matrices with a single cell
  if (length(KOs_with_Anticodon) > 1) {
    jaccard_matrix <- get_jaccad_index_matrix(de_protein_list, KOs_with_Anticodon)
    jaccard_matrices_list[[Anticodon]] <- jaccard_matrix
  }
}

# Iterate over the Jaccard index matrices and get a heatmap from each of them
plot_list <- list()
for (i in 1:length(jaccard_matrices_list)) {
  Anticodon <- names(jaccard_matrices_list)[i]
  mat <- jaccard_matrices_list[[i]]
  melt_mat <- melt(mat)
  plot_list[[i]] <- ggplot(melt_mat, aes(Var1, Var2)) +
                      geom_tile(aes(fill = value), colour = "white") +
                      scale_fill_gradient(low = "white", high = "red") +
                      xlab("") +
                      ylab("") +
                      labs(title = glue("{Anticodon}")) +
                      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
}


## Print to PDF
my_grobs <- lapply(plot_list, ggplotGrob)
output_file <- "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/compare_DEPs_across_KOs/jaccard/Jaccard_index_heatmaps_per_Anticodon_no_NAs_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf"
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=3, ncol=3), 
   width = 15, height = 9
)


# Remove unnecessary variables
rm(Anticodons, jaccard_matrices_list, Anticodon, KOs_with_Anticodon, jaccard_matrix, plot_list, my_grobs, output_file, melt_mat, mat, i)
```

Heatmaps by amino acid - without NAs
```{r}
# Preparations: remove KOs with 0 DE proteins from list, grab Anticodon names, create empty list to put Jaccard index matrices there
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list)
amino_acids <- unique(responsiveness$Amino_acid_1_letter)
jaccard_matrices_list <- list()

# Iterate over the amino acids and get a Jaccard index matrix for each of them
for (i in 1:length(amino_acids)) {
  # For each amino acid, grab the tRNAs that carry it, and get a matrix with the Jaccard index across them
  aa <- amino_acids[i]
  strain_names <- unique(responsiveness$Strain.Name[responsiveness$Amino_acid_1_letter == aa])
  KOs_with_amino_acid <- names(de_protein_list)[names(de_protein_list) %in% strain_names]
  
  # This is so I don't end up with matrices with a single cell
  if (length(KOs_with_amino_acid) > 1) {
    jaccard_matrix <- get_jaccad_index_matrix(de_protein_list, KOs_with_amino_acid)
    jaccard_matrices_list[[aa]] <- jaccard_matrix
  }
}

# Iterate over the Jaccard index matrices and get a heatmap from each of them
plot_list <- list()
for (i in 1:length(jaccard_matrices_list)) {
  aa <- names(jaccard_matrices_list)[i]
  mat <- jaccard_matrices_list[[i]]
  melt_mat <- melt(mat)
  plot_list[[i]] <- ggplot(melt_mat, aes(Var1, Var2)) +
                      geom_tile(aes(fill = value), colour = "white") +
                      scale_fill_gradient(low = "white", high = "red") +
                      xlab("") +
                      ylab("") +
                      labs(title = glue("{aa}")) +
                      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
}

my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file <- "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/compare_DEPs_across_KOs/jaccard/Jaccard_index_heatmaps_per_amino_acid_no_NAs_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf"
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=2, ncol=3), 
   width = 15, height = 9
)


# Remove unnecessary variables
rm(jaccard_matrices_list, jaccard_matrix, plot_list, my_grobs, output_file, mat, melt_mat, aa, amino_acids, i, KOs_with_amino_acid, strain_names)
```

Heatmaps by Anticodon - with NAs
```{r}
# Preparations: remove KOs with 0 DE proteins from list, grab Anticodon names, create empty list to put Jaccard index matrices there
Anticodons <- unique(responsiveness$Anticodon)
jaccard_matrices_list <- list()

# Iterate over the Anticodons and get a Jaccard index matrix for each of them
for (i in 1:length(Anticodons)) {
  # For each Anticodon, grab the tRNAs that contain it, and get a matrix with the Jaccard index across them
  Anticodon <- Anticodons[i]
  KOs_with_Anticodon <- names(de_protein_list)[grepl(Anticodon, names(de_protein_list))]
  
  # This is so I don't end up with matrices with a single cell
  if (length(KOs_with_Anticodon) > 1) {
    jaccard_matrix <- get_jaccad_index_matrix(de_protein_list, KOs_with_Anticodon)
    jaccard_matrices_list[[Anticodon]] <- jaccard_matrix
  }
}

# Iterate over the Jaccard index matrices and get a heatmap from each of them
plot_list <- list()
for (i in 1:length(jaccard_matrices_list)) {
  Anticodon <- names(jaccard_matrices_list)[i]
  mat <- jaccard_matrices_list[[i]]
  melt_mat <- melt(mat)
  plot_list[[i]] <- ggplot(melt_mat, aes(Var1, Var2)) +
                      geom_tile(aes(fill = value), colour = "white") +
                      scale_fill_gradient(low = "white", high = "red") +
                      xlab("") +
                      ylab("") +
                      labs(title = glue("{Anticodon}")) +
                      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
}

my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file <- "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/compare_DEPs_across_KOs/jaccard/Jaccard_index_heatmaps_per_Anticodon_with_NAs_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf"
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=3, ncol=3), 
   width = 15, height = 9
)


# Remove unnecessary variables
rm(Anticodons, jaccard_matrices_list, Anticodon, KOs_with_Anticodon, jaccard_matrix, plot_list, my_grobs, output_file, mat, melt_mat, i)
```

Heatmaps by amino acid - with NAs
```{r}
# Preparations: remove KOs with 0 DE proteins from list, grab Anticodon names, create empty list to put Jaccard index matrices there
amino_acids <- unique(responsiveness$Amino_acid_1_letter)
jaccard_matrices_list <- list()

# Iterate over the amino acids and get a Jaccard index matrix for each of them
for (i in 1:length(amino_acids)) {
  # For each amino acid, grab the tRNAs that carry it, and get a matrix with the Jaccard index across them
  aa <- amino_acids[i]
  strain_names <- unique(responsiveness$Strain.Name[responsiveness$Amino_acid_1_letter == aa])
  KOs_with_amino_acid <- names(de_protein_list)[names(de_protein_list) %in% strain_names]
  
  # This is so I don't end up with matrices with a single cell
  if (length(KOs_with_amino_acid) > 1) {
    jaccard_matrix <- get_jaccad_index_matrix(de_protein_list, KOs_with_amino_acid)
    jaccard_matrices_list[[aa]] <- jaccard_matrix
  }
}

# Iterate over the Jaccard index matrices and get a heatmap from each of them
plot_list <- list()
for (i in 1:length(jaccard_matrices_list)) {
  aa <- names(jaccard_matrices_list)[i]
  mat <- jaccard_matrices_list[[i]]
  melt_mat <- melt(mat)
  plot_list[[i]] <- ggplot(melt_mat, aes(Var1, Var2)) +
                      geom_tile(aes(fill = value), colour = "white") +
                      scale_fill_gradient(low = "white", high = "red") +
                      xlab("") +
                      ylab("") +
                      labs(title = glue("{aa}")) +
                      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
}

my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file <- "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/compare_DEPs_across_KOs/jaccard/Jaccard_index_heatmaps_per_amino_acid_with_NAs_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf"
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=2, ncol=3), 
   width = 15, height = 9
)


# Remove unnecessary variables
rm(KOs_with_Anticodon, jaccard_matrix, jaccard_matrices_list, plot_list, my_grobs, output_file, mat, melt_mat, i, aa, amino_acids, KOs_with_amino_acid, strain_names)
```






## 6.3. Intersections between all KOs, collecting all possible information in the columns 
### 6.3.1. Create dataframe
Create dataframe - only basic columns that are obtained through iteration
```{r}
# Prepare for iterations, create empty vectors to which I will save the information (and from which I'll create a dataframe afterwards)
observed_pairs <- c()
strains <- names(de_proteins_list)
strains_1 <- c()
strains_2 <- c()
protein_number_1 <- c()
protein_number_2 <- c()
protein_names_1 <- c()
protein_names_2 <- c()
overlap <- c()
overlap_size <- c()


# First iteration through the strains
for (i in 1:length(strains)) {
  strain_1 <- strains[i]
  proteins_strain_1 <- de_proteins_list[[strain_1]]
  
  # Second iteration through the strains
  for (j in 1:length(strains)) {
    strain_2 <- strains[j]
    proteins_strain_2 <- de_proteins_list[[strain_2]]
    
    # Make sure we are not comparing a strain to itself
    condition_1 = strain_1 != strain_2
    
    # Also make sure that we haven't added this pair of strains before already
    strain_pair <- paste(sort(c(strain_1, strain_2)), collapse = ",")
    condition_2 = !(strain_pair %in% observed_pairs)
    
    # If both these conditions are covered, analyze the pair of strains and add their characteristics to the output vectors
    if (condition_1 & condition_2) {
      strains_1 <- c(strains_1, strain_1)
      strains_2 <- c(strains_2, strain_2)
      protein_number_1 <- c(protein_number_1, length(proteins_strain_1))
      protein_number_2 <- c(protein_number_2, length(proteins_strain_2))
      protein_names_1 <- c(protein_names_1, paste(proteins_strain_1, collapse = ","))
      protein_names_2 <- c(protein_names_2, paste(proteins_strain_2, collapse = ","))
      overlap <- c(overlap, paste(intersect(proteins_strain_1, proteins_strain_2), collapse = ","))
      overlap_size <- c(overlap_size, length(intersect(proteins_strain_1, proteins_strain_2)))
      
      observed_pairs <- c(observed_pairs, paste(sort(c(strain_1, strain_2)), collapse = ","))
    }
  }
}

DE_protein_overlaps <- data.frame(strains_1, strains_2, protein_number_1, protein_number_2, overlap_size, protein_names_1, protein_names_2, overlap)
```

Add all other columns (calculations or matching to master or responsiveness datasets) - I am not using all variables from these dataset, only the most basic ones for now - I'll explore those and then I can always come back and add more
```{r}
DE_protein_overlaps <- DE_protein_overlaps %>%
  rowwise() %>%
  mutate(protein_number_avg = mean(c(protein_number_1, protein_number_2)),
         Gene_type_1 = unique(responsiveness$Gene_type[responsiveness$Strain.Name == strains_1])[1],
         Gene_type_2 = unique(responsiveness$Gene_type[responsiveness$Strain.Name == strains_2])[1]) %>%
  ungroup() %>%
  mutate(overlap_over_strain_1 = overlap_size/protein_number_1,
         overlap_over_strain_2 = overlap_size/protein_number_2,
         overlap_over_union = overlap_size/(protein_number_1+protein_number_2),
         overlap_over_log_union = overlap_size/log2(protein_number_1+protein_number_2),
         Jaccard_index = overlap_size/(protein_number_1+protein_number_2-overlap_size))

# Match to strain_1
DE_protein_overlaps <- DE_protein_overlaps %>%
  dplyr::rename(Strain.Name = strains_1)
temp <- responsiveness %>%
  dplyr::select(Strain.Name, Anticodon, Amino_acid_1_letter, chromosome_letter, amino_acid_type, amino_acid_charge)

DE_protein_overlaps <- left_join(DE_protein_overlaps, temp, by = "Strain.Name") %>%
  dplyr::rename(Anticodon_1 = Anticodon,
         Amino_acid_1 = Amino_acid_1_letter,
         chr_1 = chromosome_letter,
         aa_type_1 = amino_acid_type,
         aa_charge_1 = amino_acid_charge)

## Repeat this for the columns only in master_dataset (U_34 and A_34)
temp <- master_dataset %>%
  dplyr::select(Strain.Name, contains("Nt_at"))
DE_protein_overlaps <- left_join(DE_protein_overlaps, temp, by = "Strain.Name") %>%
  dplyr::rename(strains_1 = Strain.Name,
         Nt_at_1_1 = Nt_at_1,
         Nt_at_2_1 = Nt_at_2,
         Nt_at_3_1 = Nt_at_3,
         Nt_at_4_1 = Nt_at_4,
         Nt_at_5_1 = Nt_at_5,
         Nt_at_6_1 = Nt_at_6,
         Nt_at_7_1 = Nt_at_7,
         Nt_at_8_1 = Nt_at_8,
         Nt_at_9_1 = Nt_at_9,
         Nt_at_10_1 = Nt_at_10,
         Nt_at_11_1 = Nt_at_11,
         Nt_at_12_1 = Nt_at_12,
         Nt_at_13_1 = Nt_at_13,
         Nt_at_14_1 = Nt_at_14,
         Nt_at_15_1 = Nt_at_15,
         Nt_at_16_1 = Nt_at_16,
         Nt_at_17_1 = Nt_at_17,
         Nt_at_18_1 = Nt_at_18,
         Nt_at_19_1 = Nt_at_19,
         Nt_at_20_1 = Nt_at_20,
         Nt_at_21_1 = Nt_at_21,
         Nt_at_22_1 = Nt_at_22,
         Nt_at_23_1 = Nt_at_23,
         Nt_at_24_1 = Nt_at_24,
         Nt_at_25_1 = Nt_at_25,
         Nt_at_26_1 = Nt_at_26,
         Nt_at_27_1 = Nt_at_27,
         Nt_at_28_1 = Nt_at_28,
         Nt_at_29_1 = Nt_at_29,
         Nt_at_30_1 = Nt_at_30,
         Nt_at_31_1 = Nt_at_31,
         Nt_at_32_1 = Nt_at_32,
         Nt_at_33_1 = Nt_at_33,
         Nt_at_34_1 = Nt_at_34,
         Nt_at_35_1 = Nt_at_35,
         Nt_at_36_1 = Nt_at_36,
         Nt_at_37_1 = Nt_at_37,
         Nt_at_38_1 = Nt_at_38,
         Nt_at_39_1 = Nt_at_39,
         Nt_at_40_1 = Nt_at_40,
         Nt_at_41_1 = Nt_at_41,
         Nt_at_42_1 = Nt_at_42,
         Nt_at_43_1 = Nt_at_43,
         Nt_at_44_1 = Nt_at_44,
         Nt_at_45_1 = Nt_at_45,
         Nt_at_46_1 = Nt_at_46,
         Nt_at_47_1 = Nt_at_47,
         Nt_at_48_1 = Nt_at_48,
         Nt_at_49_1 = Nt_at_49,
         Nt_at_50_1 = Nt_at_50,
         Nt_at_51_1 = Nt_at_51,
         Nt_at_52_1 = Nt_at_52,
         Nt_at_53_1 = Nt_at_53,
         Nt_at_54_1 = Nt_at_54,
         Nt_at_55_1 = Nt_at_55,
         Nt_at_56_1 = Nt_at_56,
         Nt_at_57_1 = Nt_at_57,
         Nt_at_58_1 = Nt_at_58,
         Nt_at_59_1 = Nt_at_59,
         Nt_at_60_1 = Nt_at_60,
         Nt_at_61_1 = Nt_at_61,
         Nt_at_62_1 = Nt_at_62,
         Nt_at_63_1 = Nt_at_63,
         Nt_at_64_1 = Nt_at_64,
         Nt_at_65_1 = Nt_at_65,
         Nt_at_66_1 = Nt_at_66,
         Nt_at_67_1 = Nt_at_67,
         Nt_at_68_1 = Nt_at_68,
         Nt_at_69_1 = Nt_at_69,
         Nt_at_70_1 = Nt_at_70,
         Strain.Name = strains_2)


# Match to strain_2
temp <- responsiveness %>%
  dplyr::select(Strain.Name, Anticodon, Amino_acid_1_letter, chromosome_letter, amino_acid_type, amino_acid_charge)
DE_protein_overlaps <- left_join(DE_protein_overlaps, temp, by = "Strain.Name") %>%
  dplyr::rename(Anticodon_2 = Anticodon,
         Amino_acid_2 = Amino_acid_1_letter,
         aa_type_2 = amino_acid_type,
         aa_charge_2 = amino_acid_charge,
         chr_2 = chromosome_letter)

## Repeat this for the columns only in master_dataset (U_34 and A_34)
temp <- master_dataset %>%
  dplyr::select(Strain.Name, contains("Nt_at"))
DE_protein_overlaps <- left_join(DE_protein_overlaps, temp, by = "Strain.Name") %>%
  dplyr::rename(strains_2 = Strain.Name,
         Nt_at_1_2 = Nt_at_1,
         Nt_at_2_2 = Nt_at_2,
         Nt_at_3_2 = Nt_at_3,
         Nt_at_4_2 = Nt_at_4,
         Nt_at_5_2 = Nt_at_5,
         Nt_at_6_2 = Nt_at_6,
         Nt_at_7_2 = Nt_at_7,
         Nt_at_8_2 = Nt_at_8,
         Nt_at_9_2 = Nt_at_9,
         Nt_at_10_2 = Nt_at_10,
         Nt_at_11_2 = Nt_at_11,
         Nt_at_12_2 = Nt_at_12,
         Nt_at_13_2 = Nt_at_13,
         Nt_at_14_2 = Nt_at_14,
         Nt_at_15_2 = Nt_at_15,
         Nt_at_16_2 = Nt_at_16,
         Nt_at_17_2 = Nt_at_17,
         Nt_at_18_2 = Nt_at_18,
         Nt_at_19_2 = Nt_at_19,
         Nt_at_20_2 = Nt_at_20,
         Nt_at_21_2 = Nt_at_21,
         Nt_at_22_2 = Nt_at_22,
         Nt_at_23_2 = Nt_at_23,
         Nt_at_24_2 = Nt_at_24,
         Nt_at_25_2 = Nt_at_25,
         Nt_at_26_2 = Nt_at_26,
         Nt_at_27_2 = Nt_at_27,
         Nt_at_28_2 = Nt_at_28,
         Nt_at_29_2 = Nt_at_29,
         Nt_at_30_2 = Nt_at_30,
         Nt_at_31_2 = Nt_at_31,
         Nt_at_32_2 = Nt_at_32,
         Nt_at_33_2 = Nt_at_33,
         Nt_at_34_2 = Nt_at_34,
         Nt_at_35_2 = Nt_at_35,
         Nt_at_36_2 = Nt_at_36,
         Nt_at_37_2 = Nt_at_37,
         Nt_at_38_2 = Nt_at_38,
         Nt_at_39_2 = Nt_at_39,
         Nt_at_40_2 = Nt_at_40,
         Nt_at_41_2 = Nt_at_41,
         Nt_at_42_2 = Nt_at_42,
         Nt_at_43_2 = Nt_at_43,
         Nt_at_44_2 = Nt_at_44,
         Nt_at_45_2 = Nt_at_45,
         Nt_at_46_2 = Nt_at_46,
         Nt_at_47_2 = Nt_at_47,
         Nt_at_48_2 = Nt_at_48,
         Nt_at_49_2 = Nt_at_49,
         Nt_at_50_2 = Nt_at_50,
         Nt_at_51_2 = Nt_at_51,
         Nt_at_52_2 = Nt_at_52,
         Nt_at_53_2 = Nt_at_53,
         Nt_at_54_2 = Nt_at_54,
         Nt_at_55_2 = Nt_at_55,
         Nt_at_56_2 = Nt_at_56,
         Nt_at_57_2 = Nt_at_57,
         Nt_at_58_2 = Nt_at_58,
         Nt_at_59_2 = Nt_at_59,
         Nt_at_60_2 = Nt_at_60,
         Nt_at_61_2 = Nt_at_61,
         Nt_at_62_2 = Nt_at_62,
         Nt_at_63_2 = Nt_at_63,
         Nt_at_64_2 = Nt_at_64,
         Nt_at_65_2 = Nt_at_65,
         Nt_at_66_2 = Nt_at_66,
         Nt_at_67_2 = Nt_at_67,
         Nt_at_68_2 = Nt_at_68,
         Nt_at_69_2 = Nt_at_69,
         Nt_at_70_2 = Nt_at_70)

# Come up with columns that require matching between these 2 sets of them
DE_protein_overlaps <- DE_protein_overlaps %>%
  mutate(same_family = Anticodon_1 == Anticodon_2,
         same_amino_acid = Amino_acid_1 == Amino_acid_2,
         same_chromosome = chr_1 == chr_2,
         same_family_and_chr = same_family&same_chromosome,
         same_amino_acid_and_chr = same_amino_acid&same_chromosome,
         same_aa_type = aa_type_1 == aa_type_2,
         same_aa_charge = aa_charge_1 == aa_charge_2,
         Nt_at_1 = Nt_at_1_1 == Nt_at_1_2,
         Nt_at_2 = Nt_at_2_1 == Nt_at_2_2,
         Nt_at_3 = Nt_at_3_1 == Nt_at_3_2,
         Nt_at_4 = Nt_at_4_1 == Nt_at_4_2,
         Nt_at_5 = Nt_at_5_1 == Nt_at_5_2,
         Nt_at_6 = Nt_at_6_1 == Nt_at_6_2,
         Nt_at_7 = Nt_at_7_1 == Nt_at_7_2,
         Nt_at_8 = Nt_at_8_1 == Nt_at_8_2,
         Nt_at_9 = Nt_at_9_1 == Nt_at_9_2,
         Nt_at_10 = Nt_at_10_1 == Nt_at_10_2,
         Nt_at_11 = Nt_at_11_1 == Nt_at_11_2,
         Nt_at_12 = Nt_at_12_1 == Nt_at_12_2,
         Nt_at_13 = Nt_at_13_1 == Nt_at_13_2,
         Nt_at_14 = Nt_at_14_1 == Nt_at_14_2,
         Nt_at_15 = Nt_at_15_1 == Nt_at_15_2,
         Nt_at_16 = Nt_at_16_1 == Nt_at_16_2,
         Nt_at_17 = Nt_at_17_1 == Nt_at_17_2,
         Nt_at_18 = Nt_at_18_1 == Nt_at_18_2,
         Nt_at_19 = Nt_at_19_1 == Nt_at_19_2,
         Nt_at_20 = Nt_at_20_1 == Nt_at_30_2,
         Nt_at_21 = Nt_at_21_1 == Nt_at_21_2,
         Nt_at_22 = Nt_at_22_1 == Nt_at_22_2,
         Nt_at_23 = Nt_at_23_1 == Nt_at_23_2,
         Nt_at_24 = Nt_at_24_1 == Nt_at_24_2,
         Nt_at_25 = Nt_at_25_1 == Nt_at_25_2,
         Nt_at_26 = Nt_at_26_1 == Nt_at_26_2,
         Nt_at_27 = Nt_at_27_1 == Nt_at_27_2,
         Nt_at_28 = Nt_at_28_1 == Nt_at_28_2,
         Nt_at_29 = Nt_at_29_1 == Nt_at_29_2,
         Nt_at_30 = Nt_at_30_1 == Nt_at_30_2,
         Nt_at_31 = Nt_at_31_1 == Nt_at_31_2,
         Nt_at_32 = Nt_at_32_1 == Nt_at_32_2,
         Nt_at_33 = Nt_at_33_1 == Nt_at_33_2,
         Nt_at_34 = Nt_at_34_1 == Nt_at_34_2,
         Nt_at_35 = Nt_at_35_1 == Nt_at_35_2,
         Nt_at_36 = Nt_at_36_1 == Nt_at_36_2,
         Nt_at_37 = Nt_at_37_1 == Nt_at_37_2,
         Nt_at_38 = Nt_at_38_1 == Nt_at_38_2,
         Nt_at_39 = Nt_at_39_1 == Nt_at_39_2,
         Nt_at_40 = Nt_at_40_1 == Nt_at_40_2,
         Nt_at_41 = Nt_at_41_1 == Nt_at_41_2,
         Nt_at_42 = Nt_at_42_1 == Nt_at_42_2,
         Nt_at_43 = Nt_at_43_1 == Nt_at_43_2,
         Nt_at_44 = Nt_at_44_1 == Nt_at_44_2,
         Nt_at_45 = Nt_at_45_1 == Nt_at_45_2,
         Nt_at_46 = Nt_at_46_1 == Nt_at_46_2,
         Nt_at_47 = Nt_at_47_1 == Nt_at_47_2,
         Nt_at_48 = Nt_at_48_1 == Nt_at_48_2,
         Nt_at_49 = Nt_at_49_1 == Nt_at_49_2,
         Nt_at_50 = Nt_at_50_1 == Nt_at_50_2,
         Nt_at_51 = Nt_at_51_1 == Nt_at_51_2,
         Nt_at_52 = Nt_at_52_1 == Nt_at_52_2,
         Nt_at_53 = Nt_at_53_1 == Nt_at_53_2,
         Nt_at_54 = Nt_at_54_1 == Nt_at_54_2,
         Nt_at_55 = Nt_at_55_1 == Nt_at_55_2,
         Nt_at_56 = Nt_at_56_1 == Nt_at_56_2,
         Nt_at_57 = Nt_at_57_1 == Nt_at_57_2,
         Nt_at_58 = Nt_at_58_1 == Nt_at_58_2,
         Nt_at_59 = Nt_at_59_1 == Nt_at_59_2,
         Nt_at_60 = Nt_at_60_1 == Nt_at_60_2,
         Nt_at_61 = Nt_at_61_1 == Nt_at_61_2,
         Nt_at_62 = Nt_at_62_1 == Nt_at_62_2,
         Nt_at_63 = Nt_at_63_1 == Nt_at_63_2,
         Nt_at_64 = Nt_at_64_1 == Nt_at_64_2,
         Nt_at_65 = Nt_at_65_1 == Nt_at_65_2,
         Nt_at_66 = Nt_at_66_1 == Nt_at_66_2,
         Nt_at_67 = Nt_at_67_1 == Nt_at_67_2,
         Nt_at_68 = Nt_at_68_1 == Nt_at_68_2,
         Nt_at_69 = Nt_at_69_1 == Nt_at_69_2,
         Nt_at_70 = Nt_at_70_1 == Nt_at_70_2) %>%
  dplyr::select(-c(Nt_at_1_1, Nt_at_1_2, Nt_at_2_1, Nt_at_2_2, Nt_at_3_1, Nt_at_3_2, Nt_at_4_1, Nt_at_4_2, Nt_at_5_1, Nt_at_5_2, Nt_at_6_1, Nt_at_6_2, Nt_at_7_1, Nt_at_7_2, Nt_at_8_1, Nt_at_8_2, Nt_at_9_1, Nt_at_9_2, Nt_at_10_1, Nt_at_10_2, Nt_at_11_1, Nt_at_11_2, Nt_at_12_1, Nt_at_12_2, Nt_at_13_1, Nt_at_13_2, Nt_at_14_1, Nt_at_14_2, Nt_at_15_1, Nt_at_15_2, Nt_at_16_1, Nt_at_16_2, Nt_at_17_1, Nt_at_17_2, Nt_at_18_1, Nt_at_18_2, Nt_at_19_1, Nt_at_19_2, Nt_at_20_1, Nt_at_20_2, Nt_at_21_1, Nt_at_21_2, Nt_at_22_1, Nt_at_22_2, Nt_at_23_1, Nt_at_23_2, Nt_at_24_1, Nt_at_24_2, Nt_at_25_1, Nt_at_25_2, Nt_at_26_1, Nt_at_26_2, Nt_at_27_1, Nt_at_27_2, Nt_at_28_1, Nt_at_28_2, Nt_at_29_1, Nt_at_29_2, Nt_at_30_1, Nt_at_30_2, Nt_at_31_1, Nt_at_31_2, Nt_at_32_1, Nt_at_32_2, Nt_at_33_1, Nt_at_33_2, Nt_at_34_1, Nt_at_34_2, Nt_at_35_1, Nt_at_35_2, Nt_at_36_1, Nt_at_36_2, Nt_at_37_1, Nt_at_37_2, Nt_at_38_1, Nt_at_38_2, Nt_at_39_1, Nt_at_39_2, Nt_at_40_1, Nt_at_40_2, Nt_at_41_1, Nt_at_41_2, Nt_at_42_1, Nt_at_42_2, Nt_at_43_1, Nt_at_43_2, Nt_at_44_1, Nt_at_44_2, Nt_at_45_1, Nt_at_45_2, Nt_at_46_1, Nt_at_46_2, Nt_at_47_1, Nt_at_47_2, Nt_at_48_1, Nt_at_48_2, Nt_at_49_1, Nt_at_49_2, Nt_at_50_1, Nt_at_50_2, Nt_at_51_1, Nt_at_51_2, Nt_at_52_1, Nt_at_52_2, Nt_at_53_1, Nt_at_53_2, Nt_at_54_1, Nt_at_54_2, Nt_at_55_1, Nt_at_55_2, Nt_at_56_1, Nt_at_56_2, Nt_at_57_1, Nt_at_57_2, Nt_at_58_1, Nt_at_58_2, Nt_at_59_1, Nt_at_59_2, Nt_at_60_1, Nt_at_60_2, Nt_at_61_1, Nt_at_61_2, Nt_at_62_1, Nt_at_62_2, Nt_at_63_1, Nt_at_63_2, Nt_at_64_1, Nt_at_64_2, Nt_at_65_1, Nt_at_65_2, Nt_at_66_1, Nt_at_66_2, Nt_at_67_1, Nt_at_67_2, Nt_at_68_1, Nt_at_68_2, Nt_at_69_1, Nt_at_69_2, Nt_at_70_1, Nt_at_70_2))

# Get columns based on strain_1 and strain_2, but which reorganize this: the one with more DEPs to one column, the one with less DEPs to the other
# Just so that I can check the overlap_size/amount of DEPs in the KO strain with less out of the pair. Not sure if too important but oh well
DE_protein_overlaps <- DE_protein_overlaps %>%
  rowwise() %>%
  mutate(Strain_more_DEPs = max(protein_number_1, protein_number_2),
         Strain_less_DEPs = min(protein_number_1, protein_number_2),
         Ratio_more_to_less_DEPs = Strain_more_DEPs/Strain_less_DEPs)

# Add columns where I combine the strings for the Anticodons and amino acids for the 2 strains (always using sort() before so that they are unique)
DE_protein_overlaps <- DE_protein_overlaps %>%
  rowwise() %>%
  mutate(both_Anticodons = paste(sort(c(Anticodon_1, Anticodon_2)), collapse = "-"),
         both_amino_acids = paste(sort(c(Amino_acid_1, Amino_acid_2)), collapse = "-"),
         both_aa_types = paste(sort(c(aa_type_1, aa_type_2)), collapse = "-"),
         both_aa_charges = paste(sort(c(aa_charge_1, aa_charge_2)), collapse = "-"))

# Put columns with protein names as the last ones
DE_protein_overlaps <- DE_protein_overlaps %>%
  relocate(protein_names_1, .after = last_col()) %>%
  relocate(protein_names_2, .after = last_col()) %>%
  relocate(overlap, .after = last_col())
```

Save this dataset as of now 
```{r}
fwrite(DE_protein_overlaps, "/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/compare_DEPs_across_KOs/DE_protein_overlaps_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".tsv")
```



### 6.3.3. Explore large intersections
There are only 42 such pairs out of 19,306 combinations - at alpha = 0.01, idk over which Jaccard Index
At alpha = 0.05 and JI >= 0.5, there are 29???
```{r}
# Subset the dataframe
high_jaccard_df <- DE_protein_overlaps %>%
  filter(Jaccard_index >= 0.5) %>%
  mutate(same_family = case_when(same_family == T ~ "Yes",
                                 TRUE ~ "No"),
         same_amino_acid = case_when(same_amino_acid == T ~ "Yes",
                                 TRUE ~ "No"))

# Look at the strains in this subset of the data
sort(table(high_jaccard_df$strains_1))
sort(table(high_jaccard_df$strains_2))

# Look at the Anticodons and amino acids in this subset of the data
sort(table(high_jaccard_df$both_Anticodons))
sort(table(high_jaccard_df$both_amino_acids))

# Look at the amino acid types and charges in this subset of the data
sort(table(high_jaccard_df$both_aa_types))
sort(table(high_jaccard_df$both_aa_charges))
```

Plot
```{r}
# Barplot of these strains by amino acid types
ggplot(data = high_jaccard_df, aes(x = fct_rev(fct_infreq(both_aa_types)))) +
  geom_bar() +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  labs(title = "Distribution of the KO strain pairs with a Jaccard Index > 0.5",
       subtitle = "Classified based on amino acid types of the 2 KOs") +
  xlab("Amino acid types") +
  ylab("Count")

# Barplot of these strains by amino acid charges
ggplot(data = high_jaccard_df, aes(x = fct_rev(fct_infreq(both_aa_charges)))) +
  geom_bar() +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  labs(title = "Distribution of the KO strain pairs with a Jaccard Index > 0.5",
       subtitle = "Classified based on amino acid charges of the 2 KOs") +
  xlab("Amino acid charges") +
  ylab("Count")

# Barplot of these strains by whether they have the same Anticodon
ggplot(data = high_jaccard_df, aes(x = fct_rev(fct_infreq(same_family)))) +
  geom_bar() +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  labs(title = "Distribution of the KO strain pairs with a Jaccard Index > 0.5",
       subtitle = "Classified based on whether the 2 KOs were for the same Anticodon") +
  xlab("Same family?") +
  ylab("Count")

# Barplot of these strains by whether they carry the same amino acid
ggplot(data = high_jaccard_df, aes(x = fct_rev(fct_infreq(same_amino_acid)))) +
  geom_bar() +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  labs(title = "Distribution of the KO strain pairs with a Jaccard Index > 0.5",
       subtitle = "Classified based on whether the 2 KOs were for tRNAs carrying the same amino acid") +
  xlab("Same amino acid?") +
  ylab("Count")
```

Go into the top pairs with the largest JIs and look at what are the proteins in them - does it have a biological meaning or is it just random stuff/survival stuff/whatever?
```{r}
# Since I want to do enrichment analysis below, I need to load some stuff beforehand - based on the enrichment analysis file
## List of dataframes with the proteins that were DE in each KO strain - at alpha = 0.01 - remove emtpy vectors
de_proteins_list <- fromJSON("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/enrichment_analysis/de_proteins_list_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json")
de_proteins_list <- Filter(function(x) length(x) > 0, de_proteins_list)

# Full Entrez ID dataframe, with all genes
entrez_db <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/enrichment_analysis/entrez_reference.txt"))

## Define background
temp <- data.frame("Protein_stable_ID" = de_proteins_list[["WT"]])
temp <- left_join(temp, entrez_db, by = "Protein_stable_ID")
my_universe <- temp$`NCBI_gene_(formerly_Entrezgene)_ID`

# Load YeastMine dataset
yeastmine <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/databases/alliancemine_results_2024-11-20T11-19-04.tsv"))




# Prepare for iteration
N <- 10                                       # This sets the limit at JI > 0.65, fair enough I guess?
high_jaccard_ea_list <- list()
high_jaccard_protein_names <- list()
high_jaccard_protein_description <- list()
high_jaccard_df <- high_jaccard_df %>%
  arrange(desc(Jaccard_index))


for (i in 1:N) {
  strain_1 <- high_jaccard_df$strains_1[i]
  strain_2 <- high_jaccard_df$strains_2[i]
  
  # Grab the names of the proteins in the intersection
  proteins <- intersect(de_proteins_list[[strain_1]], de_proteins_list[[strain_2]])
  
  # Do an enrichment analysis
  proteins_detected <- data.frame("Protein_stable_ID" = proteins)
  proteins_detected <- left_join(proteins_detected, entrez_db, by = "Protein_stable_ID")
  proteins_detected <- proteins_detected$`NCBI_gene_(formerly_Entrezgene)_ID`
  
  go_results <- enrichGO(gene = proteins_detected, 
                           OrgDb = "org.Sc.sgd.db", 
                           keyType = "ENTREZID", 
                           ont = "ALL", 
                           universe = my_universe,
                           maxGSSize = 200)
  high_jaccard_ea_list[[i]] <- as.data.frame(go_results)
  
  
  # Save the full names of the proteins (normal ones and descriptive ones)
  temp <- data.frame("Gene.secondaryIdentifier" = proteins)
  temp <- left_join(temp, yeastmine, by = "Gene.secondaryIdentifier")
  high_jaccard_protein_description[[i]] <- temp[["Gene.name"]]
  
  high_jaccard_protein_names[[i]] <- proteins
}

# Get a version of the high_jaccard_df from which I can take a screenshot for my slides
temp_2 <- high_jaccard_df %>%
  dplyr::select(strains_1, strains_2, protein_number_1, protein_number_2, overlap_size, Jaccard_index)

# Summary of the proteins across the N intersections
sort(table(unlist(high_jaccard_protein_description)))

# Get a summary dataframe with the protein names and the description, for a slide
temp <- data.frame(table(unlist(high_jaccard_protein_names)))
colnames(temp) <- c("Gene.secondaryIdentifier", "Freq")
temp <- left_join(temp, yeastmine, by = "Gene.secondaryIdentifier") %>%
  dplyr::select(Gene.secondaryIdentifier, Freq, Gene.name)

# Summarize the pathways found in the EA
temp_list <- c()
for (i in 1:length(high_jaccard_ea_list)) {
  temp_list[[i]] <- as.character(high_jaccard_ea_list[[i]]$Description)
}
sort(table(unlist(temp_list)))
```


### 6.3.4. Test and plot for Jaccard Index across different variables (same amino acid, same Anticodon, same chromosome, same amino acid charge, same amino acid type...) - variables with 2 levels
```{r}
#' This functions needs to receive as input a dataframe where we want to perform the test for all the columns! Except for one column which is the one containing the Jaccard Index, and which needs to be called "Jaccard_index"
#' 
perform_chi_square_and_wmw_return_pvalues_and_effect_sizes <- function(DE_protein_overlaps) {
  # Create some vectors to collect the outcome
  variables <- c()
  p_vals_chi_square <- c()
  true_to_false_ratio_chi_square <- c()
  p_vals_wmw <- c()
  effect_size_directions_wmw <- c()
  perc_same_across_all_pairs <- c()
  
  
  # Iterate over the columns of the dataframe, performing the tests for each of them
  columns <- colnames(DE_protein_overlaps)
  columns <- columns[!columns %in% c("Jaccard_index")]
  for (i in 1:length(columns)) {
    # Save the name of the variable we are testing for
    variable <- columns[i]
    variables <- c(variables, variable)
    
    ## Chi-square test for the proportion of 0s in each group
    data <- table(as.numeric(!(DE_protein_overlaps$Jaccard_index == 0)), as.factor(DE_protein_overlaps[[variable]]))
    p_vals_chi_square <- c(p_vals_chi_square, chisq.test(data)$p.value)
    
    ## Proportion of 0s in each group
    true_group_zero_prop <- sum(DE_protein_overlaps$Jaccard_index[DE_protein_overlaps[[variable]] == T] == 0, na.rm = T)/
      sum(DE_protein_overlaps[[variable]] == T)
    false_group_zero_prop <- sum(DE_protein_overlaps$Jaccard_index[DE_protein_overlaps[[variable]] == F] == 0, na.rm = T)/
      sum(DE_protein_overlaps[[variable]] == F)
    true_to_false_ratio <- true_group_zero_prop/false_group_zero_prop                 
    # Changed this, now it represents the % increase (or decrease) in the proportion of 0s in the TRUE group w.r.t. the FALSE group
    if (true_to_false_ratio > 1) {
      true_to_false_ratio_chi_square <- c(true_to_false_ratio_chi_square, (true_to_false_ratio-1)*100)
    } else {
      true_to_false_ratio_chi_square <- c(true_to_false_ratio_chi_square, (1-true_to_false_ratio)*100)
    }
    
    
    ## Wilcoxon-Mann Whitney test for the non-zero values
    temp <- DE_protein_overlaps %>%
      filter(Jaccard_index != 0)
    x <- temp$Jaccard_index[temp[colnames(temp) == variable] == T]
    y <- temp$Jaccard_index[temp[colnames(temp) == variable] == F]
    p_vals_wmw <- c(p_vals_wmw, wilcox.test(x, y)$p.value)
    
    ## Wilcoxon-Mann Whitney effect size - TURNED THIS INTO "PERCENTAGE" EFFECT SIZE BY DIVIDING BY THE MEAN JACCARD INDEX IN THE GROUP WHERE THE PAIRS OF KOS DO NOT SHARE THE CHARACTERISTIC ("FALSE" GROUP) SO AS TO TRY TO MAKE THIS MORE INTERPRETABLE
    effect_size_directions_wmw <- c(effect_size_directions_wmw, ((mean(x)-mean(y))/mean(y))*100)
    
    # Grab a value which shows the percentage of pairs across which each variable was TRUE
    perc_same_across_all_pairs <- c(perc_same_across_all_pairs, sum(DE_protein_overlaps[[variable]] == T)/nrow(DE_protein_overlaps))
  }
  
  # Put it all together and return it
  p_values_chisq_and_wmw <- data.frame(variables, p_vals_chi_square, true_to_false_ratio_chi_square, p_vals_wmw, effect_size_directions_wmw,
                                       perc_same_across_all_pairs)
  return(p_values_chisq_and_wmw)
}


# Define the columns we want to provide as input for the above defined function - to test (Chi-square and WMW) the Jaccard Indexes across their levels
df <- DE_protein_overlaps %>%
  dplyr::select(Jaccard_index,
                same_amino_acid,
                same_family, 
                same_chromosome,
                same_amino_acid_and_chr, 
                same_family_and_chr,
                same_aa_charge,
                same_aa_type,
                Nt_at_1,
                Nt_at_2,
                Nt_at_3,
                Nt_at_4,
                Nt_at_5,
                Nt_at_6,
                Nt_at_7,
                Nt_at_8,
                Nt_at_9,
                Nt_at_10,
                Nt_at_11,
                Nt_at_12,
                Nt_at_13,
                Nt_at_14,
                Nt_at_15,
                Nt_at_16,
                Nt_at_17,
                Nt_at_18,
                Nt_at_19,
                Nt_at_20,
                Nt_at_21,
                Nt_at_22,
                Nt_at_23,
                Nt_at_24,
                Nt_at_25,
                Nt_at_26,
                Nt_at_27,
                Nt_at_28,
                Nt_at_29,
                Nt_at_30,
                Nt_at_31,
                Nt_at_32,
                Nt_at_33,
                Nt_at_34,
                Nt_at_35,
                Nt_at_36,
                Nt_at_37,
                Nt_at_38,
                Nt_at_39,
                Nt_at_40,
                Nt_at_41,
                Nt_at_42,
                Nt_at_43,
                Nt_at_44,
                Nt_at_45,
                Nt_at_46,
                Nt_at_47,
                Nt_at_48,
                Nt_at_49,
                Nt_at_40,
                Nt_at_51,
                Nt_at_52,
                Nt_at_53,
                Nt_at_54,
                Nt_at_55,
                Nt_at_56,
                Nt_at_57,
                Nt_at_58,
                Nt_at_59,
                Nt_at_60,
                Nt_at_61,
                Nt_at_62,
                Nt_at_63,
                Nt_at_64,
                Nt_at_65,
                Nt_at_66,
                Nt_at_67,
                Nt_at_68,
                Nt_at_69,
                Nt_at_70)

# Perform testing and save p-values and effect sizes
p_values_chisq_and_wmw <- perform_chi_square_and_wmw_return_pvalues_and_effect_sizes(df)

# Correct the p-values with BH
p_values_chisq_and_wmw$p_vals_chi_square_adj <- p.adjust(p_values_chisq_and_wmw$p_vals_chi_square, method = "BH")
p_values_chisq_and_wmw$p_vals_wmw_adj <- p.adjust(p_values_chisq_and_wmw$p_vals_wmw, method = "BH")






# WHEN USING ALL NUCLEOTIDE POSITIONS

# Keep only significant rows
p_values_large <- p_values_chisq_and_wmw %>%
  filter(p_vals_wmw_adj < alpha) %>%
  dplyr::select(-c(p_vals_chi_square, p_vals_wmw)) %>%
  arrange(p_vals_chi_square_adj)

p_values_print <- p_values_large %>%
  dplyr::select(-(perc_same_across_all_pairs))

# Print the resulting table to LaTex
print(xtable(p_values_print, label = "p_values_table_with_Nts", digits = c(9)), include.rownames = F)








# WHEN NOT USING ALL NUCLEOTIDE POSITIONS

## Filter out all rows referring to the nucleotides
#p_values_chisq_and_wmw <- p_values_chisq_and_wmw %>%
#  filter(!(grepl("Nt_at", variables))) %>%
#  dplyr::select(-c(p_vals_chi_square, p_vals_wmw, perc_same_across_all_pairs))
#
## Make the row descriptions a bit prettier - colnames I need to fix directly in LaTex - this only functions when I am not using all nucleotide #positions
#p_values_chisq_and_wmw$variables <- c("Carried amino acid", "Anticodon", "Chromosome", "Carried amino acid and chromosome", "Anticodon and chromosome",
#                                      "Amino acid charge", "Amino acid type")
#
## Print it to take it to LaTex
#print(xtable(p_values_chisq_and_wmw, label = "p_values_table", digits = c(8)), include.rownames=FALSE)
```

Manually check the effect of Nt_at_21, looking at what happens exactly for each Nt that can be there - TO DO
```{r}
D
```

Relate effect of Nt_at_whatever on Jaccard Index by conservation of that Nt position
```{r}
# Look at correlation first of all
temp <- p_values_large 
rownames(temp) <- temp[,1]
temp <- temp[,-1]
cor_mat <- round(cor(temp, use = "pairwise.complete"), 2)


# Look at how common each nucleotide is in each of some of the most interesting positions
table(master_dataset$Nt_at_21)
table(master_dataset$Nt_at_1)
table(master_dataset$Nt_at_33)


# Plots
ggplot(data = p_values_large, aes(x = perc_same_across_all_pairs, y = effect_size_directions_wmw)) +
  geom_point() +
  theme_light() +
  geom_text_repel(data = subset(p_values_large, effect_size_directions_wmw > 20 | perc_same_across_all_pairs > 0.45), 
                  aes(x = perc_same_across_all_pairs, y = effect_size_directions_wmw, label = variables))
```



## 6.4. Explore intersections between major KOs inside each family (only families with more than 1 major KO)
Prepare data
```{r}
# Load protein overlaps dataset created in previous section, with all possible intersections
DE_protein_overlaps <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/compare_DEPs_across_KOs/DE_protein_overlaps_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".tsv"))

# Master dataset
master_dataset <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/master_tRNA_dataset.csv"))
```

Got a bit side-tracked, exploring the correlation between the average nDEP in the pair and the JI
```{r}
# Keep only pairs where the 2 KOs belong to the same family
DE_protein_overlaps_same_family <- DE_protein_overlaps %>%
  filter(Anticodon_1 == Anticodon_2)

# JI vs. average nDEP
ggplot(data = DE_protein_overlaps, aes(x = protein_number_avg, y = Jaccard_index)) +
  geom_point(size = 0.2) +
  theme_light()

# JI vs. average nDEP - color by same family
ggplot(data = DE_protein_overlaps, aes(x = protein_number_avg, y = Jaccard_index, col = same_family)) +
  geom_point(size = 0.2) +
  theme_light()

# JI vs. average nDEP - for those pairs in the same family only
ggplot(data = DE_protein_overlaps_same_family, aes(x = protein_number_avg, y = Jaccard_index)) +
  geom_point(size = 1) +
  theme_light()
```

Analyze
```{r}
# This is what happens if I filter based on major - minor (defined by me)
DE_protein_overlaps_major_within_family <- DE_protein_overlaps %>%
  filter(Anticodon_1 == Anticodon_2,
         Gene_type_1 == "Major" & Gene_type_2 == "Major")

# Get a version of this which I can screenshot for a slide
temp <- DE_protein_overlaps_major_within_family %>%
  dplyr::select(strains_1, strains_2, protein_number_1, protein_number_2, overlap_size, Jaccard_index)

# Grab the strains in here and put them into a vector so I can filter the EA results by them
paired_major_strains <- sort(unique(c(as.character(DE_protein_overlaps_major_within_family$strains_1), as.character(DE_protein_overlaps_major_within_family$strains_2))))
```

Look at the EA results for these strains
```{r}
# Load GO EA results - this one doesn't work recently because I haven't been running the GO analysis! Only the GSEA, with both GO and KEGG annotations
go_results_list <- read_json(path = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/enrichment_analysis/go_results_list_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", simplifyVector = T)

# Load GSEA results (GO and KEGG)
kegg_gsea_results <- read_json(path = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/enrichment_analysis/kegg_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold),
                                            "_enrichment_alpha_", alpha_enrichment_plain, ".json", simplifyVector = T)
go_gsea_results <- read_json(path = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/enrichment_analysis/go_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold),
                                            "_enrichment_alpha_", alpha_enrichment_plain, ".json", simplifyVector = T)

# Keep only those we are interested in
go_results_list_filtered <- go_results_list[names(go_results_list) %in% paired_major_strains]
kegg_gsea_results_filtered <- kegg_gsea_results[names(kegg_gsea_results) %in% paired_major_strains]
go_gsea_results_filtered <- go_gsea_results[names(go_gsea_results) %in% paired_major_strains]
```



Produce LaTex table with significant pathways in pairs of KOs with the same Anticodon
  - GO
```{r}
N <- 10

# Load the GO GSEA results produced in that file
go_gsea_results <- read_json(path = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/enrichment_analysis/go_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", simplifyVector = T)

# For GO GSEA results
## Get the unique codons to iterate over
codons <- unique(sapply(names(go_gsea_results), extract_Anticodon_from_trna_name))

# Iterate over codons and create a table for each pair of KOs (for those Anticodons for which we have more than 1 KO)
for (i in 1:length(codons)) {
  codon <- codons[i]
  temp_go_gsea_results <- go_gsea_results[grepl(codon, names(go_gsea_results))]
  
  # Proceed only if there are GSEA results for at least 2 KOs with this Anticodon, and if at least 2 of them are major
  if ((length(temp_go_gsea_results) > 1) & sum(names(temp_go_gsea_results) %in% paired_major_strains) > 1) {
    temp_list <- list()
    temp_go_gsea_results <- temp_go_gsea_results[names(temp_go_gsea_results) %in% paired_major_strains]    # Remove the non-major subunits
    for (j in 1:length(temp_go_gsea_results)) {
      temp_go_gsea_results[[j]] <- temp_go_gsea_results[[j]][order(temp_go_gsea_results[[j]]$padj),]       # Order by increasing p-adj
      temp_go_gsea_results[[j]] <- temp_go_gsea_results[[j]][1:N,]                                         # Grab only the first N pathways
      temp_list[[names(temp_go_gsea_results)[j]]] <- sort(temp_go_gsea_results[[j]]$pathway)               # Grab the pathway names and order there them                                                                                                                     alphabetically, which makes it easier to compare them                                                                                                             between KO strains
    }
    out_df <- data.frame(matrix(ncol = 0, nrow = max(sapply(temp_list, length))))
    for (j in 1:length(temp_list)) {
      new_col <- temp_list[[j]]
      if (length(new_col) == max(sapply(temp_list, length))) {
        out_df[,j] <- new_col
      } else {
        out_df[,j] <- c(new_col, rep(NA, max(sapply(temp_list, length))-length(new_col)))
      }
    }
    colnames(out_df) <- names(temp_list)
    print(xtable(out_df), include.rownames=FALSE)
  }
}
```

  - KEGG
```{r}
N <- 10

# Load the GO GSEA results produced in that file
kegg_gsea_results <- read_json(path = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/enrichment_analysis/kegg_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", simplifyVector = T)

# For GO GSEA results
## Get the unique codons to iterate over
codons <- unique(sapply(names(kegg_gsea_results), extract_Anticodon_from_trna_name))

# Iterate over codons and create a table for each pair of KOs (for those Anticodons for which we have more than 1 KO)
for (i in 1:length(codons)) {
  codon <- codons[i]
  temp_kegg_gsea_results <- kegg_gsea_results[grepl(codon, names(kegg_gsea_results))]
  
  # Proceed only if there are GSEA results for at least 2 KOs with this Anticodon, and if at least 2 of them are major
  if ((length(temp_kegg_gsea_results) > 1) & sum(names(temp_kegg_gsea_results) %in% paired_major_strains) > 1) {
    temp_list <- list()
    temp_kegg_gsea_results <- temp_kegg_gsea_results[names(temp_kegg_gsea_results) %in% paired_major_strains]    # Remove the non-major subunits
    for (j in 1:length(temp_kegg_gsea_results)) {
      temp_kegg_gsea_results[[j]] <- temp_kegg_gsea_results[[j]][order(temp_kegg_gsea_results[[j]]$padj),]       # Order by increasing p-adj
      temp_kegg_gsea_results[[j]] <- temp_kegg_gsea_results[[j]][1:N,]                                         # Grab only the first N pathways
      temp_list[[names(temp_kegg_gsea_results)[j]]] <- sort(temp_kegg_gsea_results[[j]]$pathway)               # Grab the pathway names and order there them                                                                                                                     alphabetically, which makes it easier to compare them                                                                                                             between KO strains
    }
    out_df <- data.frame(matrix(ncol = 0, nrow = max(sapply(temp_list, length))))
    for (j in 1:length(temp_list)) {
      new_col <- temp_list[[j]]
      if (length(new_col) == max(sapply(temp_list, length))) {
        out_df[,j] <- new_col
      } else {
        out_df[,j] <- c(new_col, rep(NA, max(sapply(temp_list, length))-length(new_col)))
      }
    }
    colnames(out_df) <- names(temp_list)
    print(xtable(out_df), include.rownames=FALSE)
  }
}
```





## 6.5. Get the top 50 proteins between major KOs of the same family and compare their overlap
Cannot really do it based on the scores (as Markus suggested) for now since the scores for most of the strains are equal for like 90% or more of the proteins - maybe should fix that? But for now I'm doing it based on DE proteins, sorry, don't have time for this since I have to present in the group meeting soon
```{r}

```


Get the lists of IDs for ChatGPT, so it can go through the SGD pages for me and summarize what's going on with each strain
```{r}
for (i in 1:nrow(DE_protein_overlaps_major_within_family)) {
  strain_1 <- DE_protein_overlaps_major_within_family$strains_1[i]
  strain_2 <- DE_protein_overlaps_major_within_family$strains_2[i]
  
  print(glue("RESULST FOR THE FOLLOWING STRAIN PAIR: {strain_1}{strain_2}"))
  
  temp_1 <- da[[strain_1]] %>%
    filter(adj.P.Val < 0.05 & abs(logFC) > 0.5)
  
  temp_2 <- da[[strain_2]] %>%
    filter(adj.P.Val < 0.05 & abs(logFC) > 0.5)
  
  
  print(glue("{strain_1}"))
  print(cat(rownames(temp_1), sep = ", "))
  
  print(glue("{strain_2}"))
  print(cat(rownames(temp_2), sep=", "))
}
```













######################################################################################
# 7. Evaluate effect of individual nucleotides in tRNA structure
######################################################################################

## 7.1. Check % of U in N33, based on Kemp et al., 2012
They mention (citing a different, older article) that position N33 is usually a U, and when it gets mutated, the capacity of the tRNA to do its job is strongly decreased. So let me check in how many of them we have a U, and if not having a U correlates with low nDEP. In any case, I do have to keep in mind that the sequences I am using to check the nucleotide in each position are from a database with the "official" version of the tRNA sequence, I have no way to know what the actual sequences in the cells are, or whether they have been mutated or post-transcriptionally modified, so... Wait, but what I am looking at is the consensus sequence of the tRNA that was KOd lol, so it is obviously not going to be mutated or anything, it's just not there. The only consideration then is how trustworthy these sequences are, but other than that, this does provide the information that the effect of a KO in the cell is not 
```{r}
master_temp <- master_dataset %>%
  dplyr::select(Strain.Name, Nt_at_33) %>%
  dplyr::filter(Strain.Name != "")
resp_with_n33 <- left_join(responsiveness, master_temp, by = "Strain.Name")

summary(as.factor(resp_with_n33$Nt_at_33))

resp_with_n33$Nt_at_33 <- as.factor(resp_with_n33$Nt_at_33)

ggplot(data = resp_with_n33, aes(x = Nt_at_33, y = log2(nDEP), group = Nt_at_33)) +
  geom_boxplot(aes(fill = Nt_at_33)) +
  geom_jitter() +
  theme_light()
```
--> Yup, nothing conclusive at all, had to give it a try tho



## 7.2. Statistical test for nDEP between the 4 possible nucleotides in the consensus tRNA sequence at every position
```{r}
# Add columns with information of the Nt in each position to the responsiveness dataframe
master_temp <- master_dataset %>%
  dplyr::select(Strain.Name, contains("Nt_at_")) %>%
  dplyr::filter(Strain.Name != "")
resp_with_nts <- left_join(responsiveness, master_temp, by = "Strain.Name")

# Get the names of all the columns with Nt info and iterate over them, doing a Kruskal-Wallis test for nDEP ~ each of them, saving the p-values
nts <- colnames(resp_with_nts)[grepl("Nt_at_", colnames(resp_with_nts))]
p_vals <- c()

for (i in 1:length(nts)) {
  nt <- nts[i]
  p_vals <- c(p_vals, kruskal.test(data = resp_with_nts, nDEP ~ get(nt))$p.value)
}

# Significance obtained only for position 48, let's have a look at the boxplot for that one
ggplot(data = resp_with_nts, aes(x = Nt_at_48, y = log2(nDEP), group = Nt_at_48)) +
  geom_boxplot(aes(fill = Nt_at_48)) +
  geom_jitter() +
  theme_light()
```






######################################################################################
# 8. Check abundance of proteins suggested in Bloom-Ackermann et al., 2014 to be up- or down-regulated
######################################################################################

## 8.1. RNA pol III subunits
They could be up-regulated when a tRNA belonging to a multi-copy family is KOd, I think that would be the main thing to expect?

Load data
```{r}
# UniProt dataset
uniprot_db <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv"))

# da 
da <- fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/enrichment_analysis/da_df_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv")

# Grab subunit names
rna_pol_3_subunits <- uniprot_db$`Gene Names (ordered locus)`[grepl("RNA polymerase III subunit", uniprot_db$`Protein names`, ignore.case = T)]

# Proteomics data
y.protein <- readRDS("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/limpa_analysis/y.protein.rds")
trna_ko <- y.protein$E

# Sample layout
metadata <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/metadata_alvaro.tsv"))

# The master tRNA dataset
master_dataset <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/basic/master_tRNA_dataset.csv"))

# Load responsiveness dataset
responsiveness <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/produced_during_analysis/responsiveness_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv"))
```

Start by looking at a heatmap
```{r}
heatmap_df <- trna_ko[rownames(trna_ko) %in% rna_pol_3_subunits,]

# No grouping
create_heatmap(protein_mat = heatmap_df,
               annotation = "none",
               metadata = metadata,
               metadata_column_for_sample_name = "final_proteomics_colnames",
               heatmap_type = "z-score",
               z_score_type = "standard",
               location_to_save = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/Heatmaps/",
               save_as = "png",
               plot_name = "heatmap_z_score_standard_RNA_pol_III_subunits",
               heatmap_title = "Z-score tRNA KOs heatmap, RNApolIII subunits, no grouping",
               show_row_names = T)


# Grouping based on single-member family or multi-copy family 
master_dataset_temp <- master_dataset %>%
  dplyr::mutate(Family_size_cat = case_when(Family_size == 1 ~ "Single-copy",
                                            TRUE ~ "Multi-copy")) %>%
  dplyr::select(Strain.Name, Family_size_cat)
metadata_family_size <- left_join(metadata, master_dataset_temp, by = "Strain.Name") %>%
  dplyr::mutate(Family_size_cat = case_when(Strain.Name == "WT" ~ "WT",
                                            TRUE ~ Family_size_cat))

create_heatmap(protein_mat = heatmap_df,
               annotation = "single",
               metadata = metadata_family_size,
               metadata_column_for_sample_name = "final_proteomics_colnames",
               metadata_column_for_annotation = "Family_size_cat",
               color_palette = "viridis",
               heatmap_type = "z-score",
               z_score_type = "standard",
               location_to_save = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/Heatmaps/",
               save_as = "png",
               plot_name = "heatmap_z_score_standard_annotated_by_Family_size_cat_single_or_multi",
               heatmap_title = "Z-score tRNA KOs heatmap, RNApolIII subunits,\ngrouping on single- or multi-copy family")


# Grouping based on family size
master_dataset_temp <- master_dataset %>%
  dplyr::mutate(Family_size_cat = case_when(Family_size == 1 ~ "Single-copy",
                                            Family_size > 1 & Family_size <= 5 ~ "Small family",
                                            Family_size > 5 & Family_size <= 10 ~ "Medium family",
                                            Family_size > 10 ~ "Large family")) %>%
  dplyr::select(Strain.Name, Family_size_cat)
metadata_family_size <- left_join(metadata, master_dataset_temp, by = "Strain.Name") %>%
  dplyr::mutate(Family_size_cat = case_when(Strain.Name == "WT" ~ "WT",
                                            TRUE ~ Family_size_cat))

create_heatmap(protein_mat = heatmap_df,
               annotation = "single",
               metadata = metadata_family_size,
               metadata_column_for_sample_name = "final_proteomics_colnames",
               metadata_column_for_annotation = "Family_size_cat",
               color_palette = "viridis",
               heatmap_type = "z-score",
               z_score_type = "standard",
               location_to_save = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/Heatmaps/",
               save_as = "png",
               plot_name = "heatmap_z_score_standard_annotated_by_Family_size_cat",
               heatmap_title = "Z-score tRNA KOs heatmap, RNApolIII subunits,\ngrouping on family size")
```

The Z-scores in the heatmap are calculated across all samples, so they are around the mean expression of that protein, let me look at the distribution of the logFCs (which are w.r.t. to the WTs)
```{r}
da_temp <- da %>%
  dplyr::filter(protein %in% rna_pol_3_subunits)
ggplot(data = da_temp, aes(x = logFC)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light()
```
--> Interesting, there seems to be more down-regulation than up-regulation

Clustering
- Perform hierarchical clustering
```{r}
# Elbow method - try to figure out what number of clusters is appropriate 
clust_df <- heatmap_df
clust_df <- as.data.frame(t(clust_df))         
clust_df <- scale(clust_df)

fviz_nbclust(clust_df, kmeans, method = "wss", k.max = 15)

# Perform the clustering with the selected number of clusters
my_clusters <- perform_hierarchical_clustering(clust_df, "euclidean", "complete", 7)
```

- Clustering to save dendrogram to PDF
```{r}
# Set up parameters
distance_method <- "euclidean"
clustering_method <- "complete"

# Perform clustering and create dendrogram - CLUST_DF IS SCALED IN THE PREVIOUS CHUNK! IS THAT OKAY???
dist_mat <- dist(clust_df, method = distance_method)
tree <- hclust(dist_mat, method = clustering_method)
plot(tree, cex = 0.3)
hcd <- as.dendrogram(tree)

# Open a PDF for plotting; units are inches by default
pdf("/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/dendrograms/RNA_pol_III_dist_method_",  distance_method, "_clust_method_", clustering_method, ".pdf", width=40, height=15)

# Plot the tree into the PDF
plot(tree, cex = 0.3)

# Close the PDF file's associated graphics device (necessary to finalize the output)
dev.off()

# Rotate PDF
rotate_pdf(
  page_rotation = 90,
  input_filepath = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/dendrograms/RNA_pol_III_dist_method_",  distance_method, "_clust_method_", clustering_method, ".pdf",
  output_filepath = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/dendrograms/RNA_pol_III_dist_method_",  distance_method, "_clust_method_", clustering_method, ".pdf",
  overwrite = TRUE
)
```



Calculate weighted score per strain
```{r}
# Calculate the scores and make them into a dataframe
strains <- unique(da$Strain.Name)
scores <- c()

for (strain in strains) {
  da_temp <- da %>%
    dplyr::filter(Strain.Name == strain) %>%
    dplyr::filter(protein %in% rna_pol_3_subunits) %>%
    dplyr::mutate(score = logFC*(-log10(adj.P.Val)))
  strain_score <- sum(da_temp$score)/nrow(da_temp)
  scores <- c(scores, strain_score)
}

weighted_scores_df <- data.frame(Strain.Name = strains, weighted_score = scores)

# Check the mean and SD of this distribution to see where to put the threshold for "significant" up- or down-regulation
# Important to notice that this threshold should officially be at -log10(alpha)*logFC_threshold, but we don't get any significance there,
# so I might as well try this
median(weighted_scores_df$weighted_score)
sd(weighted_scores_df$weighted_score)
# --> Well that's not great, the limit 

# Plot the scores
ggplot(data = weighted_scores_df, aes(x = weighted_score)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  geom_vline(xintercept = -0.4, col = "orange", linewidth = 1) +
  geom_vline(xintercept = 0.4, col = "orange", linewidth = 1) +
  geom_label_repel(data = subset(weighted_scores_df, abs(weighted_score) > 0.4),
                  aes(x = weighted_score, y = 50, label = Strain.Name),
                  label.size = 0.5) +
  xlab("Score") +
  ylab("Frequency") +
  labs(title = "Combined DE measure of all 10 RNA pol III subunits across strains")

# Actually I would like to plot these scores against the same score for MAF1 in each of the strains, this is the main RNA pol III negative regulator,
# stress mediated and also related to tRNAs in other ways, interesting
strains <- unique(da$Strain.Name)
scores_maf1 <- c()

for (strain in strains) {
  da_temp <- da %>%
    dplyr::filter(Strain.Name == strain) %>%
    dplyr::filter(protein == "YDR005C") %>%
    dplyr::mutate(score = logFC*(-log10(adj.P.Val)))
  scores_maf1 <- c(scores_maf1, da_temp$score[1])
}

weighted_scores_df$scores_maf1 <- scores_maf1

ggplot(data = weighted_scores_df, aes(x = scores_maf1, y = weighted_score)) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05)*0.5, col = "orange", linewidth = 1) +
  geom_hline(yintercept = log10(0.05)*0.5, col = "orange", linewidth = 1) +
  geom_vline(xintercept = -log10(0.05)*0.5, col = "orange", linewidth = 1) +
  geom_vline(xintercept = log10(0.05)*0.5, col = "orange", linewidth = 1) +
  geom_label_repel(data = subset(weighted_scores_df, (scores_maf1 < -log10(0.05)*0.5 | scores_maf1 > log10(0.05)*0.5 |
                                                      weighted_score < -log10(0.05)*0.5 | weighted_score > log10(0.05)*0.5)),
                   aes(x = scores_maf1, y = weighted_score, label = Strain.Name), 
                   label.size = 0.15) +
  theme_light() +
  xlab("Expression score for MAF1") +
  ylab("Combined expression score for RNA pol III subunits") +
  labs(title = "Expression of RNA pol III subunits vs. expression of MAF1")

# Grab the name of the strains where the RNA pol III is up- or down-regulated, and check their family sizes
strains_with_up_reg_RNA_pol_III <- weighted_scores_df$Strain.Name[weighted_scores_df$weighted_score > 0.4]
strains_with_down_reg_RNA_pol_III <- weighted_scores_df$Strain.Name[weighted_scores_df$weighted_score < -0.4]

family_sizes_up <- master_dataset %>%
  dplyr::filter(Strain.Name %in% strains_with_up_reg_RNA_pol_III) %>%
  dplyr::distinct(Strain.Name, .keep_all = T) %>%
  dplyr::pull(Family_size)

family_sizes_down <- master_dataset %>%
  dplyr::filter(Strain.Name %in% strains_with_down_reg_RNA_pol_III) %>%
  dplyr::distinct(Strain.Name, .keep_all = T) %>%
  dplyr::pull(Family_size)

print("Sizes of families where RNA pol III seems to be up-regulated:")
print(family_sizes_up)
print("And down-regulated:")
print(family_sizes_down)

# Actually let me directly check the correlation between family size and this score
master_temp <- master_dataset %>%
  dplyr::select(Strain.Name, Family_size)
weighted_scores_df_all <- left_join(weighted_scores_df, master_temp, by = "Strain.Name")
cor(weighted_scores_df_all$weighted_score, weighted_scores_df_all$Family_size)

# Correlation is quite small, how about I check it spearately for major and minor subunits, since up-regulation seems to only happen when KOing the major subunit of a large family?
resp_temp <- responsiveness %>%
  dplyr::select(Strain.Name, Gene_type)

master_temp_major <- master_dataset %>%
  left_join(resp_temp, by = "Strain.Name") %>%
  dplyr::select(Strain.Name, Family_size, Gene_type)
weighted_scores_df_major <- left_join(weighted_scores_df, master_temp_major, by = "Strain.Name") %>%
  dplyr::filter(Gene_type == "Major")
cor(weighted_scores_df_major$weighted_score, weighted_scores_df_major$Family_size)

master_temp_minor <- master_dataset %>%
  left_join(resp_temp, by = "Strain.Name") %>%
  dplyr::select(Strain.Name, Family_size, Gene_type)
weighted_scores_df_minor <- left_join(weighted_scores_df, master_temp_minor, by = "Strain.Name") %>%
  dplyr::filter(Gene_type != "Major")
cor(weighted_scores_df_minor$weighted_score, weighted_scores_df_minor$Family_size)
```


Calculate Stouffer's Z per strain - TODO: WROTE THE CODE BUT DIDN'T CHECK THAT IT RUNS OR THAT IT MAKE SENSE!
```{r}
da <- da %>%
  dplyr::mutate(z_score_p_val = (adj.P.Val - median(da$adj.P.Val))/mad(da$adj.P.Val))

strains <- unique(da$Strain.Name)
scores <- c()

for (strain in strains) {
  da_temp <- da %>%
    dplyr::filter(Strain.Name == strain) %>%
    dplyr::filter(protein %in% rna_pol_3_subunits) %>%
    dplyr::mutate(weighted_z_score = abs(logFC)*z_score_p_val) %>%
    dplyr::mutate(squared_weight = (abs(logFC))^2)
  final_score_strain <- sum(da_temp$weighted_z_score)/sqrt(sum(squared_weight))
  scores <- c(scores, final_score_strain)
}
```




## 8.2. Proteotoxic response mechanisms in the strains that grow better in DTT than the WT
```{r}
go_terms_proteotoxicity <- data.frame(GO_terms = c("GO:0071218", "GO:0070843", "GO:0006515", "GO:0051788", "GO:0006457", "GO:0051083", 
                                                   "GO:0006986", "GO:0034620", "GO:0101031", "GO:0051087", "GO:0006458"),
                                      Name = c("cellular response to misfolded protein", "misfolded protein transport", 
                                               "protein quality control for misfolded or incompletely synthesized proteins", 
                                               "response to misfolded protein", "protein folding", "'de novo' cotranslational protein folding", "response to unfolded protein", 
                                               "cellular response to unfolded protein", "protein folding chaperone complex", "protein-folding chaperone binding", 
                                               "'de novo' protein folding"))

trna_ko <- as.data.frame(trna_ko)

for (i in 1:nrow(go_terms_proteotoxicity)) {
  go_term <- go_terms_proteotoxicity$GO_terms[i]
  proteins_to_select <- uniprot_db$`Gene Names (ordered locus)`[grepl(go_term, uniprot_db$`Gene Ontology IDs`)]
  print(proteins_to_select)
  trna_temp <- trna_ko[rownames(trna_ko) %in% proteins_to_select,]
  
  if (nrow(trna_temp) > 1) {
    create_heatmap(protein_mat = trna_temp,
                   annotation = "none",
                   metadata = metadata,
                   metadata_column_for_sample_name = "final_proteomics_colnames",
                   heatmap_type = "z-score",
                   z_score_type = "standard",
                   location_to_save = "/home/alvaro/MyStuff/Projects/tRNA_KOs/Output/Plots/Heatmaps/proteotoxicity/",
                   save_as = "png",
                   plot_name = go_terms_proteotoxicity$Name[go_terms_proteotoxicity$GO_terms == go_term],
                   heatmap_title = paste("Z-score tRNA KOs heatmap, proteins in ", go_term, ", no grouping"),
                   show_row_names = F)
  }
}
```



















