---
title: "try_limpa_reanalysis"
author: "Álvaro Gómez Pérez"
date: "2025-05-18"
output: html_document
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Packages
```{r}
library(tidyr)
library(dplyr)
library(data.table)
library(ggplot2)
library(limpa)
library(stringr)
```


Set up
```{r}
# Significance level to be used for all tests and plots in this file
alpha <- 0.05

# Significance level as a plain string to use when loading or writing files
alpha_plain <- str_replace(as.character(alpha), "\\.", "")

# Minimum threshold for the average log2-expression across all samples in order to keep a protein in the data before DE analysis
mean_log2_across_all_samples_threshold <- 2

# Minimum threshold for the variance of the log2-expression across all samples in order to keep a protein in the data before DE analysis
var_across_log2_all_samples_threshold <- 0.6

# Separate significance level, the one used for the enrichment analysis
alpha_enrichment <- 0.05

# Significance level above as a plain string to use when loading or writing files
alpha_enrichment_plain <- str_replace(as.character(alpha_enrichment), "\\.", "")

# Log-fold change limit to be considered "biologically significant"
lfc_threshold <- 1

# Number of nDEP from which a tRNA is considered "major" (this threshold value should be included) - THIS I AM NOT USING ANYMORE, AM I?
threshold_major <- 2

# Set directories to be used
working_from = "home"

if (working_from == "home") {
  base_dir = "/home/alvaro/MyStuff/tRNA_KOs/"
} else
if (working_from == "charite") {
  base_dir = "C:/MyStuff/tRNA_KOs/"
}

```



Load data
```{r}
# Boris pre-processed data - normalized, batch and drift corrected
raw_data <- as.data.frame(fread(paste(base_dir, "Data/AlternativeAAUsage-tRNA_peptidecentric_PrecursorQuantity_reprep_driftcorrected_batchcorrected_onWTs.tsv", sep="")))
rownames(raw_data) <- raw_data$Precursor.Id

# Sample layout - from the S drive
sample_layout <- as.data.frame(fread(paste(base_dir, "Data/Other/proteomics_data/sample_layout_alvaro.tsv", sep="")))

# Separate metadata
metadata <- raw_data %>%
  dplyr::select(Precursor.Id, Stripped.Sequence, Protein.Group, Genes)
rownames(metadata) <- NULL
raw_data <- raw_data %>%
  dplyr::select(-c(Precursor.Id, Stripped.Sequence, Protein.Group, Genes))

# Fix colnames (sample names)
colnames(raw_data) <- sapply(colnames(raw_data), function(x) str_replace_all(x, "-", "_"))
temp_match <- sample_layout %>%
  dplyr::select(Sample.ID.unique, final_proteomics_colnames)
temp_colnames <- data.frame(Sample.ID.unique = colnames(raw_data)) %>%
  left_join(temp_match, by = "Sample.ID.unique")
colnames(raw_data) <- temp_colnames$final_proteomics_colnames

# Remove unnecessary variables
rm(temp_match, temp_colnames)
```


Prepare limpa input
```{r}
# Protein labels
protein.id <- metadata$Protein.Group

# Design matrix
## Get the names of all KOs we have, and set WT as the reference
trna_levels <- c()
for (i in 1:ncol(raw_data)) {
  sample_name <- colnames(raw_data)[i]
  strain_name <- sample_layout$Strain.Name[sample_layout$final_proteomics_colnames == sample_name]
  if (length(strain_name) > 1) {
    strain_name <- strain_name[1]
  }
  trna_levels <- c(trna_levels, strain_name)
}
trna_levels <- as.factor(trna_levels)
trna_levels <- relevel(trna_levels, ref = "WT")

## Generate design matrix
mm <- model.matrix(~ 0 + trna_levels)
colnames(mm) <- levels(trna_levels)
```


Run limpa analysis
THERE ARE STILL WARNINGS IN THE FOR LOOP, SHOULD LOOK INTO THAT BUT RESULTS SEEM REASONABLE
```{r}
# Original code
dpcfit <- dpc(raw_data)
y.protein <- dpcQuant(raw_data, protein.id, dpc=dpcfit)
fit <- dpcDE(y.protein, mm)
#fit <- eBayes(fit)
#full_top_table_1 <- topTable(fit, coef = 2)

# This is what they provide, I wonder if they use the kind of design matrix that Alexis used
# I did not, so I am going to introduce contrasts here? I hope that makes sense?
## Create all contrasts - need to susbtitute parentheses in strain names by dots so that it runs...
treatments <- colnames(fit$coefficients)
treatments <- sapply(treatments, function(x) str_replace(x, "\\(", "."))
treatments <- sapply(treatments, function(x) str_replace(x, "\\)", "."))
design <- model.matrix(~ 0 + treatments)
colnames(design) <- treatments
contrast_list <- paste0(treatments, "-WT")

## Need to change parentheses to dots in the fit object as well so they match...
colnames(fit$coefficients) <- sapply(colnames(fit$coefficients), function(x) str_replace(x, "\\(", "."))
colnames(fit$coefficients) <- sapply(colnames(fit$coefficients), function(x) str_replace(x, "\\)", "."))

## Introduce the contrasts and run eBayes for them, 10 at a time
da <- list()
batch_size <- 5
n_batches <- ceiling(ncol(fit$coefficients)/batch_size)

for (i in 1:n_batches) {
  contrast_subset <- contrast_list[((i - 1) * batch_size + 1):min(i * batch_size, length(contrast_list))]
  contrast.matrix <- makeContrasts(contrasts = contrast_subset, levels = design)
  
  fit2 <- contrasts.fit(fit, contrast.matrix)
  fit3 <- eBayes(fit2, robust = TRUE, trend = TRUE)
  
  new_contrast_names <- c()
  
  # Store topTables for each contrast
  for (contrast_name in colnames(contrast.matrix)) {
    new_name <- substr(contrast_name, 1, str_locate(contrast_name, "-")-1)
    if (grepl(".", new_name)) {
        substr(new_name, 3, 3) <- "("
        substr(new_name, 7, 7) <- ")"
    }
    da[[new_name]] <- topTable(fit3, coef = contrast_name, adjust.method = 'BH', number = Inf, sort.by = 'none')
    da[[new_name]]$Strain.Name <- rep(new_name, nrow(da[[new_name]]))
  }
}
```

Finish processing the DE analysis results
```{r}
# Format data
da <- bind_rows(da) %>%
  mutate(protein = rep(rownames(da[[1]]), times = length(da))) %>%
  dplyr::distinct(Strain.Name, protein, logFC, .keep_all = T)
temp <- sample_layout %>%
  dplyr::distinct(Strain.Name, .keep_all = T)
da <- left_join(da, temp, by = "Strain.Name") %>%
  dplyr::relocate(Strain.Name, .before = logFC) %>%
  dplyr::relocate(protein, .after = Strain.Name) %>%
  filter(Strain.Name != "WT")

da <- da %>%
  dplyr::select(protein, Strain.Name, logFC, P.Value, adj.P.Val) %>%                              # From here on in this function it's added by me
  mutate(diffexpressed_adjusted = case_when((logFC > lfc_threshold) & (adj.P.Val < alpha) ~ "Up_regulated",
                                            (logFC < -lfc_threshold) & (adj.P.Val < alpha) ~ "Down_regulated",
                                            TRUE ~ "Not_significant"),
         diffexpressed_non_adjusted = case_when((logFC > lfc_threshold) & (P.Value < alpha) ~ "Up_regulated",
                                                (logFC < -lfc_threshold) & (P.Value < alpha) ~ "Down_regulated",
                                                TRUE ~ "Not_significant"))

da <- da %>%
  dplyr::distinct(Strain.Name, protein, logFC, .keep_all = T)

# Add a column to da with the number of replicates per KO - by me
unique_KOs <- unique(da$Strain.Name)
replicates <- c()
for (i in 1:length(unique_KOs)) {
  KO <- unique_KOs[i]
  replicates <- c(replicates, sum(grepl(KO, colnames(trna_ko), fixed = T)))
}
KOs_replicates <- data.frame(unique_KOs, replicates)
colnames(KOs_replicates) <- c("Strain.Name", "Replicate_num")
da <- merge(da, KOs_replicates, by = "Strain.Name")

# Responsiveness
responsiveness <- da %>%
  group_by(Strain.Name) %>%
  summarise(nDEP = sum(abs(logFC) >= lfc_threshold & adj.P.Val <= alpha, na.rm = T),
            Up_regulated_adjusted = sum(abs(logFC) >= lfc_threshold & adj.P.Val <= alpha & diffexpressed_adjusted == "Up_regulated", na.rm = T),
            Down_regulated_adjusted = sum(abs(logFC) >= lfc_threshold & adj.P.Val <= alpha & diffexpressed_adjusted == "Down_regulated", na.rm = T),
            Up_regulated_non_adjusted = sum(abs(logFC) >= lfc_threshold & P.Value <= alpha & diffexpressed_non_adjusted == "Up_regulated", na.rm = T),
            Down_regulated_non_adjusted = sum(abs(logFC) >= lfc_threshold & P.Value <= alpha & diffexpressed_non_adjusted == "Down_regulated", na.rm = T),
            Replicate_num = mean(Replicate_num)) %>%
  mutate(Amino_acid_1_letter = str_sub(Strain.Name, 2, 2),
         chromosome_letter = substr(Strain.Name, 8, 8),
         anticodon = str_extract(Strain.Name, "(?<=\\()[[:alpha:]]{3}(?=\\))"),
         up_down_regulated_ratio_adjusted = Up_regulated_adjusted/Down_regulated_adjusted,
         up_down_regulated_ratio_non_adjusted = Up_regulated_non_adjusted/Down_regulated_non_adjusted) %>%
  arrange(Amino_acid_1_letter) %>%
  mutate(anticodon = factor(anticodon, levels = unique(anticodon)))

# Add all amino acid names
amino_acids <- as.data.frame(fread(paste(base_dir, "Data/Other/GtRNAdb/amino_acids.csv", sep="")))
responsiveness <- left_join(responsiveness, amino_acids, by = "Amino_acid_1_letter")
```



## 1.5. Volcano plots for the differential expression
```{r}
# One plot per KO and save them to a PDF - for all KOs
## Come up with the list of plots
plot_list <- list()
for (i in 1:length(levels(as.factor(da$Strain.Name)))) {
  trna <- levels(as.factor(da$Strain.Name))[i]
  temp <- da %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = glue("{trna} - {unique(temp$Replicate_num)} replicates")) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "Output/Plots/Volcano_plots/limpa_volcano_plots_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)




# One plot per KO and save them to a PDF - for all KOs
## Come up with the list of plots
plot_list <- list()
for (i in 1:length(levels(as.factor(da$Strain.Name)))) {
  trna <- levels(as.factor(da$Strain.Name))[i]
  temp <- da %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(P.Value), col = diffexpressed_non_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = trna) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "Output/Plots/Volcano_plots/limpa_volcano_plots_per_KO_all_KOs_non_adjusted_p_values_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)




# One plot per KO and save them to a PDF - only for KOs with at least 1 DE protein
## Remove KOs with 0 DE proteins
KOs_with_DE_proteins <- responsiveness$Strain.Name[responsiveness$nDEP > 0]
da_only_KOs_with_DE_proteins <- da[da$Strain.Name %in% KOs_with_DE_proteins,]

## Come up with the list of plots
plot_list <- list()
for (i in 1:length(KOs_with_DE_proteins)) {
  trna <- KOs_with_DE_proteins[i]
  temp <- da_only_KOs_with_DE_proteins %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = trna) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "Output/Plots/Volcano_plots/limpa_volcano_plots_per_KO_KOs_with_DE_proteins_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)
```
--> Lots of the volcano plots are completely flat, just dots at the bottom. It would be nice if I could compare this to which are minor and which are major tRNA copies within each family actually, that would be great, but we don't have that information, do we? We have it for one family I think, I could check that, and then for the other families I would have to make the conclusions about "major" and "minor" myself precisely based on this, no?

Volcano plot for all KO strains together
```{r}
ggplot(data = da, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = "Volcano plot for all KO strains together",
         subtitle = "Adjusted p-values") +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))


ggplot(data = da, aes(x = logFC, y = -log10(P.Value), col = diffexpressed_non_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = "Volcano plot for all KO strains together",
         subtitle = "Raw p-values") +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))


# Remove unused objects
#rm(list = c("my_grobs", "plot_list", "KOs_with_DE_proteins", "temp", "da_only_KOs_with_DE_proteins", "trna", "i", "output_file"))
```

Evaluate distribution of p-values and fold-changes
```{r}
ggplot(data = da, aes(x = P.Value)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = "Distribution of raw p-values for DE", 
       subtitle = "All KO strains") +
  xlab("p-value") +
  ylab("Count")

ggplot(data = da, aes(x = adj.P.Val)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = "Distribution of adjusted p-values for DE", 
       subtitle = "All KO strains") +
  xlab("p-value") +
  ylab("Count")

ggplot(data = da, aes(x = logFC)) +
  geom_histogram(col = "black", fill = "grey", binwidth = 0.2) +
  theme_light() +
  labs(title = "Distribution of logFC values for DE", 
       subtitle = "All KO strains") +
  xlab("logFC") +
  ylab("Count")
```






Further code? In the limpa manual, not totally sure what this is supposed to do
```{r}
fit_2 <- dpcDE(y.protein, mm, plot=TRUE)
fit_2 <- eBayes(fit_2)
topTable(fit_2, coef=2)
```







Save limpa results
```{r}
# As .RData
save(dpcfit, y.protein, fit, file = paste(base_dir, "Data/Other/limpa_analysis/limpa_analysis_results.RData", sep=""))

# As .rds
saveRDS(dpcfit, file = paste(base_dir, "Data/Other/limpa_analysis/dpcfit.rds", sep=""))
saveRDS(y.protein, file = paste(base_dir, "Data/Other/limpa_analysis/y.protein.rds", sep=""))
saveRDS(fit, file = paste(base_dir, "Data/Other/limpa_analysis/fit.rds", sep=""))
```

Load limpa results 
```{r}
# From .RData
load(paste(base_dir, "Data/Other/limpa_analysis/limpa_analysis_results.RData", sep=""))

# From .rds
dpcfit <- readRDS(paste(base_dir, "Data/Other/limpa_analysis/dpcfit.rds", sep=""))
y.protein <- readRDS(paste(base_dir, "Data/Other/limpa_analysis/y.protein.rds", sep=""))
fit <- readRDS(paste(base_dir, "Data/Other/limpa_analysis/fit.rds", sep=""))
```

Evaluate results with the plots from the limpa package
```{r}
plotDPC(dpcfit)
plotMDSUsingSEs(y.protein)

```





















