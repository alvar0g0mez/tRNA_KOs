---
title: "tRNAs"
author: "Álvaro Gómez Pérez"
date: "2024-11-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Packages
```{r}
library(dplyr)
library(data.table)
library(limma)
library(ggplot2)
library(patchwork)
library(tidyr)
library(tibble)
library(stringr)
library(gprofiler2)
library(xlsx)
library(stringr)
library(gridExtra)
library(grid)
suppressPackageStartupMessages(library(ComplexHeatmap))
suppressPackageStartupMessages(library(circlize))
library(factoextra)
library(glue)
library(dendextend)
library(ggrepel)
library(ggvenn)
library(tidyr)
library(interactions)
library(performance)
library(MASS)
library(jsonlite)
```

Set parameters
```{r}
# Significance level to be used for all tests and plots in this file
alpha <- 0.01

# Log-fold change limit to be considered "biologically significant"
lfc_threshold <- 1.5

# Number of nDEP from which a tRNA is considered "major" (this threshold value should be included)
threshold_major <- 2

# Set directories to be used
working_from = "charite"

if (working_from == "home") {
  base_dir = "/home/alvaro/MyStuff/tRNA_KOs/"
} else
if (working_from == "charite") {
  base_dir = "C:/MyStuff/tRNA_KOs/"
}
```





################################################################################
# 1. Load data and initial analysis
################################################################################
## 1.1. Load data
```{r}
if (working_from == "charite") {
  # Our proteomics data 
  proteomics_raw <- read.delim2('S:/AG/AG-CF-HTMS/AG-Ralser-Share/30-0092_AndreaLehmann-AlternativeAAUsage-tRNA/05_DataAnalysis/11_Preprocessing_Boris/AlternativeAAUsage-tRNA/AlternativeAAUsage-tRNA_peptidecentric_ProteinMaxLFQ_PCAoutlier_removed_complete.tsv', header = T)
  
  # The sample layout
  sample_layout <- as.data.frame(fread("S:/AG/AG-CF-HTMS/AG-Ralser-Share/30-0092_AndreaLehmann-AlternativeAAUsage-tRNA/05_DataAnalysis/11_Preprocessing_Boris/AlternativeAAUsage-tRNA/AlternativeAAUsage-tRNA_peptidecentric_PrecursorQuantity_filename_annotations.tsv"))
  
  # The master tRNA dataset
  master_dataset <- as.data.frame(fread("C:/MyStuff/tRNA_KOs/Data/Other/GtRNAdb/master_tRNA_dataset.csv"))
  
  # Import the functions I have created in another file
  source("C:/MyStuff/tRNA_KOs/Code/R/Mine/0.general_use_functions.R")
} else 

if (working_from == "home") {
  # Proteomics data and sample layout - from the S drive
  #proteomics_raw <- read.delim2('/home/alvaro/MyStuff/tRNA_KOs/Data/proteomics_data/AlternativeAAUsage-tRNA_peptidecentric_ProteinMaxLFQ_PCAoutlier_removed_complete.tsv', header = T)
  
  proteomics_raw <- read.delim2('/home/alvaro/MyStuff/tRNA_KOs/Data/Other/proteomics_data/AlternativeAAUsage-tRNA_peptidecentric_ProteinMaxLFQ_complete.tsv', header = T)
  
  sample_layout <- as.data.frame(fread("/home/alvaro/MyStuff/tRNA_KOs/Data/Other/proteomics_data/AlternativeAAUsage-tRNA_peptidecentric_PrecursorQuantity_filename_annotations.tsv"))
  
  
  # My data - in the project folder - when I open the project, the directory is set to its location
  ## The master tRNA dataset
  master_dataset <- as.data.frame(fread("/home/alvaro/MyStuff/tRNA_KOs/Data/Other/GtRNAdb/master_tRNA_dataset.csv"))
  
  ## Import the functions I have created in another file
  source("/home/alvaro/MyStuff/tRNA_KOs/Code/R/Mine/0.general_use_functions.R")
}
```

## 1.2. Add columns to sample_layout and merge it with master_dataframe
```{r}
# Extract the date for when each sample was run
sample_layout <- sample_layout %>% 
  mutate(date = str_extract(File.Name, "(?<=/30-0092/).*?(?=_Z2_KTT_)"))

# Create a column that simply has the info of if each sample is a KO strain or a WT replicate
sample_layout <- sample_layout %>% 
  mutate(Strain.Type = case_when(Strain.Name == "WT" ~ "WT",
                                 TRUE ~ "KO"))

# Add a column with the following format: Analysis.Plate.96_Replicate
sample_layout <- sample_layout %>%
  mutate(Analysis.Plate.96_Replicate = paste(Analysis.Plate.96, Replicate, sep="_"))

# Add a column which identifies samples in Analysis.Plate.96 = 3, Replicate = 2
sample_layout <- sample_layout %>%
  mutate(Wrong_batch = case_when(Analysis.Plate.96_Replicate == "3_2" ~ "Yes",
                                 TRUE ~ "No"))

# Merge with master dataframe
sample_layout <- sample_layout %>% 
  dplyr::select(-Anticodon) %>%
  left_join(master_dataset, by = c("Strain.Name"))
```

## 1.3. Pre-process proteomics data - this is where I deal with the 2 duplicated strains and remove samples in the wrong subbatch
```{r}
# Come up with new colnames
new_names <- c("sample_group", "genes")
for (i in 3:ncol(proteomics_raw)) {
  strain_and_batch <- colnames(proteomics_raw)[i]
  trna_name <- proteomics_raw[1, i]
  batch_num <- str_extract(strain_and_batch, "(?<=\\.).*")
  new_name <- paste(trna_name, "_", batch_num, sep = "")
  new_names <- c(new_names, new_name)
}
colnames(proteomics_raw) <- new_names


# Fix the situation with 2 tRNA_KOs being present twice (so 6 replicates for each instead of 3) - just going to take the average between the replicated samples
## Come up with the averages
n_occur <- data.frame(table(colnames(proteomics_raw)))
repeated_samples <- as.character(n_occur$Var1)[n_occur$Freq > 1]

out_temp <- data.frame(matrix(ncol = 0, nrow = nrow(proteomics_raw)))
for (i in 1:length(repeated_samples)) {
  strain <- repeated_samples[i]
  temp <- proteomics_raw[5:nrow(proteomics_raw), colnames(proteomics_raw) == strain]
  temp[,1] <- as.numeric(temp[,1])
  temp[,2] <- as.numeric(temp[,2])
  first_rows <- proteomics_raw[1:4, colnames(proteomics_raw) == strain]
  out <- c(first_rows[,1], apply(temp, 1, mean))
  out_temp[,i] <- out
}
colnames(out_temp) <- repeated_samples

## Remove original columns from dataframe and add the averaged ones
proteomics_raw <- proteomics_raw[,!(colnames(proteomics_raw) %in% repeated_samples)]
proteomics_raw <- cbind(proteomics_raw, out_temp)


# Format data to get a biological protein abundance dataframe with samples names as colnames and gene names as rownames
trna_ko <- proteomics_raw %>%                 
  filter(!(genes %in% c('', 'Genes', 'Protein.Group'))) %>%             # Remove rows for which "genes" column is empty or has "Genes" as value
  dplyr::select(-genes & !contains('QC')) %>%                                  # Remove UNIPROT IDs and QCs columns
  column_to_rownames(var = 'sample_group')                              # Convert gene name column to rownames

# Convert to a numeric dataframe
trna_ko <- as.data.frame(apply(trna_ko, 2, as.numeric), row.names =  rownames(trna_ko))   

# Add sample_names to sample_layout so that we can filter out in the next line
sample_layout <- sample_layout %>%
  mutate(sample_names = case_when(Strain.ID == "WT" ~ paste(gsub("-", "_", Sample.ID), ".0", Replicate, sep=""),
                                  TRUE ~ paste(Strain.Name, "_0", Replicate, sep=""))) 

# Remove the sub-batch that went wrong
samples_in_wrong_batch <- sample_layout$sample_names[sample_layout$Analysis.Plate.96_Replicate == "3_2"]
trna_ko <- trna_ko[,!(colnames(trna_ko) %in% samples_in_wrong_batch)]

# Save this last dataset for later usage elsewhere
fwrite(trna_ko, paste(base_dir, "Data/Other/proteomics_data/processed_proteomics_dataframe.tsv", sep=""), row.names = T)

# Remove unnecessary objects
rm(proteomics_raw, n_occur, repeated_samples, out_temp, strain, temp, first_rows, out, batch_num, i, new_name, new_names, strain_and_batch, trna_name,
   samples_in_wrong_batch)
```

## 1.4. Differential expression analysis - adapted from what Alexis did, still need to fully understand some stuff
Perform DE analysis
```{r}
# Get the names of all KOs we have, and set WT as the reference
trna_levels <- c()
for (i in 1:ncol(trna_ko)) {
  sample_name <- colnames(trna_ko)[i]
  strain_name <- sample_layout$Strain.Name[sample_layout$sample_names == sample_name]
  if (length(strain_name) > 1) {
    strain_name <- strain_name[1]
  }
  trna_levels <- c(trna_levels, strain_name)
}
trna_levels <- as.factor(trna_levels)
trna_levels <- relevel(trna_levels, ref = "WT")


# Generate design matrix
mm <- model.matrix(~trna_levels)
colnames(mm) <- levels(trna_levels)
voom(trna_ko, mm, plot = TRUE)                                  # This I still need to look into!

# In order to fit linear model we need to get log2(data), but that causes log2(0) = -Inf --> I am turning 0s to 1s before log2 --> IDK HOW CORRECT THIS IS
zeros_to_ones <- function(x) {
  if (x == 0) {return(1)}
  else {return(x)}
}
trna_ko_log <- trna_ko
trna_ko_log[] <- apply(trna_ko, c(1,2), zeros_to_ones)
trna_ko_log <- log2(trna_ko_log)

# Fit linear model
fit <- lmFit(trna_ko_log, mm)                                 # Notice the log2 here
fit2 <- eBayes(fit, trend = TRUE)

# Identify differentially expressed proteins
da <- list()
for (i in colnames(mm)) {
  da[[i]] <- topTable(fit2, coef = i, adjust = 'BH', number = Inf, sort.by = 'none')
}
```

Save DE proteins for GO enrichment analysis
```{r}
# At the alpha specified at the top of the document
yeastmine <- as.data.frame(fread(paste(base_dir, "Data/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))
de_proteins_list_001 <- list()
for (i in 1:length(da)) {
  temp <- da[[i]]
  
  # Collect protein names and turn them all into systematic notation
  general_protein_names <- rownames(temp)[na.omit(temp$adj.P.Val) < alpha]
  standard_protein_names <- general_protein_names[general_protein_names %in% yeastmine$Gene.symbol]
  systematic_protein_names <- general_protein_names[general_protein_names %in% yeastmine$Gene.secondaryIdentifier]
  final_protein_names <- c(systematic_protein_names, match_systematic_and_standard_protein_names(data = standard_protein_names,
                                                                                                 yeastmine = yeastmine,
                                                                                                 input = "standard",
                                                                                                 simplify = T))
  
  # Save protein names
  de_proteins_list_001[[names(da)[i]]] <- final_protein_names
}
output_file <- paste(base_dir, "Data/Other/enrichment_analysis/de_proteins_list_001.json", sep="")
write_json(de_proteins_list_001, path=output_file)




# At alpha= 0.05
yeastmine <- as.data.frame(fread(paste(base_dir, "Data/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))
de_proteins_list_005 <- list()
for (i in 1:length(da)) {
  temp <- da[[i]]
  
  # Collect protein names and turn them all into systematic notation
  general_protein_names <- rownames(temp)[na.omit(temp$adj.P.Val) < 0.05]
  standard_protein_names <- general_protein_names[general_protein_names %in% yeastmine$Gene.symbol]
  systematic_protein_names <- general_protein_names[general_protein_names %in% yeastmine$Gene.secondaryIdentifier]
  final_protein_names <- c(systematic_protein_names, match_systematic_and_standard_protein_names(data = standard_protein_names,
                                                                                                 yeastmine = yeastmine,
                                                                                                 input = "standard",
                                                                                                 simplify = T))
  
  # Save protein names
  de_proteins_list_005[[names(da)[i]]] <- final_protein_names
}
output_file <- paste(base_dir, "Data/Other/enrichment_analysis/de_proteins_list_005.json", sep="")
write_json(de_proteins_list_005, path=output_file)
```

Save all proteins for GSEA
```{r}
write_json(da, path=paste(base_dir, "Data/Other/enrichment_analysis/da.json", sep=""), pretty = T)
```

Finish processing the DE analysis results
```{r}
# Format data
da <- bind_rows(da) %>%
  mutate(protein = rep(rownames(da[[1]]), times = length(da)),
         Strain.Name = rep(names(da), each = nrow(da[[1]])), .before = 1) %>%
  `rownames<-`(NULL) %>%
  dplyr::select(protein, Strain.Name, logFC, adj.P.Val) %>%
  filter(Strain.Name != 'WT') %>%                              # From here on in this function it's added by me
  mutate(diffexpressed = case_when(logFC > lfc_threshold & adj.P.Val < alpha ~ "Up_regulated",
                                   logFC < -lfc_threshold & adj.P.Val < alpha ~ "Down_regulated",
                                   TRUE ~ "Not_significant"))

# Add a column to da with the number of replicates per KO - by me - THIS DOESN'T REALLY MAKE SENSE INSIDE THIS FUNCTION BUT WHEN DOING DE FOR ALL PLATES AT ONCE IT WAS, SO I'LL KEEP IT JUST IN CASE
unique_KOs <- unique(da$Strain.Name)
replicates <- c()
for (i in 1:length(unique_KOs)) {
  KO <- unique_KOs[i]
  replicates <- c(replicates, sum(grepl(KO, colnames(trna_ko), fixed = T)))
}
KOs_replicates <- data.frame(unique_KOs, replicates)
colnames(KOs_replicates) <- c("Strain.Name", "Replicate_num")
da <- merge(da, KOs_replicates, by = "Strain.Name")

# Responsiveness
responsiveness <- da %>%
  group_by(Strain.Name) %>%
  summarise(nDEP = sum(abs(logFC) >= log2(lfc_threshold) & adj.P.Val <= 0.01, na.rm = T),
            Replicate_num = mean(Replicate_num)) %>%
  mutate(AA = str_sub(Strain.Name, 2, 2),
         chromosome = str_extract(str_remove(str_sub(Strain.Name, 1, -4), '[:digit:]$'), '[:alpha:]$'),
         anticodon = str_extract(Strain.Name, "(?<=\\()[[:alpha:]]{3}(?=\\))")) %>%
  arrange(AA) %>%
  mutate(anticodon = factor(anticodon, levels = unique(anticodon)))

# Save responsiveness dataset
fwrite(responsiveness, paste(base_dir, "Data/responsiveness.csv", sep=""))

# Save results from the DE analysis in the same way as in the file where I do DE separately for each batch
DE <- list(fit = fit,
            fit2 = fit2,
            da = da, 
            responsiveness= responsiveness)



# Remove unnecesary variables
rm(DE, de_proteins_list_001, de_proteins_list_005, fit, fit2, KOs_replicates, mm, sample_layout, temp, trna_ko_log, 
   yeastmine, final_protein_names, general_protein_names, i, KO, output_file, replicates, sample_name, standard_protein_names, strain_name,
   systematic_protein_names, trna_levels, unique_KOs, trna_ko)
```

## 1.5. Volcano plots for the differential expression
```{r}
# One plot per KO and save them to a PDF - for all KOs
## Come up with the list of plots
plot_list <- list()
for (i in 1:length(levels(as.factor(da$Strain.Name)))) {
  trna <- levels(as.factor(da$Strain.Name))[i]
  temp <- da %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed)) +
    geom_point() +
    geom_hline(yintercept = -log10(0.01), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-1.5, 1.5), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = trna) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "Output/Plots/Volcano_plots/DE_together/volcano_plots_per_KO_all_KOs_together.pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)


# One plot per KO and save them to a PDF - only for KOs with at least 1 DE protein
## Remove KOs with 0 DE proteins
KOs_with_DE_proteins <- responsiveness$Strain.Name[responsiveness$nDEP > 0]
da_only_KOs_with_DE_proteins <- da[da$Strain.Name %in% KOs_with_DE_proteins,]

## Come up with the list of plots
plot_list <- list()
for (i in 1:length(KOs_with_DE_proteins)) {
  trna <- KOs_with_DE_proteins[i]
  temp <- da_only_KOs_with_DE_proteins %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = trna) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "Output/Plots/Volcano_plots/DE_together/volcano_plots_per_KO_KOs_with_DE_proteins_together.pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)


# Remove unused objects
rm(list = c("my_grobs", "plot_list", "KOs_with_DE_proteins", "temp", "da_only_KOs_with_DE_proteins", "trna", "i", "output_file"))
```
--> Lots of the volcano plots are completely flat, just dots at the bottom. It would be nice if I could compare this to which are minor and which are major tRNA copies within each family actually, that would be great, but we don't have that information, do we? We have it for one family I think, I could check that, and then for the other families I would have to make the conclusions about "major" and "minor" myself precisely based on this, no?

## 1.6. Check number of DE proteins and also volcano plots for the UCU family - minor vs. major members
```{r}
# Load their phenotypic data: growth rate and growth yield for all KOs
phenotypic_data <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/bloom_ackermann_2014/phenotypic_results.tsv", sep = "")))

# Just number of DE proteins
UCU_major_minor <- phenotypic_data %>% 
  filter(UCU_family != "No") %>%
  dplyr::select(gene_name, UCU_family) %>%
  rename(Strain.Name = gene_name)

UCU_responsiveness <- responsiveness%>% filter(anticodon == "UCU")

UCU_family <- full_join(UCU_major_minor, UCU_responsiveness, by = "Strain.Name")


# Volcano plots
## Keep only KOs in UCU family
KOs_in_UCU_family <- UCU_family$Strain.Name
da_only_KOs_from_UCU_family <- da[da$Strain.Name %in% KOs_in_UCU_family,]


## Come up with the list of plots
plot_list <- list()
for (i in 1:length(KOs_in_UCU_family)) {
  trna <- KOs_in_UCU_family[i]
  plot_title <- paste(trna, UCU_family$UCU_family[UCU_family$Strain.Name == trna], sep = "_")
  temp <- da_only_KOs_from_UCU_family %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-1.5, 1.5), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = plot_title) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_location <- paste(base_dir, "Output/Plots/Volcano_plots/DE_together/volcano_plots_per_KO_UCU_family_together.pdf", sep="")
ggsave(
   filename = output_location, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)


# Remove unused objects
rm(list = c("my_grobs", "plot_list", "KOs_in_UCU_family", "temp", "da_only_KOs_from_UCU_family", "trna", "plot_title", "UCU_major_minor", "UCU_responsiveness", "i", "UCU_family", "phenotypic_data", "output_location"))
```

## 1.7. Check number of DE proteins vs. replicates per KO
```{r}
ggplot(data = responsiveness, aes(x = as.factor(Replicate_num), y = nDEP, col = as.factor(Replicate_num))) +
  geom_boxplot() +
  geom_jitter(position=position_jitter(0.2)) +
  xlab("Number of replicates")

replicate_num_vs_nDEP_cor <- cor(responsiveness$nDEP, responsiveness$Replicate_num)
replicate_num_vs_nDEP_cor

# Remove unnecessary objects
rm(replicate_num_vs_nDEP_cor)
```
--> The point with this was that maybe a larger number of replicates causes more nDEP just because it's easier to achieve significance. However, there seems to be no correlation at all, I think that's actually good because it means that the nDEP will be only influenced by what is going on with the tRNA KOs? Even though that effect could be already confounding my results in this boxplot

## 1.8. Number of DE proteins per family, coloring by number of tRNAs in the family
```{r}
responsiveness <- responsiveness %>%
  group_by(anticodon) %>% 
  mutate(n= n())

ggplot(data = responsiveness, aes(x = anticodon, y = nDEP, fill = n)) +
  geom_boxplot()

# Correlation between nDEP and tRNA family size
resp_summarized_by_family <- aggregate(responsiveness$nDEP, list(responsiveness$anticodon), mean)
colnames(resp_summarized_by_family) <- c("anticodon", "nDEP")
resp_summarized_by_family <- merge(resp_summarized_by_family, responsiveness[, c("anticodon", "n")], by = "anticodon", all.x = T)
resp_summarized_by_family <- resp_summarized_by_family %>%
  distinct(anticodon, .keep_all = T)
cor(resp_summarized_by_family$nDEP, resp_summarized_by_family$n)


# Remove unnecessary variables
rm(resp_summarized_by_family)
```
--> The boxplot is not particularly illustrative, but the correlation is pretty meaningful I think? Looks like larger families show, on average over all tRNAs in them, less DE proteins, which makes sense with their hypothesis I think? If there are a couple major tRNA genes per family, larger families are going to have a lot of minor ones, while small families will be mostly major ones. Here I am also assuming that there are only a couple major copies per family, which I don't think they said at any point? But I guess makes sense with this. 


## 1.9. Identify major and minor tRNA genes myself for all strains
Original version, general histogram and histograms per isoacceptors, coloring by anticodon
```{r}
# Histogram of avg_nDEP for each KO strain
ggplot(data = responsiveness, aes(x = nDEP)) +
  geom_histogram(binwidth = 1, color="black", fill="grey") +
  theme_light() +
  xlab("nDEP per tRNA KO") +
  ylab("Count") +
  labs(title = "Frequency of nDEP across all tRNA KO strains")

# Given this histogram, I define the threshold to make out major and minor tRNA genes - for now I have it at 2

# Define a column with "minor"-"major" based on this so that I can check how many major and minor ones there are per family (I could also do this directly based on the avg_nDEP tbh but oh well)
responsiveness<- responsiveness%>%
  mutate(Gene_type = case_when(nDEP < threshold_major ~ "Minor",
                               TRUE ~ "Major")) %>%
  group_by(anticodon) %>%
  summarize(Major_count = sum(Gene_type == "Major"), across()) %>%
  ungroup()

# Also need to count the total number of KOs I have from each family in the experiment
responsiveness<- responsiveness%>%
  group_by(anticodon) %>%
  summarize(Family_count = n(), across()) %>%
  ungroup()


# Get a dataframe with the size of each family, the number of those genes we have as KOs in the experiment, and how many of them are major, and plot this
colnames(master_dataset)[colnames(master_dataset) == "family_size"] <- "Family_size"
family_sizes <- left_join(master_dataset, responsiveness, by = "Strain.Name")
family_sizes <- family_sizes %>%
  filter(Strain.Name %in% responsiveness$Strain.Name) %>%                       # Filtered on KOd before, but that kept strains that were removed during filtering
  dplyr::select(anticodon, Family_size, Family_count, Major_count) %>%
  distinct(anticodon, .keep_all = T)


# Get long version to plot, and re-order the anticodons by family size, in order to keep that order for the x axis of the plot
family_sizes <- family_sizes[order(-family_sizes$Family_size), ]
family_sizes_long <- family_sizes %>% pivot_longer(!anticodon, names_to = "Type", values_to = "Count")
family_sizes_long$anticodon <- factor(family_sizes_long$anticodon, levels = family_sizes$anticodon)
family_sizes_long$Type <- factor(family_sizes_long$Type, levels = c("Family_size", "Family_count", "Major_count"))

colnames(family_sizes_long)[colnames(family_sizes_long) == "anticodon"] <- "Anticodon"


# Plot this
ggplot(data = family_sizes_long, aes(x = Anticodon, y = Count, fill = Type)) +
  geom_bar(position="dodge", stat="identity") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
        legend.position = "none")


# What is the relationship between Family_count and Major_count?
ggplot(data = family_sizes, aes(x = Family_count, y = Major_count)) +
  geom_point() +
  geom_abline() +
  theme_light() +
  xlab("Genes in this family in the experiment") +
  ylab("Major genes detected in the family") +
  geom_text_repel(data = subset(family_sizes, Major_count/Family_count >= 1 | Major_count/Family_count < 0.3),
                  aes(x = Family_count, y = Major_count, label = anticodon),
                  size = 4)

# Produce a single histogram like the one at the beginning of this chunk for each set of tRNA isoacceptors - and save them to a PDF
## Add amino acid full name to be used as title for each subplot
amino_acids <- as.data.frame(fread(paste(base_dir, "Data/Other/GtRNAdb/amino_acids.csv", sep=""))) %>%
  rename(Amino_acid = Name, 
         AA = X1_letter_code) %>%
  dplyr::select(Amino_acid, AA)
responsiveness <- left_join(responsiveness, amino_acids, by = "AA")


## Create empty list of plots
plot_list <- list()

## Generate the plots and add them to the list
aas <- sort(levels(as.factor(responsiveness$Amino_acid)))
for (i in 1:length(aas)) {
  aa <- aas[i]
  temp <- responsiveness%>%
    filter(Amino_acid == aa)
  plot_list[[aa]] <- ggplot(data = temp, aes(x = nDEP, fill = anticodon)) +
    geom_histogram(binwidth = 1, stat = StatBin2) +
    theme_light() +
    xlab("nDEP") +
    ylab("Count") +
    labs(title = glue("{aa}")) +
    coord_cartesian(xlim = c(0, 230))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "Output/Plots/nDEP_hists_per_isoacceptors_color_by_codon.pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)


# Remove unnecessary variables
rm(family_sizes_long, my_grobs, plot_list, temp, aa, aas, output_file, i)
```

Histograms by anticodon, color by full sequence of the tRNA molecule (both DNA and mature sequences)
```{r}
# Add columns with DNA and mature sequences to responsiveness dataframe
temp <- master_dataset %>%
  dplyr::select(Strain.Name, DNA_sequence, mature_sequence)
responsiveness <- left_join(responsiveness, temp, by = "Strain.Name")

## Create empty list of plots
plot_list_DNA_seq <- list()
plot_list_mature_seq <- list()

## Generate the plots and add them to the list
anticodons <- unique(as.character(responsiveness$anticodon))
for (i in 1:length(anticodons)) {
  my_anticodon <- anticodons[i]
  temp <- responsiveness %>%
    filter(anticodon == my_anticodon)
  
  # Color by DNA seq
  plot_list_DNA_seq[[my_anticodon]] <- ggplot(data = temp, aes(x = nDEP, col = DNA_sequence, fill = DNA_sequence)) +
    geom_histogram(binwidth = 1) +
    theme_light() +
    xlab("nDEP") +
    ylab("Count") +
    labs(title = glue("Frequency of nDEP in tRNAs with {my_anticodon}")) + 
    theme(legend.position = "none")
  
  # Color by mature seq
  plot_list_mature_seq[[my_anticodon]] <- ggplot(data = temp, aes(x = nDEP, col = mature_sequence, fill = mature_sequence)) +
    geom_histogram(binwidth = 1) +
    theme_light() +
    xlab("nDEP") +
    ylab("Count") +
    labs(title = glue("Frequency of nDEP in tRNAs with {my_anticodon}")) + 
    theme(legend.position = "none")
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs_DNA <- lapply(plot_list_DNA_seq, ggplotGrob)
my_grobs_mature <- lapply(plot_list_mature_seq, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "Output/Plots/nDEP_hists_per_anticodon_color_by_DNA_seq.pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs_DNA, nrow=4, ncol=4), 
   width = 15, height = 9
)
output_file = paste(base_dir, "Output/Plots/nDEP_hists_per_anticodon_color_by_mature_seq.pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs_mature, nrow=4, ncol=4), 
   width = 15, height = 9
)


# Save responsiveness dataframe for further use
responsiveness <- responsiveness %>%
  rename(Amino_acid_1_letter = AA)
fwrite(responsiveness, paste(base_dir, "Data/responsiveness.csv", sep=""))
```


## 1.10. Do all tRNAs with the same anticodon have exactly the same sequence throughout their whole structure?
No, they do not! Look further into this elsewhere
```{r}
num_of_tRNA_versions_DNA <- c()
num_of_tRNA_versions_mature <- c()
anticodons <- unique(master_dataset$Anticodon)
for (i in 1:length(anticodons)) {
  anticodon <- anticodons[i]
  temp <- master_dataset %>%
    filter(Anticodon == anticodon)
  num_of_tRNA_versions_DNA <- c(num_of_tRNA_versions_DNA, length(unique(temp$DNA_sequence)))
  num_of_tRNA_versions_mature <- c(num_of_tRNA_versions_mature, length(unique(temp$mature_sequence)))
}

temp <- data.frame(anticodons, num_of_tRNA_versions_DNA, num_of_tRNA_versions_mature)
```


## 1.11. Explore correlation between the number of tRNA genes for a certain amino acid (or anticodon) that couldn't be KOd, and the number of genes with that amino acid/anticodon - THIS WAS IN A DIFFERENT FILE, IN THE TSSC CODE! NOT SURE IF IT WILL RUN HERE BUT I THINK IT SHOULD
```{r}
# Plots by anticodon
master_by_anticodon <- master_dataset %>%
  distinct(Anticodon, .keep_all = T)

## Just the percentage of KOd genes per anticodon
ggplot(data = master_by_anticodon, aes(x = Anticodon, y = Perc_KOd_genes_per_anticodon)) +
  geom_point() +
  theme_light() +
  geom_text_repel(data = subset(master_by_anticodon, Perc_KOd_genes_per_anticodon < 0.7), aes(x = Anticodon, y = Perc_KOd_genes_per_anticodon, label = Anticodon)) +
  theme(axis.text.x = element_blank()) +
  labs(title = "% of tRNA-genes with each anticodon that were KOd") +
  ylab("% of genes KOd")



# Plots by amino acid - for some reason distinct() is not working???
master_by_amino_acid <- master_dataset[!duplicated(master_dataset$Isotype_from_anticodon),]

## Just the percentage of KOd genes per amino acid
ggplot(data = master_by_amino_acid, aes(x = Isotype_from_anticodon, y = Perc_KOd_genes_per_amino_acid, col = Number_of_tRNAs_loading_this_aa)) +
  geom_point() +
  theme_light() +
  geom_text_repel(data = subset(master_by_amino_acid, Perc_KOd_genes_per_amino_acid < 0.8), aes(x = Isotype_from_anticodon, y = Perc_KOd_genes_per_amino_acid, label = Isotype_from_anticodon)) +
  theme(axis.text.x = element_blank()) +
  xlab("Amino acid") +
  ylab("% of genes KOd") +
  labs(title = "% of tRNA-genes carrying each amino acid that were KOd",
       col = "Number of tRNAs\nloading this aa")

# How many tRNA genes are there for each amino acid?
ggplot(data = master_by_amino_acid, aes(x = Isotype_from_anticodon, y = Number_of_tRNAs_loading_this_aa)) +
  geom_point() +
  theme_light() +
  theme(axis.text.x = element_blank()) +
  labs(title = "Number of tRNA genes carrying each amino acid") +
  xlab("Amino acid") +
  ylab("Number of genes") +
  geom_text_repel(data = subset(master_by_amino_acid, Number_of_tRNAs_loading_this_aa < 6 | Number_of_tRNAs_loading_this_aa > 20), aes(x = Isotype_from_anticodon, y = Number_of_tRNAs_loading_this_aa, label = Isotype_from_anticodon))
```










########################################################################################
# 2. Compare to data from the literature that might explain the nDEP for each KO strain:
########################################################################################
  - tRNA expression data from Cozen et al., 2015
  - tRNA synthetase abundance data from Chu et al., 2011
  - anticodon frequency in the genome from van der Haar, 2008


## 2.1. tRNA expression data from Cozen et al., 2015
The main issue with this dataset (apart from the fact that they are read counts) is that in many rows, the counts are not assigned to a single tRNA gene, but they can come from any tRNA gene with a certain anticodon. Actually, these are the reads that come from sequencing the actual, mature tRNAs, seemingly these are very hard to differentiate. Also, there are extremely high counts for these ones, so they are pretty uninformative and make it complicated to interpret when summing them up with the read counts that are for each tRNA gene specifically (because it seems like all those that are counted together as the mature tRNA have basically the same level of expression). Hence, I decided to only use the rows which have one single tRNA identified per row, this is, the genomic rows: these are the ones where the information comes from sequencing the tRNA just after it has been trasncribed, before maturation or anything, which allows to identify exactly which gene they are coming from (all of this is kind of my interpretation, not 100% sure of it, but I think this is it). 

Load data
```{r}
# tRNa expression data from Cozen et al., 2015 - keep only genomic rows
cozen <- read.xlsx(paste(base_dir, "Data/Other/tRNA_expression_comparative/cozen_et_al_2015.xlsx", sep=""), 1) %>%
  filter(read.mapping..genomic.sequence.or.mature.tRNA. == "genomic")

# Load responsiveness dataset
responsiveness <- as.data.frame(fread(paste(base_dir, "Data/responsiveness.csv", sep="")))
```

Remove rows with NAs in relevant columns, select columns of interest, get the sum of reads per tRNA (since there are several rows for the same tRNA), and rename to merge with responsiveness dataframe
```{r}
cozen_to_merge <- cozen %>%
  filter(saccaromyces.genome.datasbase..sgd..tRNA.name != "NA" &
           mean.normalized.ReadCount..AlkB != "NA") %>%
  dplyr::select(name, tRNA.group, chromosome, chromosome.start, chromosome.end, chromosome.start,
         saccaromyces.genome.datasbase..sgd..tRNA.name, mean.normalized.ReadCount..AlkB, read.mapping..genomic.sequence.or.mature.tRNA.) %>%
  group_by(saccaromyces.genome.datasbase..sgd..tRNA.name) %>%
  mutate(mean_reads_per_tRNA = sum(as.numeric(mean.normalized.ReadCount..AlkB), na.rm = T)) %>%
  rename(Strain.Name = saccaromyces.genome.datasbase..sgd..tRNA.name)

## Merge with resp
resp_and_expression <- left_join(responsiveness, cozen_to_merge, by = "Strain.Name")
```

Plots - nDEP vs. tRNA expression from Cozen et al., 2015
```{r}
# Plot average nDEP vs. avg expression - genomic tRNA sequences
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP)) +
  geom_point() +
  theme_light() + 
  labs(title = "nDEP vs. tRNA expression") +
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")

# Same, but color by number of tRNA genes in family
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = Family_count)) +
  geom_point() +
  theme_light() + 
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")
```


## 2.2. Integrate data from tRNA synthetase abundance and tRNA abundance (Chu et al., 2011) 
Load and prepare data
```{r}
# Load data
chu_synths <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/chu_2011/S3.csv", sep="")))[1:20,] 
chu_trnas <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/chu_2011/S2.csv", sep="")))
# The problem with these abundances for tRNAs is that they are for each family, not for each tRNA concretely, so I don't really know if they will be useful to me. I could collapse those from Cozen et al. by family and compare them to this to see if they point in the same direction, but might be a bit of a time waste

# Join the synthetase data to the resp_and_expression dataset
amino_acids <- as.data.frame(fread(paste(base_dir, "Data/Other/GtRNAdb/amino_acids.csv", sep="")))

chu_synths <- left_join(chu_synths, amino_acids, by = "Amino_acid_3_letter") %>%
  rename(synthetase_abundance = Abundance)
resp_and_expression <- left_join(resp_and_expression, chu_synths, by = "Amino_acid_1_letter")

# Add also the synthetase abundance we detect in our WTs
## Remove those synthetases we didn't detect in our data, as well as GRS2 (only active under stress)
synthetases <- fread(paste(base_dir, "Data/trna_synthetases.csv", sep=""))
temp <- synthetases %>%
  filter(Gene.symbol != "GRS2",
         !is.na(measured_proteomics_WT)) %>%
  dplyr::select(Amino_acid_1_letter, measured_proteomics_WT)
  

# For the rows for each amino acid, select the limiting one, the one we detect the least of (even though I don't even know if they join 1:1 to form the complex?)
synthetases_to_merge <- data.frame(matrix(ncol = ncol(synthetases), nrow = 0))
aas <- unique(synthetases$Amino_acid_1_letter)
for (i in 1:length(aas)) {
  aa <- aas[i]
  temp_2 <- temp %>%
    filter(Amino_acid_1_letter == aa)
  temp_2 <- temp_2[which.min(temp_2$measured_proteomics_WT),]
  synthetases_to_merge <- rbind(synthetases_to_merge, temp_2)
}

resp_and_expression <- left_join(resp_and_expression, synthetases_to_merge, by = "Amino_acid_1_letter")
```

Plots - nDEP vs. tRNA expression from Cozen et al., 2015 (coloring by amino acid characteristics)
```{r}
# Plot average nDEP vs. avg expression - color by amino acid type
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = amino_acid_type)) +
  geom_point() +
  theme_light() + 
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")

# Plot average nDEP vs. avg expression - color by amino acid charge
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = amino_acid_charge)) +
  geom_point() +
  theme_light() + 
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")

# Plot average nDEP vs. avg expression - color by amino acid weight
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = molecular_weight)) +
  geom_point() +
  theme_light() + 
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")
```

Plots - tRNA expression from Cozen et al., 2015 vs. tRNA synthetase abundance from Chu et al., 2011
```{r}
# tRNA abundance from Cozen et al., vs. log2 tRNA synthetase abundance from Chu et al.
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA)) +
  geom_point() +
  theme_light()

# Same, but color by major and minor based on our proteomics
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA, col = Gene_type)) +
  geom_point() +
  theme_light()

# Plot average nDEP vs. avg expression, but color by tRNA synthetase abundance from Chu et al.
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = synthetase_abundance)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid type
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA, col = amino_acid_type)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid charge
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA, col = amino_acid_charge)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid weight
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA, col = molecular_weight)) +
  geom_point() +
  theme_light()
```

Plots - nDEP vs. synthetase abundance
```{r}
# nDEP vs. synthetase abundance
ggplot(data = resp_and_expression, aes(x = synthetase_abundance, y = nDEP)) +
  geom_point()

# nDEP vs. log2-synthetase abundance
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance") +
  xlab("log2-tRNA synthetase abundance (from von der Haar, 2008)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by family size
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = Family_count)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by chromosome
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = chromosome.y)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid type
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = amino_acid_type)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid charge
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = amino_acid_charge)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid weight
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = molecular_weight)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")
```

Plots - nDEP vs. synthetase k_cat
```{r}
# nDEP vs. log2-synthetase k_cat
ggplot(data = resp_and_expression, aes(x = log2(k_cat_value), y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. log2(synthetase catalytic constant)") +
  xlab(bquote(log2-k["cat"]))

# The synthetases for W seem to have a k_cat more than 10x those of other amino acids, so I am going to get rid of that one then repeat the plot
ggplot(data = resp_and_expression, aes(x = k_cat_value, y = nDEP)) +
  geom_point() +
  theme_light() +
  coord_cartesian(xlim = c(0, 150))

# Not really a pattern I think, let's try synthetase abundance*k_cat
ggplot(data = resp_and_expression, aes(x = k_cat_value*synthetase_abundance, y = nDEP)) +
  geom_point() +
  theme_light() +
  coord_cartesian(xlim = c(0, 500000))
```



## 2.3. Add information about codon frequency as well
Load and prepare data
```{r}
# Get anticodon from codon and rename columns
anticodon_freq <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/chu_2011/S1.csv", sep="")))
anticodon_freq$anticodon <- lapply(anticodon_freq[,colnames(anticodon_freq) == "Codon"], codon_to_anticodon)
anticodon_freq$anticodon <- as.character(anticodon_freq$anticodon)
anticodon_freq$anticodon <- as.factor(anticodon_freq$anticodon)
anticodon_freq <- anticodon_freq %>%
  rename(codon_frequency_chu_2011 = Frequency)

# Merge to resp_and_expression
resp_and_expression <- left_join(resp_and_expression, anticodon_freq, by = "anticodon")
```

Plots - nDEP vs. codon frequency (from van der Haar, 2008)
```{r}
# Codon frequency vs. nDEP
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency") +
  xlab("Codon frequency (from van der Haar, 2008)") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by tRNA abundance from Cozen et al.
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = mean_reads_per_tRNA)) +
  geom_point() +
  theme_light() +
  xlab("Codon frequency (from van der Haar, 2008)") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by log2 tRNA synthetase abundance from Chu et al.
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = log2(synthetase_abundance))) +
  geom_point() +
  theme_light() +
  xlab("Codon frequency (from van der Haar, 2008)") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by family size
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = Family_count)) +
  geom_point() +
  theme_light() +
  xlab("Codon frequency (from van der Haar, 2008)") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by amino acid type
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = amino_acid_type)) +
  geom_point() +
  theme_light() +
  xlab("Codon frequency (from van der Haar, 2008)") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by amino acid charge
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = amino_acid_charge)) +
  geom_point() +
  theme_light() +
  xlab("Codon frequency (from van der Haar, 2008)") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by amino acid weight
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = molecular_weight)) +
  geom_point() +
  theme_light() +
  xlab("Codon frequency (from van der Haar, 2008)") +
  ylab("nDEP per tRNA KO")
```


## 2.4. Plots regarding family size and so on, from 1.11., but I want to color by variables only introduced here
```{r}
# Family_count vs. major_count, as in 1.11., but color by amino acid carried - TODO
temp <- resp_and_expression %>%
  dplyr::select(anticodon, AA)
temp_2 <- left_join(family_sizes, temp, by = "anticodon") %>%
  distinct(anticodon, .keep_all = T)

ggplot(data = temp_2, aes(x = Family_count, y = Major_count, col = AA)) +
  geom_point() +
  geom_abline() +
  theme_light() +
  xlab("Genes in this family in the experiment") +
  ylab("Major genes detected in the family") +
  geom_text_repel(data = subset(temp_2, Major_count/Family_count == 1 | Major_count/Family_count < 0.3),
                  aes(x = Family_count, y = Major_count, label = anticodon),
                  size = 4, 
                  max.overlaps = 100)

# Same, but use in the y axis the % of major tRNAs instead of the count
ggplot(data = temp_2, aes(x = Family_count, y = Major_count/Family_count)) +
  geom_point() +
  geom_smooth(method='lm') +
  theme_light() +
  xlab("Genes in this family in the study") +
  ylab("% of major genes detected in the family") +
  geom_text_repel(data = subset(temp_2, Major_count/Family_count >= 1 | Major_count/Family_count < 0.3| anticodon == "CAA"),
                  aes(x = Family_count, y = Major_count/Family_count, label = anticodon, col = AA),
                  size = 4)

# Same, but use in the y axis the % of major tRNAs instead of the count, and color by aa
ggplot(data = temp_2, aes(x = Family_size, y = Major_count/Family_count)) +
  geom_point() +
  geom_smooth(method='lm') +
  theme_light() +
  xlab("Genes in this family in total") +
  ylab("% of major genes detected in the family") +
  geom_text_repel(data = subset(temp_2, Major_count/Family_count >= 1 | Major_count/Family_count < 0.3 | anticodon == "CAA"),
                  aes(x = Family_size, y = Major_count/Family_count, label = anticodon, col = AA),
                  size = 4)
```


## 2.5. Save the resp_and_expression dataset as it is at this point, can be useful later in other files
```{r}
fwrite(resp_and_expression, paste(base_dir, "Data/resp_and_expression.csv", sep=""))
```




################################################################################
# 3. Modelling
################################################################################
## 3.0. Load data - so I don't have to run everything above
```{r}
resp_and_expression <- as.data.frame(fread(paste(base_dir, "Data/resp_and_expression.csv", sep="")))
```

## 3.1. Model the data with a GLM instead
Poisson
```{r}
# Poisson model
fit <- glm(data = resp_and_expression,
           formula = nDEP ~ synthetase_abundance*k_cat_value*codon_frequency_chu_2011,
           family = poisson)
summary(fit)

# Check overdispersion - seems like there is, unsurprisingly
check_overdispersion(fit)

# Actually in the fit for the Poisson model we can already get an idea of if there is overdispersion or not: we do this by looking at the residual deviance and at the corresponding degrees of freedom, if the ratio between them is roughly 1, there is no overdispersion. If it is larger, there is overdispersion. So yeah, we see that we indeed have it here. 
```

Negative binomial - with 3 variables
```{r}
fit <- glm.nb(data = resp_and_expression, 
              formula = nDEP ~ synthetase_abundance*k_cat_value*codon_frequency_chu_2011)
summary(fit)

# Check overdispersion
check_overdispersion(fit)
```

Negative binomial - with 4 variables
```{r}
resp_and_expression_modelling <- resp_and_expression %>%
  dplyr::rename(catalytic_constant = k_cat_value,
         condon_frequency = codon_frequency_chu_2011,
         tRNA_expression = mean_reads_per_tRNA)

fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance*catalytic_constant*condon_frequency*tRNA_expression)
summary(fit)

# Check overdispersion
check_overdispersion(fit)
```

Negative binomial - with 4 variables - remove strains below certain numbers of nDEPs
```{r}
resp_and_expression_modelling <- resp_and_expression %>%
  dplyr::rename(catalytic_constant = k_cat_value,
         condon_frequency = codon_frequency_chu_2011,
         tRNA_expression = mean_reads_per_tRNA)

# nDEP > 0
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 0)

fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance*catalytic_constant*condon_frequency*tRNA_expression)
summary(fit)

# Check overdispersion
check_overdispersion(fit)


# nDEP > 1
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 1)

fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance*catalytic_constant*condon_frequency*tRNA_expression)
summary(fit)

# Check overdispersion
check_overdispersion(fit)


# nDEP > 2
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 2)

fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance*catalytic_constant*condon_frequency*tRNA_expression)
summary(fit)

# Check overdispersion
check_overdispersion(fit)


# nDEP > 3
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 3)

fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance*catalytic_constant*condon_frequency*tRNA_expression)
summary(fit)

# Check overdispersion
check_overdispersion(fit)


# nDEP > 4
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 4)

fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance*catalytic_constant*condon_frequency*tRNA_expression)
summary(fit)

# Check overdispersion
check_overdispersion(fit)


# nDEP > 5
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 5)

fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance*catalytic_constant*condon_frequency*tRNA_expression)
summary(fit)

# Check overdispersion
check_overdispersion(fit)


# nDEP > 10
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 10)

fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance*catalytic_constant*condon_frequency*tRNA_expression)
summary(fit)

# Check overdispersion
check_overdispersion(fit)
```




################################################################################
# 4. Evaluate codon enrichment in DEPs sequences
################################################################################
SHOULD I CONSIDER SOME GROUPING BY CODON HERE? LIKE, THE DIFFERENT TRNAS THAT HAVE THE SAME CODON?
Load data (generated in Python script "check_codon_enrichment_in_DEPs_sequences.py")
```{r}
# Load list
codon_ratios_list <- fromJSON(paste(base_dir, "Data/Other/check_codon_enrichment_in_protein_sequences/codon_counts.json", sep=""))

# Remove from the list those strains where there aren't at least 4 DE proteins
bool <- c()
for (i in 1:length(codon_ratios_list)) {
  bool <- c(bool, length(codon_ratios_list[[i]][["DE"]]) > 4)
}
codon_ratios_list <- codon_ratios_list[bool]
```

Iterate over the strains and perform a test for each, testing the mean counts of DE vs. that of non_DE
```{r}
strains <- names(codon_ratios_list)
p.values_wmw <- c()
mean_de <- c()
mean_non_de <- c()
num_de <- c()
num_non_de <- c()
for (i in 1:length(codon_ratios_list)) {
  # Grab data for this strain
  strain_name <- names(codon_ratios_list)[i]
  de <- codon_ratios_list[[strain_name]][["DE"]]
  non_de <- codon_ratios_list[[strain_name]][["non_DE"]]
  de_df <- data.frame(codon_ratios_list[[strain_name]][["DE"]])
  non_de_df <- data.frame(codon_ratios_list[[strain_name]][["non_DE"]])
  
  # Plot overlapping histograms - not worth it I think
  ggplot() +
    geom_histogram(data = de_df, aes(x = log2(codon_ratios_list..strain_name.....DE...)), fill = "red", alpha = 0.9) +
    geom_histogram(data = non_de_df, aes(x = log2(codon_ratios_list..strain_name.....non_DE...)), fill = "orange", alpha = 0.4)
  
  # Test - WMW
  p.values_wmw <- c(p.values_wmw, wilcox.test(de, non_de)$p.value)
  
  # Test - log2 transform (need to take care of 0s) and use t-test - is this worth doing?
  
  
  # Save the mean of each group to the output vectors as well
  mean_de <- c(mean_de, mean(de))
  mean_non_de <- c(mean_non_de, mean(non_de))
  
  # Save the number of proteins in each of the two groups - probably will explain the significance bc of low power with small DE protein counts
  num_de <- c(num_de, length(de))
  num_non_de <- c(num_non_de, length(non_de))
}

p.values.adj <- p.adjust(p.values_wmw, method = "fdr")

test_codon_enrichment <- data.frame(Strain.Name = strains, p.values_wmw, p.values.adj, mean_de, mean_non_de, num_de, num_non_de) %>%
  mutate(direction = case_when(mean_de > mean_non_de ~ "DE",
                               TRUE ~ "non_DE"),
         FC = mean_de/mean_non_de)

# Get the logFC - need to deal with the negative values in the FC - there is definitely a better way to do this but oh well
logFC <- c()
for (i in 1:nrow(test_codon_enrichment)) {
  FC <- test_codon_enrichment$FC[i]
  if (FC < 1) {
    out <- -log10(abs(FC))
  }
  else if (FC > 1) {
    out <- log10(FC)
  }
  else if (FC == 0) {
    out <- 0
  }
  logFC <- c(logFC, out)
}
test_codon_enrichment$logFC <- log10(test_codon_enrichment$FC)


# Remove unnecessary variables
rm(bool, strains, p.values_wmw, mean_de, mean_non_de, p.values.adj, logFC, FC, out, num_de, num_non_de)
```

Add some information to this plot to be able to color plots by it (amino acid, codon, etc.)
```{r}
temp <- master_dataset %>%
  dplyr::select(Strain.Name, Anticodon, Best_isotype_model_1_letter, Family_size) %>%
  rename(AA = Best_isotype_model_1_letter)
test_codon_enrichment <- left_join(test_codon_enrichment, temp, by = "Strain.Name")

temp <- resp_and_expression %>%
  dplyr::select(Strain.Name, codon_frequency_chu_2011)
test_codon_enrichment <- left_join(test_codon_enrichment, temp, by = "Strain.Name")
rm(temp)
```

"Volcano plot"
```{r}
# Basic volcano plot - FC vs. -log10(adj.p-value) - tag only significant p-values and FCs
ggplot(data = test_codon_enrichment, aes(x = FC, y = -log10(p.values.adj))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = 1.5, col = "red") +
  theme_light() +
  geom_text_repel(data = subset(test_codon_enrichment, (((FC < 0.5 | FC > 1.5) & -log10(p.values.adj) > -log10(0.05)))|-log10(p.values.adj) > -log10(0.05)),
                  aes(x = FC, y = -log10(p.values.adj), label = Strain.Name))

# Basic volcano plot - FC vs. -log10(adj.p-value) - tag all significant FCs
ggplot(data = test_codon_enrichment, aes(x = FC, y = -log10(p.values.adj))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = 1.5, col = "red") +
  theme_light() +
  geom_text_repel(data = subset(test_codon_enrichment, FC < 0.5 | FC > 1.5), 
                  aes(x = FC, y = -log10(p.values.adj), label = Strain.Name))

# Color by count of DE proteins
ggplot(data = test_codon_enrichment, aes(x = FC, y = -log10(p.values.adj), col = num_de)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = 1.5, col = "red") +
  theme_light()

# Color by family
ggplot(data = test_codon_enrichment, aes(x = FC, y = -log10(p.values.adj), col = Anticodon)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = 1.5, col = "red") +
  theme_light()

# Color by family size
ggplot(data = test_codon_enrichment, aes(x = FC, y = -log10(p.values.adj), col = Family_size)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = 1.5, col = "red") +
  theme_light()

# Color by amino acid
ggplot(data = test_codon_enrichment, aes(x = FC, y = -log10(p.values.adj), col = AA)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = 1.5, col = "red") +
  theme_light()

# Color by codon frequency
ggplot(data = test_codon_enrichment, aes(x = FC, y = -log10(p.values.adj), col = codon_frequency_chu_2011)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = 1.5, col = "red") +
  theme_light()
```

What if I plot nDEP against the FC of the previous plot?
```{r}
ggplot(data = test_codon_enrichment, aes(x = num_de, y = FC)) +
  geom_point() +
  theme_light()

hist(test_codon_enrichment$FC)
```





################################################################################
# 5. Look for the expression of the tRNA synthetases in my proteomics data
################################################################################
## 5.0. Load data
```{r}
# Processed KO proteomics dataframe
trna_ko <- as.data.frame(as.matrix(fread(paste(base_dir, "Data/Other/proteomics_data/processed_proteomics_dataframe.tsv", sep="")), rownames = 1))

# List of dataframes with the proteins that were DE in each KO strain - at alpha = 0.01
de_proteins_list_001 <- fromJSON(paste(base_dir, "Data/Other/enrichment_analysis/de_proteins_list_001.json", sep=""))

## Remove WT dataframe
de_proteins_list_001 <- de_proteins_list_001[names(de_proteins_list_001) != "WT"]

# List of dataframes with the proteins that were DE in each KO strain - at alpha = 0.05
de_proteins_list_005 <- fromJSON(paste(base_dir, "Data/Other/enrichment_analysis/de_proteins_list_005.json", sep=""))

## Remove WT dataframe
de_proteins_list_005 <- de_proteins_list_005[names(de_proteins_list_005) != "WT"]

# Synthetase information
chu_synths <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/chu_2011/S3.csv", sep="")))[1:20,] 

# Yeastmine
yeastmine <- as.data.frame(fread(paste(base_dir, "Data/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))

# Before I match standard to systematic names, I need to extend the rows with multiple standard names into several rows, each with one of the systematic names, since they are all meaningful and different
chu_synths_new <- data.frame(matrix(ncol = ncol(chu_synths), nrow = 0))
colnames(chu_synths_new) <- colnames(chu_synths)
for (i in 1:nrow(chu_synths)) {
  std_name <- chu_synths$Synthetase[i]
  if (grepl("/", std_name)) {
    std_names <- str_split_1(std_name, "/")
    for (j in 1:length(std_names)) {
      new_row <- chu_synths[i, ]
      new_row$Synthetase[1] <- std_names[j]
      chu_synths_new <- rbind(chu_synths_new, new_row)
    }
  }
  else {
    new_row <- chu_synths[i,]
    chu_synths_new <- rbind(chu_synths_new, new_row)
  }
}
chu_synths_new <- chu_synths_new %>%
  rename(gene_names = Synthetase)


# Get a column with systematic gene names in the synthetase dataframe (they only have the standard naming)
chu_synths_new <- match_systematic_and_standard_protein_names(data = chu_synths_new,
                                                              yeastmine = yeastmine,
                                                              input = "standard", 
                                                              simplify = F, 
                                                              add_extra_columns = F)
```


## 5.1. Evaluate some basic stuff about synthetases: how many are there, how many do I detect, etc.
Create the dataframe with all information about synthetase - not save it yet since we need to add the information of how much of each of them we detect in our WTs
```{r}
# Load YeastMine dataset
yeastmine <- as.data.frame(fread(paste(base_dir, "Data/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))

# Subset this into a new dataframe with only info of tRNA synthases/synthetases (remove "kinase" because there is one that says "tRNA synthase-associated kinase")
synthetases <- yeastmine[(grepl("trna synthase", yeastmine$Gene.name, ignore.case = T)|grepl("trna synthetase", yeastmine$Gene.name, ignore.case = T)) &
                           !grepl("kinase", yeastmine$Gene.name, ignore.case = T),]

# Add a column with information on:
#   - Whether each synthetase is mitochondrial or not 
#   - Whether it is a synthase or a synthetase
#   - Whether it is the actual enzyme or a cofactor
synthetases <- synthetases %>%
  mutate(mitochondrial = case_when(grepl("mitochondrial", Gene.name, ignore.case = T) ~ "Yes",
                                   TRUE ~ "No"),
         type = case_when(grepl("synthase", Gene.name, ignore.case = T) ~ "synthase",
                          grepl("synthetase", Gene.name, ignore.case = T) ~ "synthetase"),
         cofactor_or_enzyme = case_when(grepl("cofactor", Gene.name, ignore.case = T) ~ "cofactor",
                                        TRUE ~ "enzyme"))

# Merge this with the k_cat and other synthetase info from van der Haar et al., 2008
check <- left_join(synthetases, chu_synths_new, by = "Gene.secondaryIdentifier") %>%
  dplyr::select(-Gene.briefDescription)

# Try to get a column with the amino acid that is loaded by each synthetase based on chu_synths_new
temp <- chu_synths_new %>%
  dplyr::select(Amino_acid, Gene.secondaryIdentifier)
synthetases <- left_join(synthetases, temp, by = "Gene.secondaryIdentifier")

# Some of them need to be added manually because they are not included in chu_synths_new (got them from SGD myself)
synthetases$Amino_acid[synthetases$Gene.symbol == "GRS2"] <- "Gly"
synthetases$Amino_acid[synthetases$Gene.symbol == "ISM1"] <- "Ile"
synthetases$Amino_acid[synthetases$Gene.symbol == "MSR1"] <- "Arg"
synthetases$Amino_acid[synthetases$Gene.symbol == "MST1"] <- "Thr"
synthetases$Amino_acid[synthetases$Gene.symbol == "MSW1"] <- "Trp"
synthetases$Amino_acid[synthetases$Gene.symbol == "MSM1"] <- "Met"
synthetases$Amino_acid[synthetases$Gene.symbol == "MSK1"] <- "Lys"
synthetases$Amino_acid[synthetases$Gene.symbol == "MSE1"] <- "Glu"
synthetases$Amino_acid[synthetases$Gene.symbol == "MSY1"] <- "Tyr"
synthetases$Amino_acid[synthetases$Gene.symbol == "MSD1"] <- "Asp"
synthetases$Amino_acid[synthetases$Gene.symbol == "MSF1"] <- "Phe"

synthetases <- synthetases %>%
  dplyr::select(-Gene.briefDescription)
```

Check how many synthetases there are
```{r}
# How many tRNA synthases
sum(grepl("trna synthase", synthetases$Gene.name, ignore.case = T))

# How many tRNA synthetases 
sum(grepl("trna synthetase", synthetases$Gene.name, ignore.case = T))

# How many are mitochondrial?
sum(grepl("mitochondrial", synthetases$Gene.name, ignore.case = T))
```

Check how many of them we detect in our dataset
```{r}
# Get all the proteins we detect into systematic notation
detected_proteins <- match_systematic_and_standard_protein_names(data = rownames(trna_ko),
                                                                 yeastmine = yeastmine,
                                                                 input = "standard",
                                                                 simplify = T)

# See how many tRNA synthetases are in there: 18, 67% of them
sum(detected_proteins %in% synthetases$Gene.secondaryIdentifier)
sum(detected_proteins %in% synthetases$Gene.secondaryIdentifier)/length(unique(synthetases$Gene.secondaryIdentifier))

# Check which ones: only 1 is mitochondrial, all others are cytosolic - so I think we are mainly interested in cytosolic, we detect 17 of the 18 there are, the one we don't detect is YPL040C
synths_detected <- synthetases[synthetases$Gene.secondaryIdentifier %in% detected_proteins,]
sum(synths_detected$mitochondrial == "Yes")
sum(synthetases$mitochondrial == "No")
temp <- synthetases$Gene.secondaryIdentifier[synthetases$mitochondrial == "No"]
synthetases$Gene.secondaryIdentifier[!(synthetases$Gene.secondaryIdentifier %in% synths_detected$Gene.secondaryIdentifier) & (synthetases$mitochondrial == "No")]
```

Check how much of each we detect across WTs, add that information to the dataset and save the dataset
```{r}
# Prepare
WTs <- trna_ko[, grepl("WT", colnames(trna_ko))]
rownames(WTs) <- match_systematic_and_standard_protein_names(as.character(rownames(WTs)),
                                                             yeastmine = yeastmine, 
                                                             input = "standard",
                                                             simplify = T)

# Actually check and save it to a new column in the dataframe
measured_proteomics <- c()
for (i in 1:nrow(synthetases)) {
  synth <- synthetases$Gene.secondaryIdentifier[i]
  if (synth %in% rownames(WTs)) {
    measured_proteomics <- c(measured_proteomics, mean(as.numeric(WTs[rownames(WTs) == synth,]), na.rm = T))
    hist(as.numeric(WTs[rownames(WTs) == synth,]))
  }
  else {
    measured_proteomics <- c(measured_proteomics, NA)
  }
}
synthetases$measured_proteomics_WT <- measured_proteomics


# Fix the names of the amino acid columns
synthetases <- synthetases %>%
  rename(Amino_acid_3_letter = Amino_acid)
temp <- fread(paste(base_dir, "Data/Other/GtRNAdb/amino_acids.csv", sep="")) %>%
  dplyr::select(-molecular_weight)
synthetases <- left_join(synthetases, temp, by = "Amino_acid_3_letter")


# Save this dataset
fwrite(synthetases, paste(base_dir, "Data/trna_synthetases.csv", sep=""))
```



## 5.2. Go over the KO strains and see if any of the synthetases are DE in any of them
At alpha = 0.01
```{r}
de_synthetases_001 <- list()
for (i in 1:length(de_proteins_list_001)) {
  de_proteins <- de_proteins_list_001[[i]]
  temp <- de_proteins[de_proteins %in% chu_synths_new$Gene.secondaryIdentifier]
  if (length(temp) > 0) {
    de_synthetases_001[[names(de_proteins_list_001)[i]]] <- temp
  }
}

# Get a table summarizing this
temp <- unlist(de_synthetases_001)
sort(table(temp))

# Remove unnecessary variables
rm(de_proteins, temp)
```

At alpha = 0.05
```{r}
de_synthetases_005 <- list()
for (i in 1:length(de_proteins_list_005)) {
  de_proteins <- de_proteins_list_005[[i]]
  temp <- de_proteins[de_proteins %in% chu_synths_new$Gene.secondaryIdentifier]
  if (length(temp) > 0) {
    de_synthetases_005[[names(de_proteins_list_005)[i]]] <- temp
  }
}

# Get a table summarizing this
temp <- unlist(de_synthetases_005)
sort(table(temp))

# Remove unnecessary variables
rm(de_proteins, temp)
```


## 5.3. Use the information obtained in the previous chunk, of which synthetases are DE in which KO strains, to capture the information from those genes in those strains
```{r}
grab_de_synthetases_dfs <- function(da_full, de_synthetases, yeastmine) {
  de_synthetases_dfs <- list()
  for (i in 1:length(da_full)) {
    strain_name <- names(da_full)[[i]]
    strains_with_de_synths <- names(de_synthetases)
    if (strain_name %in% strains_with_de_synths) {
      temp <- da_full[[i]]
      rownames(temp) <- match_systematic_and_standard_protein_names(data = rownames(temp),
                                                                       yeastmine = yeastmine,
                                                                       input = "standard",
                                                                       simplify = T) 
      temp <- temp[rownames(temp) %in% de_synthetases[[strain_name]],]
      temp$Synthetase <- rownames(temp)
      temp$Strain.Name <- strain_name
      de_synthetases_dfs[[strain_name]] <- temp
    }
  }
  
  # Turn the resulting list into a single dataframe
  de_synthetases_df <- bind_rows(de_synthetases_dfs)
  rownames(de_synthetases_df) <- NULL
  
  # Add a column with the standard names for the tRNA synthetase genes
  temp <- match_systematic_and_standard_protein_names(data = as.character(de_synthetases_df$Synthetase),
                                                      yeastmine = yeastmine, 
                                                      input = "systematic",
                                                      simplify = T)
  de_synthetases_df$Synthetase_standard <- temp
  de_synthetases_df <- de_synthetases_df %>%
    rename(Synthetase_systematic = Synthetase)
  
  return(de_synthetases_df)
}


da <- read_json(path=paste(base_dir, "Data/Other/enrichment_analysis/da.json", sep=""), simplifyVector = T)

de_synthetases_df_001 <- grab_de_synthetases_dfs(da, de_synthetases_001, yeastmine)
de_synthetases_df_005 <- grab_de_synthetases_dfs(da, de_synthetases_005, yeastmine)
```

Add 2 columns: one for the amino acid which the KOd tRNA carries, another for the the amino acid that is loaded by the synthetase found to be DE
```{r}
add_2_columns <- function(de_synthetases_df) {
  # Amino acid carried by the KOd tRNA
  temp <- master_dataset %>%
    dplyr::select(Strain.Name, Isotype_from_anticodon_1_letter)
  de_synthetases_df <- left_join(de_synthetases_df, temp, by = "Strain.Name") %>%
    rename(AA = Isotype_from_anticodon_1_letter)
  
  temp <- amino_acids %>%
    dplyr::select(AA, amino_acid_charge, amino_acid_type) %>%
    rename(AA_charge_tRNA = amino_acid_charge,
           AA_type_tRNA = amino_acid_type)
  de_synthetases_df <- left_join(de_synthetases_df, temp, by = "AA") %>%
    rename(AA_carried_by_tRNA = AA)
  
  # Amino acid loaded by the synthetase
  temp <- amino_acids %>%
    dplyr::select(Amino_acid, AA, amino_acid_charge, amino_acid_type) %>%
    rename(AA_loaded_by_synthetase = AA,
           AA_charge_synth = amino_acid_charge,
           AA_type_synth = amino_acid_type)
  
  temp_2 <- left_join(chu_synths_new, temp, by = "Amino_acid") %>%
    dplyr::select(Gene.secondaryIdentifier, AA_charge_synth, AA_type_synth) %>%
    rename(Synthetase = Gene.secondaryIdentifier)
  
  temp_3 <- temp_2 %>%
    group_by(Synthetase) %>%
    summarise(text=paste(AA_charge_synth, collapse = ",")) %>%
    rename(AA_charge_synth = text,
           Synthetase_systematic = Synthetase)
  
  temp_4 <- temp_2 %>%
    group_by(Synthetase) %>%
    summarise(text=paste(AA_type_synth, collapse = ",")) %>%
    rename(AA_type_synth = text,
           Synthetase_systematic = Synthetase)
  
  de_synthetases_df <- left_join(de_synthetases_df, temp_3, by = "Synthetase_systematic")
  de_synthetases_df <- left_join(de_synthetases_df, temp_4, by = "Synthetase_systematic")
  
  temp <- left_join(chu_synths_new, temp, by = "Amino_acid") %>%
    dplyr::select(Gene.secondaryIdentifier, AA_loaded_by_synthetase) %>%
    rename(Synthetase = Gene.secondaryIdentifier) %>%
    group_by(Synthetase) %>%
    summarise(text=paste(AA_loaded_by_synthetase, collapse = ",")) %>%
    rename(AA_loaded_by_synthetase = text,
           Synthetase_systematic = Synthetase)
  de_synthetases_df <- left_join(de_synthetases_df, temp, by = "Synthetase_systematic") %>%
    rename()
  
  return(de_synthetases_df)
}

amino_acids <- as.data.frame(fread(paste(base_dir, "Data/Other/GtRNAdb/amino_acids.csv", sep=""))) %>%
  rename(Amino_acid = X3_letter_code, 
         AA = X1_letter_code)

de_synthetases_df_001 <- add_2_columns(de_synthetases_df_001)
de_synthetases_df_005 <- add_2_columns(de_synthetases_df_005)


# Remove unnecessary variables
rm(chu_synths, chu_synths_new, de_proteins_list_001, de_proteins_list_005, new_row, trna_ko, yeastmine,
   std_name, std_names, i, j, check, detected_proteins, de_synthetases_001, de_synthetases_005,
   grab_de_synthetases_dfs, da, amino_acids, add_2_columns, synths_detected)
```


## 5.4. Check how many synthetases we have TS alleles for in the Boone library
There are 11 of them, none of them mitochondrial, none of them the ARC1 cofactor, one of them a synthase
```{r}
if (working_from == "charite") {
  ts_library <- as.data.frame(fread("C:/MyStuff/TSSC/Data/Growth/Mine/Processed_by_them/growth_agar_matched.tsv"))
} else if (working_from == "home") {
  ts_library <- as.data.frame(fread("/home/alvaro/MyStuff/TSSc/Data/Growth/Mine/Processed_by_them/growth_agar_matched.tsv"))
}

ts_library_synths <- ts_library[ts_library$Systematic_name %in% synthetases$Gene.secondaryIdentifier,]
synths_in_ts_library_info <- synthetases[synthetases$Gene.secondaryIdentifier %in% ts_library$Systematic_name,] 
```


## 5.5. Save the dataframes with the information on the DE synthetases and remove everything
```{r}
# Save them
fwrite(de_synthetases_df_001, paste(base_dir, "Data/Other/synthetases/de_synthetases_df_001.tsv", sep=""))
fwrite(de_synthetases_df_005, paste(base_dir, "Data/Other/synthetases/de_synthetases_df_005.tsv", sep=""))

# Remove everything
rm(de_synthetases_df_001, de_synthetases_df_005, ts_library, synths_in_ts_library_info, ts_library_synths, synthetases)
```







######################################################################################
# 6. Check if different KOs with the same anticodon cause the same proteins to be DE
######################################################################################
## 6.0. Load data
```{r}
# List of dataframes with the proteins that were DE in each KO strain - at alpha = 0.01
de_proteins_list_001 <- fromJSON(paste(base_dir, "Data/Other/enrichment_analysis/de_proteins_list_001.json", sep=""))

## Remove WT dataframe
de_proteins_list_001 <- de_proteins_list_001[names(de_proteins_list_001) != "WT"]

# Load responsiveness dataset
responsiveness <- as.data.frame(fread(paste(base_dir, "Data/responsiveness.csv", sep="")))
```


## 6.1. Get Jaccard index heatmaps - KOs with no DEPs are ignored here, not included in the plots!
Heatmaps by anticodon - without NAs
```{r}
# Preparations: remove KOs with 0 DE proteins from list, grab anticodon names, create empty list to put Jaccard index matrices there
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list_001)
anticodons <- unique(responsiveness$anticodon)
jaccard_matrices_list <- list()

# Iterate over the anticodons and get a Jaccard index matrix for each of them
for (i in 1:length(anticodons)) {
  # For each anticodon, grab the tRNAs that contain it, and get a matrix with the Jaccard index across them
  anticodon <- anticodons[i]
  KOs_with_anticodon <- names(de_protein_list)[grepl(anticodon, names(de_protein_list))]
  
  # This is so I don't end up with matrices with a single cell
  if (length(KOs_with_anticodon) > 1) {
    jaccard_matrix <- get_jaccad_index_matrix(de_protein_list, KOs_with_anticodon)
    jaccard_matrices_list[[anticodon]] <- jaccard_matrix
  }
}

# Iterate over the Jaccard index matrices and get a heatmap from each of them
plot_list <- list()
for (i in 1:length(jaccard_matrices_list)) {
  anticodon <- names(jaccard_matrices_list)[i]
  mat <- jaccard_matrices_list[[i]]
  melt_mat <- melt(mat)
  plot_list[[i]] <- ggplot(melt_mat, aes(Var1, Var2)) +
                      geom_tile(aes(fill = value), colour = "white") +
                      scale_fill_gradient(low = "white", high = "red") +
                      xlab("") +
                      ylab("") +
                      labs(title = glue("Jaccard index heatmap - anticodon {anticodon}")) +
                      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
}

my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file <- paste(base_dir, "Output/Plots/compare_DEPs_across_KOs/Jaccard_index_heatmaps_per_anticodon_no_NAs.pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=3, ncol=3), 
   width = 15, height = 9
)


# Remove unnecessary variables
rm(anticodons, jaccard_matrices_list, anticodon, KOs_with_anticodon, jaccard_matrix, plot_list, my_grobs, output_file)
```

Heatmaps by amino acid - without NAs
```{r}
# Preparations: remove KOs with 0 DE proteins from list, grab anticodon names, create empty list to put Jaccard index matrices there
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list_001)
amino_acids <- unique(responsiveness$AA)
jaccard_matrices_list <- list()

# Iterate over the amino acids and get a Jaccard index matrix for each of them
for (i in 1:length(amino_acids)) {
  # For each amino acid, grab the tRNAs that carry it, and get a matrix with the Jaccard index across them
  aa <- amino_acids[i]
  strain_names <- unique(responsiveness$Strain.Name[responsiveness$AA == aa])
  KOs_with_amino_acid <- names(de_protein_list)[names(de_protein_list) %in% strain_names]
  
  # This is so I don't end up with matrices with a single cell
  if (length(KOs_with_amino_acid) > 1) {
    jaccard_matrix <- get_jaccad_index_matrix(de_protein_list, KOs_with_amino_acid)
    jaccard_matrices_list[[aa]] <- jaccard_matrix
  }
}

# Iterate over the Jaccard index matrices and get a heatmap from each of them
plot_list <- list()
for (i in 1:length(jaccard_matrices_list)) {
  aa <- names(jaccard_matrices_list)[i]
  mat <- jaccard_matrices_list[[i]]
  melt_mat <- melt(mat)
  plot_list[[i]] <- ggplot(melt_mat, aes(Var1, Var2)) +
                      geom_tile(aes(fill = value), colour = "white") +
                      scale_fill_gradient(low = "white", high = "red") +
                      xlab("") +
                      ylab("") +
                      labs(title = glue("Jaccard index heatmap - amino acid: {aa}")) +
                      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
}

my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file <- paste(base_dir, "Output/Plots/compare_DEPs_across_KOs/Jaccard_index_heatmaps_per_amino_acid_no_NAs.pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=2, ncol=3), 
   width = 15, height = 9
)


# Remove unnecessary variables
rm(jaccard_matrices_list, jaccard_matrix, plot_list, my_grobs, output_file)
```

Heatmaps by anticodon - with NAs
```{r}
# Preparations: remove KOs with 0 DE proteins from list, grab anticodon names, create empty list to put Jaccard index matrices there
de_protein_list <- de_proteins_list_001
anticodons <- unique(responsiveness$anticodon)
jaccard_matrices_list <- list()

# Iterate over the anticodons and get a Jaccard index matrix for each of them
for (i in 1:length(anticodons)) {
  # For each anticodon, grab the tRNAs that contain it, and get a matrix with the Jaccard index across them
  anticodon <- anticodons[i]
  KOs_with_anticodon <- names(de_protein_list)[grepl(anticodon, names(de_protein_list))]
  
  # This is so I don't end up with matrices with a single cell
  if (length(KOs_with_anticodon) > 1) {
    jaccard_matrix <- get_jaccad_index_matrix(de_protein_list, KOs_with_anticodon)
    jaccard_matrices_list[[anticodon]] <- jaccard_matrix
  }
}

# Iterate over the Jaccard index matrices and get a heatmap from each of them
plot_list <- list()
for (i in 1:length(jaccard_matrices_list)) {
  anticodon <- names(jaccard_matrices_list)[i]
  mat <- jaccard_matrices_list[[i]]
  melt_mat <- melt(mat)
  plot_list[[i]] <- ggplot(melt_mat, aes(Var1, Var2)) +
                      geom_tile(aes(fill = value), colour = "white") +
                      scale_fill_gradient(low = "white", high = "red") +
                      xlab("") +
                      ylab("") +
                      labs(title = glue("Jaccard index heatmap - anticodon {anticodon}")) +
                      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
}

my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file <- paste(base_dir, "Output/Plots/compare_DEPs_across_KOs/Jaccard_index_heatmaps_per_anticodon_with_NAs.pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=3, ncol=3), 
   width = 15, height = 9
)


# Remove unnecessary variables
rm(anticodons, jaccard_matrices_list, anticodon, KOs_with_anticodon, jaccard_matrix, plot_list, my_grobs, output_file)
```

Heatmaps by amino acid - with NAs
```{r}
# Preparations: remove KOs with 0 DE proteins from list, grab anticodon names, create empty list to put Jaccard index matrices there
de_protein_list <- de_proteins_list_001
amino_acids <- unique(responsiveness$AA)
jaccard_matrices_list <- list()

# Iterate over the amino acids and get a Jaccard index matrix for each of them
for (i in 1:length(amino_acids)) {
  # For each amino acid, grab the tRNAs that carry it, and get a matrix with the Jaccard index across them
  aa <- amino_acids[i]
  strain_names <- unique(responsiveness$Strain.Name[responsiveness$AA == aa])
  KOs_with_amino_acid <- names(de_protein_list)[names(de_protein_list) %in% strain_names]
  
  # This is so I don't end up with matrices with a single cell
  if (length(KOs_with_amino_acid) > 1) {
    jaccard_matrix <- get_jaccad_index_matrix(de_protein_list, KOs_with_amino_acid)
    jaccard_matrices_list[[aa]] <- jaccard_matrix
  }
}

# Iterate over the Jaccard index matrices and get a heatmap from each of them
plot_list <- list()
for (i in 1:length(jaccard_matrices_list)) {
  aa <- names(jaccard_matrices_list)[i]
  mat <- jaccard_matrices_list[[i]]
  melt_mat <- melt(mat)
  plot_list[[i]] <- ggplot(melt_mat, aes(Var1, Var2)) +
                      geom_tile(aes(fill = value), colour = "white") +
                      scale_fill_gradient(low = "white", high = "red") +
                      xlab("") +
                      ylab("") +
                      labs(title = glue("Jaccard index heatmap - amino acid: {aa}")) +
                      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
}

my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file <- paste(base_dir, "Output/Plots/compare_DEPs_across_KOs/Jaccard_index_heatmaps_per_amino_acid_with_NAs.pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=2, ncol=3), 
   width = 15, height = 9
)


# Remove unnecessary variables
rm(KOs_with_anticodon, jaccard_matrix, jaccard_matrices_list, plot_list, my_grobs, output_file)
```


## 6.2. Check how frequent each DEP is - provided pretty much the same information as the Jaccard index heatmaps above I think
By anticodon
```{r}
# Preparations: grab anticodon names, create empty list to put the plots there
anticodons <- unique(responsiveness$anticodon)
plot_list <- list()

# Iterate over anticodons
for (i in 1:length(anticodons)) {
  anticodon <- anticodons[i]
  
  # For this anticodon, get a count of the appearances of the DEPs, and a barplot
  all_de_proteins <- data.frame(table(unlist(de_proteins_list_001[grepl(anticodon, names(de_proteins_list_001))])))
  all_de_proteins$Freq <- as.factor(all_de_proteins$Freq)
  plot_list[[i]] <- ggplot(data = all_de_proteins, aes(x = Freq)) +
                      geom_bar() +
                      theme_light() +
                      xlab("Number of KOs in which proteins where DE") +
                      ylab("Number of DE proteins") +
                      labs(title = glue("Anticodon {anticodon} - {sum(grepl(anticodon, names(de_proteins_list_001)))} total KOs"))
}

my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file <- paste(base_dir, "Output/Plots/compare_DEPs_across_KOs/barplots_DE_counts_per_anticodon.pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=3, ncol=3), 
   width = 15, height = 9
)
```

By amino acid
```{r}
# Preparations: grab amino acid names, create empty list to put the plots there
amino_acids <- unique(responsiveness$AA)
plot_list <- list()

# Iterate over amino acids
for (i in 1:length(amino_acids)) {
  aa <- amino_acids[i]
  strain_names <- unique(responsiveness$Strain.Name[responsiveness$AA == aa])
  
  # For this anticodon, get a count of the appearances of the DEPs, and a barplot
  all_de_proteins <- data.frame(table(unlist(de_proteins_list_001[names(de_proteins_list_001) %in% strain_names])))
  all_de_proteins$Freq <- as.factor(all_de_proteins$Freq)
  plot_list[[i]] <- ggplot(data = all_de_proteins, aes(x = Freq)) +
                      geom_bar() +
                      theme_light() +
                      xlab("Number of KOs in which proteins where DE") +
                      ylab("Number of DE proteins") +
                      labs(title = glue("Amino acid {aa} - {sum(names(de_proteins_list_001) %in% strain_names)} total KOs"))
}

my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file <- paste(base_dir, "Output/Plots/compare_DEPs_across_KOs/barplots_DE_counts_per_amino_acid.pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=3, ncol=3), 
   width = 15, height = 9
)
```




























