---
title: "tRNAs"
author: "Álvaro Gómez Pérez"
date: "2024-11-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Packages
```{r}
library(dplyr)
library(data.table)
library(limma)
library(ggplot2)
library(patchwork)
library(tidyr)
library(tibble)
library(stringr)
library(gprofiler2)
library(xlsx)
library(stringr)
library(gridExtra)
library(grid)
suppressPackageStartupMessages(library(ComplexHeatmap))
suppressPackageStartupMessages(library(circlize))
library(factoextra)
library(glue)
library(dendextend)
library(ggrepel)
library(ggvenn)
library(tidyr)
library(interactions)
library(performance)
library(MASS)
library(jsonlite)
```



# 1. Load data and initial analysis
## 1.0. Set parameters
```{r}
# Significance level to be used for all tests and plots in this file
alpha <- 0.01

# Log-fold change limit to be considered "biologically significant"
lfc_threshold <- 1.5

# Number of nDEP from which a tRNA is considered "major" (this threshold value should be included)
threshold_major <- 2

# Set directories to be used
working_from = "charite"

if (working_from == "home") {
  base_dir = "/home/alvaro/MyStuff/tRNA_KOs/"
} else
if (working_from == "charite") {
  base_dir = "C:/MyStuff/tRNA_KOs/"
}
```

## 1.1. Load data
```{r}
if (working_from == "charite") {
  # Our proteomics data 
  proteomics_raw <- read.delim2('S:/AG/AG-CF-HTMS/AG-Ralser-Share/30-0092_AndreaLehmann-AlternativeAAUsage-tRNA/05_DataAnalysis/11_Preprocessing_Boris/AlternativeAAUsage-tRNA/AlternativeAAUsage-tRNA_peptidecentric_ProteinMaxLFQ_PCAoutlier_removed_complete.tsv', header = T)
  
  # The sample layout
  sample_layout <- as.data.frame(fread("S:/AG/AG-CF-HTMS/AG-Ralser-Share/30-0092_AndreaLehmann-AlternativeAAUsage-tRNA/05_DataAnalysis/11_Preprocessing_Boris/AlternativeAAUsage-tRNA/AlternativeAAUsage-tRNA_peptidecentric_PrecursorQuantity_filename_annotations.tsv"))
  
  # The master tRNA dataset
  master_dataset <- as.data.frame(fread("C:/MyStuff/tRNA_KOs/Data/Other/GtRNAdb/master_tRNA_dataset.csv"))
  
  # Import the functions I have created in another file
  source("C:/MyStuff/tRNA_KOs/Code/R/Mine/0.general_use_functions.R")
} else 

if (working_from == "home") {
  # Proteomics data and sample layout - from the S drive
  #proteomics_raw <- read.delim2('/home/alvaro/MyStuff/tRNA_KOs/Data/proteomics_data/AlternativeAAUsage-tRNA_peptidecentric_ProteinMaxLFQ_PCAoutlier_removed_complete.tsv', header = T)
  
  proteomics_raw <- read.delim2('/home/alvaro/MyStuff/tRNA_KOs/Data/Other/proteomics_data/AlternativeAAUsage-tRNA_peptidecentric_ProteinMaxLFQ_complete.tsv', header = T)
  
  sample_layout <- as.data.frame(fread("/home/alvaro/MyStuff/tRNA_KOs/Data/Other/proteomics_data/AlternativeAAUsage-tRNA_peptidecentric_PrecursorQuantity_filename_annotations.tsv"))
  
  
  # My data - in the project folder - when I open the project, the directory is set to its location
  ## The master tRNA dataset
  master_dataset <- as.data.frame(fread("/home/alvaro/MyStuff/tRNA_KOs/Data/Other/GtRNAdb/master_tRNA_dataset.csv"))
  
  ## Import the functions I have created in another file
  source("/home/alvaro/MyStuff/tRNA_KOs/Code/R/Mine/0.general_use_functions.R")
}
```

## 1.2. Add columns to sample_layout and merge it with master_dataframe
```{r}
# Extract the date for when each sample was run
sample_layout <- sample_layout %>% 
  mutate(date = str_extract(File.Name, "(?<=/30-0092/).*?(?=_Z2_KTT_)"))

# Create a column that simply has the info of if each sample is a KO strain or a WT replicate
sample_layout <- sample_layout %>% 
  mutate(Strain.Type = case_when(Strain.Name == "WT" ~ "WT",
                                 TRUE ~ "KO"))

# Add a column with the following format: Analysis.Plate.96_Replicate
sample_layout <- sample_layout %>%
  mutate(Analysis.Plate.96_Replicate = paste(Analysis.Plate.96, Replicate, sep="_"))

# Add a column which identifies samples in Analysis.Plate.96 = 3, Replicate = 2
sample_layout <- sample_layout %>%
  mutate(Wrong_batch = case_when(Analysis.Plate.96_Replicate == "3_2" ~ "Yes",
                                 TRUE ~ "No"))

# Merge with master dataframe
colnames(master_dataset)[colnames(master_dataset) == "gene_name"] <- "Strain.Name"

sample_layout <- sample_layout %>% 
  dplyr::select(-Anticodon) %>%
  left_join(master_dataset, by = c("Strain.Name"))
```

## 1.3. Pre-process proteomics data - this is where I deal with the 2 duplicated strains and remove samples in the wrong subbatch
```{r}
# Come up with new colnames
new_names <- c("sample_group", "genes")
for (i in 3:ncol(proteomics_raw)) {
  strain_and_batch <- colnames(proteomics_raw)[i]
  trna_name <- proteomics_raw[1, i]
  batch_num <- str_extract(strain_and_batch, "(?<=\\.).*")
  new_name <- paste(trna_name, "_", batch_num, sep = "")
  new_names <- c(new_names, new_name)
}
colnames(proteomics_raw) <- new_names


# Fix the situation with 2 tRNA_KOs being present twice (so 6 replicates for each instead of 3) - just going to take the average between the replicated samples
## Come up with the averages
n_occur <- data.frame(table(colnames(proteomics_raw)))
repeated_samples <- as.character(n_occur$Var1)[n_occur$Freq > 1]

out_temp <- data.frame(matrix(ncol = 0, nrow = nrow(proteomics_raw)))
for (i in 1:length(repeated_samples)) {
  strain <- repeated_samples[i]
  temp <- proteomics_raw[5:nrow(proteomics_raw), colnames(proteomics_raw) == strain]
  temp[,1] <- as.numeric(temp[,1])
  temp[,2] <- as.numeric(temp[,2])
  first_rows <- proteomics_raw[1:4, colnames(proteomics_raw) == strain]
  out <- c(first_rows[,1], apply(temp, 1, mean))
  out_temp[,i] <- out
}
colnames(out_temp) <- repeated_samples

## Remove original columns from dataframe and add the averaged ones
proteomics_raw <- proteomics_raw[,!(colnames(proteomics_raw) %in% repeated_samples)]
proteomics_raw <- cbind(proteomics_raw, out_temp)


# Format data to get a biological protein abundance dataframe with samples names as colnames and gene names as rownames
trna_ko <- proteomics_raw %>%                 
  filter(!(genes %in% c('', 'Genes', 'Protein.Group'))) %>%             # Remove rows for which "genes" column is empty or has "Genes" as value
  dplyr::select(-genes & !contains('QC')) %>%                                  # Remove UNIPROT IDs and QCs columns
  column_to_rownames(var = 'sample_group')                              # Convert gene name column to rownames

# Convert to a numeric dataframe
trna_ko <- as.data.frame(apply(trna_ko, 2, as.numeric), row.names =  rownames(trna_ko))   

# Add sample_names to sample_layout so that we can filter out in the next line
sample_layout <- sample_layout %>%
  mutate(sample_names = case_when(Strain.ID == "WT" ~ paste(gsub("-", "_", Sample.ID), ".0", Replicate, sep=""),
                                  TRUE ~ paste(Strain.Name, "_0", Replicate, sep=""))) 

# Remove the sub-batch that went wrong
samples_in_wrong_batch <- sample_layout$sample_names[sample_layout$Analysis.Plate.96_Replicate == "3_2"]
trna_ko <- trna_ko[,!(colnames(trna_ko) %in% samples_in_wrong_batch)]

# Remove unnecessary objects
rm(proteomics_raw, n_occur, repeated_samples, out_temp, strain, temp, first_rows, out, batch_num, i, new_name, new_names, strain_and_batch, trna_name,
   samples_in_wrong_batch, working_from)
```

## 1.4. Differential expression analysis - adapted from what Alexis did, still need to fully understand some stuff
Perform DE analysis
```{r}
# Get the names of all KOs we have, and set WT as the reference
trna_levels <- c()
for (i in 1:ncol(trna_ko)) {
  sample_name <- colnames(trna_ko)[i]
  strain_name <- sample_layout$Strain.Name[sample_layout$sample_names == sample_name]
  if (length(strain_name) > 1) {
    strain_name <- strain_name[1]
  }
  trna_levels <- c(trna_levels, strain_name)
}
trna_levels <- as.factor(trna_levels)
trna_levels <- relevel(trna_levels, ref = "WT")


# Generate design matrix
mm <- model.matrix(~trna_levels)
colnames(mm) <- levels(trna_levels)
voom(trna_ko, mm, plot = TRUE)                                  # This I still need to look into!

# In order to fit linear model we need to get log2(data), but that causes log2(0) = -Inf --> I am turning 0s to 1s before log2 --> IDK HOW CORRECT THIS IS
zeros_to_ones <- function(x) {
  if (x == 0) {return(1)}
  else {return(x)}
}
trna_ko_log <- trna_ko
trna_ko_log[] <- apply(trna_ko, c(1,2), zeros_to_ones)
trna_ko_log <- log2(trna_ko_log)

# Fit linear model
fit <- lmFit(trna_ko_log, mm)                                 # Notice the log2 here
fit2 <- eBayes(fit, trend = TRUE)

# Identify differentially expressed proteins
da <- list()
for (i in colnames(mm)) {
  da[[i]] <- topTable(fit2, coef = i, adjust = 'BH', number = Inf, sort.by = 'none')
}
```

Save DE proteins for GO enrichment analysis
```{r}
# At the alpha specified at the top of the document
yeastmine <- as.data.frame(fread(paste(base_dir, "Data/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))
de_proteins_list_001 <- list()
for (i in 1:length(da)) {
  temp <- da[[i]]
  
  # Collect protein names and turn them all into systematic notation
  general_protein_names <- rownames(temp)[na.omit(temp$adj.P.Val) < alpha]
  standard_protein_names <- general_protein_names[general_protein_names %in% yeastmine$Gene.symbol]
  systematic_protein_names <- general_protein_names[general_protein_names %in% yeastmine$Gene.secondaryIdentifier]
  final_protein_names <- c(systematic_protein_names, match_systematic_and_standard_protein_names(data = standard_protein_names,
                                                                                                 yeastmine = yeastmine,
                                                                                                 input = "standard",
                                                                                                 simplify = T))
  
  # Save protein names
  de_proteins_list_001[[names(da)[i]]] <- final_protein_names
}
output_file <- paste(base_dir, "Data/Other/enrichment_analysis/de_proteins_list_001.json", sep="")
write_json(de_proteins_list_001, path=output_file)




# At alpha= 0.05
yeastmine <- as.data.frame(fread(paste(base_dir, "Data/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))
de_proteins_list_005 <- list()
for (i in 1:length(da)) {
  temp <- da[[i]]
  
  # Collect protein names and turn them all into systematic notation
  general_protein_names <- rownames(temp)[na.omit(temp$adj.P.Val) < 0.05]
  standard_protein_names <- general_protein_names[general_protein_names %in% yeastmine$Gene.symbol]
  systematic_protein_names <- general_protein_names[general_protein_names %in% yeastmine$Gene.secondaryIdentifier]
  final_protein_names <- c(systematic_protein_names, match_systematic_and_standard_protein_names(data = standard_protein_names,
                                                                                                 yeastmine = yeastmine,
                                                                                                 input = "standard",
                                                                                                 simplify = T))
  
  # Save protein names
  de_proteins_list_005[[names(da)[i]]] <- final_protein_names
}
output_file <- paste(base_dir, "Data/Other/enrichment_analysis/de_proteins_list_005.json", sep="")
write_json(de_proteins_list_005, path=output_file)
```

Save all proteins for GSEA
```{r}
write_json(da, path=paste(base_dir, "Data/Other/enrichment_analysis/da.json", sep=""))
```

Finish processing the DE analysis results
```{r}
# Format data
da <- bind_rows(da) %>%
  mutate(protein = rep(rownames(da[[1]]), times = length(da)),
         Strain.Name = rep(names(da), each = nrow(da[[1]])), .before = 1) %>%
  `rownames<-`(NULL) %>%
  dplyr::select(protein, Strain.Name, logFC, adj.P.Val) %>%
  filter(Strain.Name != 'WT') %>%                              # From here on in this function it's added by me
  mutate(diffexpressed = case_when(logFC > lfc_threshold & adj.P.Val < alpha ~ "Up_regulated",
                                   logFC < -lfc_threshold & adj.P.Val < alpha ~ "Down_regulated",
                                   TRUE ~ "Not_significant"))

# Add a column to da with the number of replicates per KO - by me - THIS DOESN'T REALLY MAKE SENSE INSIDE THIS FUNCTION BUT WHEN DOING DE FOR ALL PLATES AT ONCE IT WAS, SO I'LL KEEP IT JUST IN CASE
unique_KOs <- unique(da$Strain.Name)
replicates <- c()
for (i in 1:length(unique_KOs)) {
  KO <- unique_KOs[i]
  replicates <- c(replicates, sum(grepl(KO, colnames(trna_ko), fixed = T)))
}
KOs_replicates <- data.frame(unique_KOs, replicates)
colnames(KOs_replicates) <- c("Strain.Name", "Replicate_num")
da <- merge(da, KOs_replicates, by = "Strain.Name")

# Responsiveness
responsiveness <- da %>%
  group_by(Strain.Name) %>%
  summarise(nDEP = sum(abs(logFC) >= log2(lfc_threshold) & adj.P.Val <= 0.01, na.rm = T),
            Replicate_num = mean(Replicate_num)) %>%
  mutate(AA = str_sub(Strain.Name, 2, 2),
         chromosome = str_extract(str_remove(str_sub(Strain.Name, 1, -4), '[:digit:]$'), '[:alpha:]$'),
         anticodon = str_extract(Strain.Name, "(?<=\\()[[:alpha:]]{3}(?=\\))")) %>%
  arrange(AA) %>%
  mutate(anticodon = factor(anticodon, levels = unique(anticodon)))


# Save results from the DE analysis in the same way as in the file where I do DE separately for each batch
DE <- list(fit = fit,
            fit2 = fit2,
            da = da, 
            responsiveness= responsiveness)



# Remove unnecesary variables
rm(DE, de_proteins_list_001, de_proteins_list_005, fit, fit2, KOs_replicates, mm, sample_layout, temp, trna_ko, trna_ko_log, 
   yeastmine, final_protein_names, general_protein_names, i, KO, output_file, replicates, sample_name, standard_protein_names, strain_name,
   systematic_protein_names, trna_levels, unique_KOs)
```

## 1.5. Volcano plots for the differential expression
```{r}
# One plot per KO and save them to a PDF - for all KOs
## Come up with the list of plots
plot_list <- list()
for (i in 1:length(levels(as.factor(da$Strain.Name)))) {
  trna <- levels(as.factor(da$Strain.Name))[i]
  temp <- da %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed)) +
    geom_point() +
    geom_hline(yintercept = -log10(0.01), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-1.5, 1.5), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = trna) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "Output/Plots/Volcano_plots/DE_together/volcano_plots_per_KO_all_KOs_together.pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)


# One plot per KO and save them to a PDF - only for KOs with at least 1 DE protein
## Remove KOs with 0 DE proteins
KOs_with_DE_proteins <- responsiveness$Strain.Name[responsiveness$nDEP > 0]
da_only_KOs_with_DE_proteins <- da[da$Strain.Name %in% KOs_with_DE_proteins,]

## Come up with the list of plots
plot_list <- list()
for (i in 1:length(KOs_with_DE_proteins)) {
  trna <- KOs_with_DE_proteins[i]
  temp <- da_only_KOs_with_DE_proteins %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = trna) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "Output/Plots/Volcano_plots/DE_together/volcano_plots_per_KO_KOs_with_DE_proteins_together.pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)


# Remove unused objects
rm(list = c("my_grobs", "plot_list", "KOs_with_DE_proteins", "temp", "da_only_KOs_with_DE_proteins", "trna", "i", "output_file"))
```
--> Lots of the volcano plots are completely flat, just dots at the bottom. It would be nice if I could compare this to which are minor and which are major tRNA copies within each family actually, that would be great, but we don't have that information, do we? We have it for one family I think, I could check that, and then for the other families I would have to make the conclusions about "major" and "minor" myself precisely based on this, no?

## 1.6. Check number of DE proteins and also volcano plots for the UCU family - minor vs. major members
```{r}
# Load their phenotypic data: growth rate and growth yield for all KOs
phenotypic_data <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/bloom_ackermann_2014/phenotypic_results.tsv", sep = "")))

# Just number of DE proteins
UCU_major_minor <- phenotypic_data %>% 
  filter(UCU_family != "No") %>%
  dplyr::select(gene_name, UCU_family) %>%
  rename(Strain.Name = gene_name)

UCU_responsiveness <- responsiveness%>% filter(anticodon == "UCU")

UCU_family <- full_join(UCU_major_minor, UCU_responsiveness, by = "Strain.Name")


# Volcano plots
## Keep only KOs in UCU family
KOs_in_UCU_family <- UCU_family$Strain.Name
da_only_KOs_from_UCU_family <- da[da$Strain.Name %in% KOs_in_UCU_family,]


## Come up with the list of plots
plot_list <- list()
for (i in 1:length(KOs_in_UCU_family)) {
  trna <- KOs_in_UCU_family[i]
  plot_title <- paste(trna, UCU_family$UCU_family[UCU_family$Strain.Name == trna], sep = "_")
  temp <- da_only_KOs_from_UCU_family %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-1.5, 1.5), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = plot_title) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_location <- paste(base_dir, "Output/Plots/Volcano_plots/DE_together/volcano_plots_per_KO_UCU_family_together.pdf", sep="")
ggsave(
   filename = output_location, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)


# Remove unused objects
rm(list = c("my_grobs", "plot_list", "KOs_in_UCU_family", "temp", "da_only_KOs_from_UCU_family", "trna", "plot_title", "UCU_major_minor", "UCU_responsiveness", "i", "UCU_family", "phenotypic_data", "output_location"))
```

## 1.8. Check number of DE proteins vs. replicates per KO
```{r}
ggplot(data = responsiveness, aes(x = as.factor(Replicate_num), y = nDEP, col = as.factor(Replicate_num))) +
  geom_boxplot() +
  geom_jitter(position=position_jitter(0.2)) +
  xlab("Number of replicates")

replicate_num_vs_nDEP_cor <- cor(responsiveness$nDEP, responsiveness$Replicate_num)
replicate_num_vs_nDEP_cor

# Remove unnecessary objects
rm(replicate_num_vs_nDEP_cor)
```
--> The point with this was that maybe a larger number of replicates causes more nDEP just because it's easier to achieve significance. However, there seems to be no correlation at all, I think that's actually good because it means that the nDEP will be only influenced by what is going on with the tRNA KOs? Even though that effect could be already confounding my results in this boxplot

## 1.9. Number of DE proteins per family, coloring by number of tRNAs in the family
```{r}
responsiveness <- responsiveness %>%
  group_by(anticodon) %>% 
  mutate(n= n())

ggplot(data = responsiveness, aes(x = anticodon, y = nDEP, fill = n)) +
  geom_boxplot()

# Correlation between nDEP and tRNA family size
resp_summarized_by_family <- aggregate(responsiveness$nDEP, list(responsiveness$anticodon), mean)
colnames(resp_summarized_by_family) <- c("anticodon", "nDEP")
resp_summarized_by_family <- merge(resp_summarized_by_family, responsiveness[, c("anticodon", "n")], by = "anticodon", all.x = T)
resp_summarized_by_family <- resp_summarized_by_family %>%
  distinct(anticodon, .keep_all = T)
cor(resp_summarized_by_family$nDEP, resp_summarized_by_family$n)


# Remove unnecessary variables
rm(resp_summarized_by_family)
```
--> The boxplot is not particularly illustrative, but the correlation is pretty meaningful I think? Looks like larger families show, on average over all tRNAs in them, less DE proteins, which makes sense with their hypothesis I think? If there are a couple major tRNA genes per family, larger families are going to have a lot of minor ones, while small families will be mostly major ones. Here I am also assuming that there are only a couple major copies per family, which I don't think they said at any point? But I guess makes sense with this. 


## 1.10. Identify major and minor tRNA genes myself for all strains
```{r}
# Histogram of avg_nDEP for each KO strain
ggplot(data = responsiveness, aes(x = nDEP)) +
  geom_histogram(binwidth = 1, color="black", fill="grey") +
  theme_light() +
  xlab("nDEP per tRNA KO") +
  ylab("Count") +
  labs(title = "Frequency of nDEP across all tRNA KO strains")

# Given this histogram, I define the threshold to make out major and minor tRNA genes - for now I have it at 2

# Define a column with "minor"-"major" based on this so that I can check how many major and minor ones there are per family (I could also do this directly based on the avg_nDEP tbh but oh well)
responsiveness<- responsiveness%>%
  mutate(Gene_type = case_when(nDEP < threshold_major ~ "Minor",
                               TRUE ~ "Major")) %>%
  group_by(anticodon) %>%
  summarize(Major_count = sum(Gene_type == "Major"), across()) %>%
  ungroup()

# Also need to count the total number of KOs I have from each family in the experiment
responsiveness<- responsiveness%>%
  group_by(anticodon) %>%
  summarize(Family_count = n(), across()) %>%
  ungroup()


# Get a dataframe with the size of each family, the number of those genes we have as KOs in the experiment, and how many of them are major, and plot this
colnames(master_dataset)[colnames(master_dataset) == "family_size"] <- "Family_size"
family_sizes <- left_join(master_dataset, responsiveness, by = "Strain.Name")
family_sizes <- family_sizes %>%
  filter(Strain.Name %in% responsiveness$Strain.Name) %>%                       # Filtered on KOd before, but that kept strains that were removed during filtering
  dplyr::select(anticodon, Family_size, Family_count, Major_count) %>%
  distinct(anticodon, .keep_all = T)


# Get long version to plot, and re-order the anticodons by family size, in order to keep that order for the x axis of the plot
family_sizes <- family_sizes[order(-family_sizes$Family_size), ]
family_sizes_long <- family_sizes %>% pivot_longer(!anticodon, names_to = "Type", values_to = "Count")
family_sizes_long$anticodon <- factor(family_sizes_long$anticodon, levels = family_sizes$anticodon)
family_sizes_long$Type <- factor(family_sizes_long$Type, levels = c("Family_size", "Family_count", "Major_count"))

colnames(family_sizes_long)[colnames(family_sizes_long) == "anticodon"] <- "Anticodon"


# Plot this
ggplot(data = family_sizes_long, aes(x = Anticodon, y = Count, fill = Type)) +
  geom_bar(position="dodge", stat="identity") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
        legend.position = "none")


# What is the relationship between Family_count and Major_count?
ggplot(data = family_sizes, aes(x = Family_count, y = Major_count)) +
  geom_point() +
  geom_abline() +
  theme_light() +
  xlab("Genes in this family in the experiment") +
  ylab("Major genes detected in the family") +
  geom_text_repel(data = subset(family_sizes, Major_count/Family_count >= 1 | Major_count/Family_count < 0.3),
                  aes(x = Family_count, y = Major_count, label = anticodon),
                  size = 4)

# Produce a single histogram like the one at the beginning of this chunk for each set of tRNA isoacceptors - and save them to a PDF
## Create empty list of plots
plot_list <- list()

## Generate the plots and add them to the list
aas <- levels(as.factor(responsiveness$AA))
for (i in 1:length(aas)) {
  aa <- aas[i]
  temp <- responsiveness%>%
    filter(AA == aa)
  plot_list[[aa]] <- ggplot(data = temp, aes(x = nDEP, col = anticodon, fill = anticodon)) +
    geom_histogram(binwidth = 1) +
    theme_light() +
    xlab("nDEP") +
    ylab("Count") +
    labs(title = glue("Frequency of nDEP in tRNAs loading {aa}"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "Output/Plots/nDEP_hists_per_isoacceptors_color_by_codon.pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)


# Remove unnecessary variables
rm(family_sizes_long, my_grobs, plot_list, temp, aa, aas, output_file, i)
```






# 2. Correlation with the original article by Pizpel et al., 2014
## 2.1. Correlation between our proteomics data and their phenotypic data (GR and GY)
```{r}
# Load their phenotypic data: growth rate and growth yield for all KOs
phenotypic_data <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/bloom_ackermann_2014/phenotypic_results.tsv", sep="")))

# Change "ko" colname to allow to merge datasets based on it
colnames(resp)[colnames(resp) == "Strain.Name"] <- "gene_name"
test <- full_join(phenotypic_data, resp, by = "gene_name")

# Select numeric columns, calculate correlations and plot heatmap
test <- test %>% dplyr::select(YPD, SDC, low_glucose, galactose, NaCl, DTT, YPD_GY, SDC_GY, low_glucose_GY, galactose_GY, NaCl_GY, DTT_GY, nDEP)
colnames(test) <- c("YPD_GR", "SDC_GR", "low_glucose_GR", "galactose_GR", "NaCl_GR", "DTT_GR", "YPD_GY", "SDC_GY", "low_glucose_GY", "galactose_GY", "NaCl_GY", "DTT_GY", "nDEP")
test_corrs <- round(cor(test, use = "pairwise.complete.obs"), 2)
melted_corrs <- melt(test_corrs)

ggplot(data = melted_corrs, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  geom_text(aes(Var2, Var1, label = value), size = 3) +
  scale_fill_gradient2(low = "blue", high = "red",
                       limit = c(-1,1), name="Correlation") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

# Remove unnecessary objects
rm(test, test_corrs, melted_corrs)
```
nDEP has:
  - No correlation with growth rate under SDC, YPD and low glucose
  - Relatively large, positive correlation with growth rate and growth yield under DTT: those that show more DEPs in rich medium are those that        grow better under DTT, this agrees with the original article: these strains have proteotoxic stress going on already in the cell because of the     lack of that necessary (major?) tRNA, so they adapt better to living in DTT. 
  - Relatively large, negative correlation with growth rates and growth yields under all other conditions: also makes sense with the original            article, the strains which are less affected by the KO (so less DEPs) grow better in most conditions, simply because less things are affected     inside the cell, reasonable. The more unintuitive one is the previous one. 




## 2.2. Compare our proteomics data and their microarray data
Important to remember that the microarray data are only for 5 tRNA families: 
  - MC (multi-copy) families: tR.UCU.M2 and tH.GUG.G1, both of which had impaired or WT growth under DTT
  - SC (single-copy) families: Two viable single deletions: tR.CCU.J and tL.GAG.G, plus the initiator methionine tiM.CAU.C. They all had improved growth under DTT. 

### Loading data
```{r}
# Load their small microarray data: fold changes for all genes but only for 5 samples
microarray_data <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/bloom_ackermann_2014/microarray_fold_change_data.tsv", sep="")))

# Load all S. cerevisiae genes from AllianceMine - to be able to go from standard to systematic gene names and vice versa
yeastmine <- as.data.frame(fread(paste(base_dir, "Data/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))


# Need to change the colnames in the microarray data to use () instead of ..
colnames(microarray_data) <- c("gene_names", "tM(CAU)C", "tR(CCU)J", "tR(UCU)M2", "tH(GUG)G1", "tL(GAG)G")
```


### Correlation heatmap between microarray and proteomics
```{r}
# Get standard protein names
source(paste(base_dir, "Code/R/Mine/0.general_use_functions.R", sep=""))
microarray_data <- match_systematic_and_standard_protein_names(data = microarray_data,
                                                               yeastmine = yeastmine,
                                                               input = "systematic",
                                                               simplify = FALSE,
                                                               add_extra_columns = FALSE)

# Join with our proteomics data - not too sure if this merge is the most appropriate way to do it, even though I think so?
trna_ko_temp <- trna_ko %>%
  mutate(Gene.symbol = rownames(trna_ko))
proteomics_and_microarray_data <- left_join(trna_ko_temp, microarray_data, by = "Gene.symbol") # IM KEEPING ALL PROTEINS IN TRNA_KO, THERE ARE ACTUALLY 2863 WHICH ARE IN BOTH, SO SOME IN TRNA_KO ARE NOT IN MICROARRAY_DATA, I SHOULD FIX THIS CODE SO THOSE ARE NOT INCLUDED IN THE RESULTING DATA SET

# Correlation heatmap between our samples 
samples_in_microarray <- colnames(microarray_data)[2:6]
sample_names_escaped <- c("tM\\(CAU\\)C",  "tR\\(CCU\\)J",  "tR\\(UCU\\)M2", "tH\\(GUG\\)G1", "tL\\(GAG\\)G")
proteomics_and_microarray_subset <- data.frame(matrix(nrow = nrow(proteomics_and_microarray_data), ncol = 0))

for (i in 1:length(samples_in_microarray)) {
  sample_name <- sample_names_escaped[i]
  temp <- proteomics_and_microarray_data[, grepl(sample_name, colnames(proteomics_and_microarray_data))]
  proteomics_and_microarray_subset <- cbind(proteomics_and_microarray_subset, temp)
}

cormat <- round(cor(proteomics_and_microarray_subset, use = "pairwise.complete.obs", method = "kendall"), 2)
melted_cormat <- melt(cormat)

ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  geom_text(aes(Var2, Var1, label = value), size = 3) +
  scale_fill_gradient2(low = "blue", high = "red",
                       limit = c(-1,1), name="Correlation") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))


# Remove unnecessary objects

```
--> The proteomics samples for these 5 strains have literally 0 correlation with the microarray data from the same strains. Could it be because the proteomics data are direct measurements while the microarray data are actually presented as the fold-change with respect to the WT? I don't think so but maybe I could look into it? Could try to make my proteomics data for these strains into that as well?


### Venn diagram between genes detected in proteomics and in transcriptomics
```{r}
list_for_venn_diagram <- list(Proteomics = rownames(trna_ko),
                              Transcriptomics = microarray_data$Gene.symbol)
ggvenn(
  list_for_venn_diagram, 
  fill_color = c("#80AAFF", "#FF8080"),
  stroke_size = 0.5, set_name_size = 4
  )
```


### Correlation heatmap within microarray
```{r}
test <- microarray_data %>% dplyr::select(-Gene.secondaryIdentifier, -Gene.symbol)
corrs <- round(cor(test, use = "pairwise.complete.obs"), 2)
melted_corrs <- melt(corrs)

ggplot(data = melted_corrs, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  geom_text(aes(Var2, Var1, label = value), size = 3) +
  scale_fill_gradient2(low = "blue", high = "red",
                       limit = c(-1,1), name="Correlation") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

# Remove unnecessary variables
rm(test, corrs, melted_corrs)
```


### Correlation heatmap within proteomics (only the samples involved here)
```{r}
# Grab columns of proteomics data with only samples from the strains for which there are microarray data
matches <- grepl(paste(sample_names_escaped, collapse="|"), 
                        colnames(trna_ko))
MC_and_SC_proteomics <- trna_ko[, matches]

# Add MC or SC information to column names and sort columns by this so (expected) clusters are easily visible on heatmap
new_colnames <- c()
for (i in 1:ncol(MC_and_SC_proteomics)) {
  old_colname <- colnames(MC_and_SC_proteomics)[i]
  if (grepl(paste(c("UCU", "GUG"), collapse = "|"), old_colname))
    new_colnames <- c(new_colnames, paste("MC", old_colname, sep = "_"))
  else if ((grepl(paste(c("CCU", "GAG", "CAU"), collapse = "|"), old_colname)))
    new_colnames <- c(new_colnames, paste("SC", old_colname, sep = "_"))
}
colnames(MC_and_SC_proteomics) <- new_colnames
MC_and_SC_proteomics <- MC_and_SC_proteomics %>% dplyr::select(order(colnames(MC_and_SC_proteomics)))

# Correlation heatmap
corrs <- round(cor(MC_and_SC_proteomics, use = "pairwise.complete.obs"), 2)
melted_corrs <- melt(corrs)

ggplot(data = melted_corrs, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  geom_text(aes(Var2, Var1, label = value), size = 3) +
  scale_fill_gradient2(low = "blue", high = "red",
                       limit = c(-1,1), name="Correlation") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))



# Remove unnecessary objects
rm(toMatch, matches, corrs, melted_corrs, old_colname, new_colnames)
```
--> In the heatmap based on microarray data, the SC and MC samples separate quite nicely, each of them correlating only with those in the same group as itself. However, at the proteomic level we see extremely high correlation between all of the samples, with no particular pattern to be seen. Is this something to do with how the proteomics data were processed? Or?
Okay this probably also explains why I see no correlation at all between the proteomics data and the microarray in the other heatmap, but still, what is going on here???

Get one of these for all the proteomics data and see if they all are this heavily correlated to each other or if I can actually see some pattern per KOs. Because if all of them are this correlated to each other, it feels a bit wrong I'd say? Idk, maybe it's normal. Also maybe try to get a heatmap for the proteomics data themselves, not only for the correlations between them


### Correlation heatmap of only proteomics data (for all samples)
```{r}
corrs <- round(cor(trna_ko, use = "pairwise.complete.obs"), 2)
melted_corrs <- melt(corrs)

ggplot(data = melted_corrs, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  scale_fill_gradient2(low = "blue", high = "red",
                       limit = c(-1,1), name="Correlation") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
```


Check that proteins which are upregulated in these samples in the proteomics data, are also upregulated in microarray data - if this is the case, it should mean that my correlation between the 2 datasets is not wrong and that in fact there are interesting things to look at here
```{r}
microarray_samples <- colnames(microarray_data[2:6])

da_for_microarray_samples <- da %>% filter(Strain.Name %in% microarray_samples)

for (i in 1:length(microarray_samples)) {
  sample <- microarray_samples[i]
  da_temp <- da %>% 
    filter(Strain.Name == sample) %>%
    dplyr::select(protein, diffexpressed, logFC, adj.P.Val)
  colnames(da_temp) <- c("Gene.symbol", "diffexpressed", "logFC", "adj.P.Val")
  microarray_temp <- microarray_data %>% dplyr::select(all_of(sample), Gene.symbol)
  test <- left_join(microarray_temp, da_temp, by = "Gene.symbol")
  test <- inner_join(da_temp, microarray_temp, by = "Gene.symbol")
  test <- test %>% mutate(diffexpressed = case_when(diffexpressed == "Up_regulated" ~ "Up_regulated",
                                                    diffexpressed == "Down_regulated" ~ "Down_regulated",
                                                    TRUE ~ "Not_significant"))
  colnames(test) <- c("Gene.symbol", "diffexpressed", "logFC", "adj.P.Val", "logfold_microarray")
  
  
  # Calculate correlation to add to plot
  corr_coef <- round(cor(test$logFC, test$logfold_microarray, method = "spearman", use = "complete.obs"), 2)
  
  
  # Protein names in X axis, transcriptomics fold change in Y axis, color by significance in proteomics - not such a good plot tbh
  
  #p1 <- ggplot(data = test, aes(x = Gene.symbol, y = as.numeric(logfold_microarray), col = diffexpressed)) +
  #  geom_point() +
  #  labs(title = sample,
  #       col = "Differentially\nexpressed\nin proteomics\ndata") +
  #  xlab("Protein name") +
  #  ylab("Transcriptomics fold change") +
  #  theme(axis.text.x=element_blank(),
  #      axis.ticks.x=element_blank()) +
  #  geom_text(data = subset(test, diffexpressed == "Up_regulated" | diffexpressed == "Down_regulated"),
  #            aes(x = Gene.symbol, y = as.numeric(logfold_microarray), col = diffexpressed, label = Gene.symbol),
  #            size = 5)
  #print(p1)
  
  
  # logFC transcriptomics vs. logFC proteomics - color by significance in proteomics: much better
  p2 <- ggplot(data = test, aes(x = logFC, y = logfold_microarray, col = diffexpressed)) +
    geom_point(size = 1.5) +
    labs(title = glue('{sample} - correlation coef. = {corr_coef}'),
         col = "Differentially\nexpressed\nin proteomics\ndata") +
    xlab("logFC proteomics") +
    ylab("logFC transcriptomics") +
    theme_light() +
    geom_text_repel(data = subset(test, diffexpressed == "Up_regulated" | diffexpressed == "Down_regulated"),
              aes(x = logFC, y = logfold_microarray, col = diffexpressed, label = Gene.symbol),
              size = 4) +
    geom_abline() +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
  print(p2)
  
  # This is just to check if the FCs from the microarrays data are also log2FCs, which I think so but their article says only FC
  #hist(test$logfold_microarray)
  #hist(test$logFC)
  #hist((test$logFC)^2)
}

```
--> The correlations here get quite a bit better than in the heatmap for proteomics vs. transcriptomics, I guess because the proteomics data is averaged over the replicates for each tRNA? That's the only difference I can think of

--> Interestingly, I get decent correlations between proteomics and transcriptomics in the KOs for MC tRNAs, those which grew worse than WT or equally bad in DTT, so those where we assume the removal of the tRNA is not having a proteotoxic effect. On the other hand, for SC tRNAs (those where the removal of the tRNA has a proteotoxic effect, hence allowing them to grow better than WT in DTT), there is barely any correlation between transcriptomics and proteomics. 







# 4. Repeat 3, but only using genomic tRNA sequencing data from Cozen et al., 2015 - FIX THE TITLE OF THIS SECTION BASED ON THE ONE IN THE DELETED CODE

Load data and keep only genomic rows
```{r}
cozen <- read.xlsx(paste(base_dir, "Data/Other/tRNA_expression_comparative/cozen_et_al_2015.xlsx", sep=""), 1) %>%
  filter(read.mapping..genomic.sequence.or.mature.tRNA. == "genomic")
```

Remove rows with NAs in relevant columns, select columns of interest, get the sum of reads per tRNA (since there are several rows for the same tRNA), and rename to merge with responsiveness dataframe
```{r}
cozen_to_merge <- cozen %>%
  filter(saccaromyces.genome.datasbase..sgd..tRNA.name != "NA" &
           mean.normalized.ReadCount..AlkB != "NA") %>%
  dplyr::select(name, tRNA.group, chromosome, chromosome.start, chromosome.end, chromosome.start,
         saccaromyces.genome.datasbase..sgd..tRNA.name, mean.normalized.ReadCount..AlkB, read.mapping..genomic.sequence.or.mature.tRNA.) %>%
  group_by(saccaromyces.genome.datasbase..sgd..tRNA.name) %>%
  mutate(mean_reads_per_tRNA = sum(as.numeric(mean.normalized.ReadCount..AlkB), na.rm = T)) %>%
  rename(Strain.Name = saccaromyces.genome.datasbase..sgd..tRNA.name)

## Merge with resp
resp_and_expression <- left_join(responsiveness, cozen_to_merge, by = "Strain.Name")
```

Plots - nDEP vs. tRNA expression from Cozen et al., 2015
```{r}
# Plot average nDEP vs. avg expression - genomic tRNA sequences
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP)) +
  geom_point() +
  theme_light() + 
  labs(title = "nDEP vs. tRNA expression") +
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")

# Same, but color by number of tRNA genes in family
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = Family_count)) +
  geom_point() +
  theme_light() + 
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")
```


## 4.2. Integrate data from tRNA synthetase abundance and tRNA abundance (Chu et al., 2011) 
Load and prepare data
```{r}
# Load data
chu_synths <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/chu_2011/S3.csv", sep="")))
chu_trnas <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/chu_2011/S2.csv", sep="")))
# The problem with these abundances for tRNAs is that they are for each family, not for each tRNA concretely, so I don't really know if they will be useful to me. I could collapse those from Cozen et al. by family and compare them to this to see if they point in the same direction, but might be a bit of a time waste

# Join the synthetase data to the resp_and_expression dataset
amino_acids <- as.data.frame(fread(paste(base_dir, "Data/Other/GtRNAdb/amino_acids.csv", sep=""))) %>%
  rename(Amino_acid = X3_letter_code, 
         AA = X1_letter_code)

chu_synths <- left_join(chu_synths, amino_acids, by = "Amino_acid") %>%
  rename(synthetase_abundance = Abundance)
resp_and_expression <- left_join(resp_and_expression, chu_synths, by = "AA")
```

Plots - nDEP vs. tRNA expression from Cozen et al., 2015 (coloring by amino acid characteristics)
```{r}
# Plot average nDEP vs. avg expression - color by amino acid type
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = amino_acid_type)) +
  geom_point() +
  theme_light() + 
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")

# Plot average nDEP vs. avg expression - color by amino acid charge
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = amino_acid_charge)) +
  geom_point() +
  theme_light() + 
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")

# Plot average nDEP vs. avg expression - color by amino acid weight
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = molecular_weight)) +
  geom_point() +
  theme_light() + 
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")
```

Plots - tRNA expression from Cozen et al., 2015 vs. tRNA synthetase abundance from Chu et al., 2011
```{r}
# tRNA abundance from Cozen et al., vs. log2 tRNA synthetase abundance from Chu et al.
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA)) +
  geom_point() +
  theme_light()

# Same, but color by major and minor based on our proteomics
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA, col = Gene_type)) +
  geom_point() +
  theme_light()

# Plot average nDEP vs. avg expression, but color by tRNA synthetase abundance from Chu et al.
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = synthetase_abundance)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid type
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA, col = amino_acid_type)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid charge
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA, col = amino_acid_charge)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid weight
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA, col = molecular_weight)) +
  geom_point() +
  theme_light()
```

Plots - nDEP vs. synthetase abundance
```{r}
# nDEP vs. synthetase abundance
ggplot(data = resp_and_expression, aes(x = synthetase_abundance, y = nDEP)) +
  geom_point()

# nDEP vs. log2-synthetase abundance
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance") +
  xlab("log2-tRNA synthetase abundance (from von der Haar, 2008)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by family size
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = Family_count)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by chromosome
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = chromosome.y)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid type
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = amino_acid_type)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid charge
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = amino_acid_charge)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid weight
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = molecular_weight)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")
```

Plots - nDEP vs. synthetase k_cat
```{r}
# nDEP vs. log2-synthetase k_cat
ggplot(data = resp_and_expression, aes(x = log2(k_cat_value), y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. log2(synthetase catalytic constant)") +
  xlab(bquote(log2-k["cat"]))

# The synthetases for W seem to have a k_cat more than 10x those of other amino acids, so I am going to get rid of that one then repeat the plot
ggplot(data = resp_and_expression, aes(x = k_cat_value, y = nDEP)) +
  geom_point() +
  theme_light() +
  coord_cartesian(xlim = c(0, 150))

# Not really a pattern I think, let's try synthetase abundance*k_cat
ggplot(data = resp_and_expression, aes(x = k_cat_value*synthetase_abundance, y = nDEP)) +
  geom_point() +
  theme_light() +
  coord_cartesian(xlim = c(0, 500000))
```



## 4.3. Add information about anticodon frequency as well
Load and prepare data
```{r}
# Get anticodon from codon and rename columns
anticodon_freq <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/chu_2011/S1.csv", sep="")))
anticodon_freq$anticodon <- lapply(anticodon_freq[,colnames(anticodon_freq) == "Codon"], codon_to_anticodon)
anticodon_freq$anticodon <- as.character(anticodon_freq$anticodon)
anticodon_freq$anticodon <- as.factor(anticodon_freq$anticodon)
anticodon_freq <- anticodon_freq %>%
  rename(codon_frequency_chu_2011 = Frequency)

# Merge to resp_and_expression
resp_and_expression <- left_join(resp_and_expression, anticodon_freq, by = "anticodon")
```

Plots - nDEP vs. codon frequency (from van der Haar, 2008)
```{r}
# Codon frequency vs. nDEP
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency") +
  xlab("Codon frequency (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by tRNA abundance from Cozen et al.
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = mean_reads_per_tRNA)) +
  geom_point() +
  theme_light() +
  xlab("Codon frequency (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by log2 tRNA synthetase abundance from Chu et al.
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = log2(synthetase_abundance))) +
  geom_point() +
  theme_light() +
  xlab("Codon frequency (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by family size
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = Family_count)) +
  geom_point() +
  theme_light() +
  xlab("Codon frequency (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by amino acid type
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = amino_acid_type)) +
  geom_point() +
  theme_light() +
  xlab("Codon frequency (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by amino acid charge
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = amino_acid_charge)) +
  geom_point() +
  theme_light() +
  xlab("Codon frequency (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by amino acid weight
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = molecular_weight)) +
  geom_point() +
  theme_light() +
  xlab("Codon frequency (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")
```


## 4.4. Plots regarding family size and so on, from 1.11., but I want to color by variables only introduced here
```{r}
# Family_count vs. major_count, as in 1.11., but color by amino acid carried - TODO
temp <- resp_and_expression %>%
  dplyr::select(anticodon, AA)
temp_2 <- left_join(family_sizes, temp, by = "anticodon") %>%
  distinct(anticodon, .keep_all = T)

ggplot(data = temp_2, aes(x = Family_count, y = Major_count, col = AA)) +
  geom_point() +
  geom_abline() +
  theme_light() +
  xlab("Genes in this family in the experiment") +
  ylab("Major genes detected in the family") +
  geom_text_repel(data = subset(temp_2, Major_count/Family_count == 1 | Major_count/Family_count < 0.3),
                  aes(x = Family_count, y = Major_count, label = anticodon),
                  size = 4, 
                  max.overlaps = 100)

# Same, but use in the y axis the % of major tRNAs instead of the count
ggplot(data = temp_2, aes(x = Family_count, y = Major_count/Family_count)) +
  geom_point() +
  geom_smooth(method='lm') +
  theme_light() +
  xlab("Genes in this family in the study") +
  ylab("% of major genes detected in the family") +
  geom_text_repel(data = subset(temp_2, Major_count/Family_count >= 1 | Major_count/Family_count < 0.3| anticodon == "CAA"),
                  aes(x = Family_count, y = Major_count/Family_count, label = anticodon, col = AA),
                  size = 4)

# Same, but use in the y axis the % of major tRNAs instead of the count, and color by aa
ggplot(data = temp_2, aes(x = Family_size, y = Major_count/Family_count)) +
  geom_point() +
  geom_smooth(method='lm') +
  theme_light() +
  xlab("Genes in this family in total") +
  ylab("% of major genes detected in the family") +
  geom_text_repel(data = subset(temp_2, Major_count/Family_count >= 1 | Major_count/Family_count < 0.3 | anticodon == "CAA"),
                  aes(x = Family_size, y = Major_count/Family_count, label = anticodon, col = AA),
                  size = 4)
```


## 4.5. Save the resp_and_expression dataset as it is at this point, can be useful later in other files
```{r}
fwrite(resp_and_expression, paste(base_dir, "Data/resp_and_expression.csv", sep=""))
```




# 5. Modelling

## 5.0. Load data - so I don't have to run everything above
```{r}
resp_and_expression <- as.data.frame(fread(paste(base_dir, "Data/resp_and_expression.csv", sep="")))
```


## 5.1. Try to fit a linear model to predict nDEP based on synthetase abundance and genomic tRNA read counts, and their interaction - THIS IS WRONG, I CANNOT REALLY MODEL MY DATA WITH A LINEAR MODEL, THEY ARE NOT CONTINUOUS
```{r}
# Simple linear model with synthetase abundance, tRNA expression and codon frequency (and interactions)
fit <- lm(data = resp_and_expression, nDEP ~ synthetase_abundance*mean_reads_per_tRNA*codon_frequency_chu_2011)
summary(fit)

# Simple linear model with synthetase abundance and synthetase k_cat (and interactions) - this is the only significant one
fit <- lm(data = resp_and_expression, nDEP ~ synthetase_abundance*k_cat_value*codon_frequency_chu_2011)
summary(fit)
```

Plot interactions for the significant model
```{r}
interact_plot(fit, pred = k_cat_value, modx = synthetase_abundance)
```


## 5.2. Model the data with a GLM instead

Poisson
```{r}
# Poisson model
fit <- glm(data = resp_and_expression,
           formula = nDEP ~ synthetase_abundance*k_cat_value*codon_frequency_chu_2011,
           family = poisson)
summary(fit)

# Check overdispersion - seems like there is, unsurprisingly
check_overdispersion(fit)

# Actually in the fit for the Poisson model we can already get an idea of if there is overdispersion or not: we do this by looking at the residual deviance and at the corresponding degrees of freedom, if the ratio between them is roughly 1, there is no overdispersion. If it is larger, there is overdispersion. So yeah, we see that we indeed have it here. 
```

Negative binomial
```{r}
fit <- glm.nb(data = resp_and_expression, 
              formula = nDEP ~ synthetase_abundance*k_cat_value*codon_frequency_chu_2011)
summary(fit)

# Check overdispersion
check_overdispersion(fit)
```





# 6. Evaluate codon enrichment in DEPs sequences
SHOULD I CONSIDER SOME GROUPING BY CODON HERE? LIKE, THE DIFFERENT TRNAS THAT HAVE THE SAME CODON?
Load data (generated in Python script "check_codon_enrichment_in_DEPs_sequences.py")
```{r}
# Load list
codon_ratios_list <- fromJSON(paste(base_dir, "Data/Other/check_codon_enrichment_in_protein_sequences/codon_counts.json", sep=""))

# Remove from the list those strains where there aren't at least 4 DE proteins
bool <- c()
for (i in 1:length(codon_ratios_list)) {
  bool <- c(bool, length(codon_ratios_list[[i]][["DE"]]) > 4)
}
codon_ratios_list <- codon_ratios_list[bool]
```

Iterate over the strains and perform a test for each, testing the mean counts of DE vs. that of non_DE
```{r}
strains <- names(codon_ratios_list)
p.values_wmw <- c()
mean_de <- c()
mean_non_de <- c()
num_de <- c()
num_non_de <- c()
for (i in 1:length(codon_ratios_list)) {
  # Grab data for this strain
  strain_name <- names(codon_ratios_list)[i]
  de <- codon_ratios_list[[strain_name]][["DE"]]
  non_de <- codon_ratios_list[[strain_name]][["non_DE"]]
  de_df <- data.frame(codon_ratios_list[[strain_name]][["DE"]])
  non_de_df <- data.frame(codon_ratios_list[[strain_name]][["non_DE"]])
  
  # Plot overlapping histograms - not worth it I think
  ggplot() +
    geom_histogram(data = de_df, aes(x = log2(codon_ratios_list..strain_name.....DE...)), fill = "red", alpha = 0.9) +
    geom_histogram(data = non_de_df, aes(x = log2(codon_ratios_list..strain_name.....non_DE...)), fill = "orange", alpha = 0.4)
  
  # Test - WMW
  p.values_wmw <- c(p.values_wmw, wilcox.test(de, non_de)$p.value)
  
  # Test - log2 transform (need to take care of 0s) and use t-test - is this worth doing?
  
  
  # Save the mean of each group to the output vectors as well
  mean_de <- c(mean_de, mean(de))
  mean_non_de <- c(mean_non_de, mean(non_de))
  
  # Save the number of proteins in each of the two groups - probably will explain the significance bc of low power with small DE protein counts
  num_de <- c(num_de, length(de))
  num_non_de <- c(num_non_de, length(non_de))
}

p.values.adj <- p.adjust(p.values_wmw, method = "fdr")

test_codon_enrichment <- data.frame(Strain.Name = strains, p.values_wmw, p.values.adj, mean_de, mean_non_de, num_de, num_non_de) %>%
  mutate(direction = case_when(mean_de > mean_non_de ~ "DE",
                               TRUE ~ "non_DE"),
         FC = mean_de/mean_non_de)

# Get the logFC - need to deal with the negative values in the FC - there is definitely a better way to do this but oh well
logFC <- c()
for (i in 1:nrow(test_codon_enrichment)) {
  FC <- test_codon_enrichment$FC[i]
  if (FC < 1) {
    out <- -log10(abs(FC))
  }
  else if (FC > 1) {
    out <- log10(FC)
  }
  else if (FC == 0) {
    out <- 0
  }
  logFC <- c(logFC, out)
}
test_codon_enrichment$logFC <- log10(test_codon_enrichment$FC)


# Remove unnecessary variables
rm(bool, strains, p.values_wmw, mean_de, mean_non_de, p.values.adj, logFC, FC, out, num_de, num_non_de)
```

Add some information to this plot to be able to color plots by it (amino acid, codon, etc.)
```{r}
temp <- master_dataset %>%
  dplyr::select(Strain.Name, Anticodon, Best_isotype_model_1_letter, Family_size) %>%
  rename(AA = Best_isotype_model_1_letter)
test_codon_enrichment <- left_join(test_codon_enrichment, temp, by = "Strain.Name")
```

"Volcano plot"
```{r}
# Basic volcano plot - FC vs. -log10(adj.p-value) - tag only significant p-values and FCs
ggplot(data = test_codon_enrichment, aes(x = FC, y = -log10(p.values.adj))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = 1.5, col = "red") +
  theme_light() +
  geom_text_repel(data = subset(test_codon_enrichment, (FC < 0.5 | FC > 1.5) & -log10(p.values.adj) > -log10(0.05)),
                  aes(x = FC, y = -log10(p.values.adj), label = Strain.Name))

# Basic volcano plot - FC vs. -log10(adj.p-value) - tag all significant FCs
ggplot(data = test_codon_enrichment, aes(x = FC, y = -log10(p.values.adj))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = 1.5, col = "red") +
  theme_light() +
  geom_text_repel(data = subset(test_codon_enrichment, FC < 0.5 | FC > 1.5), 
                  aes(x = FC, y = -log10(p.values.adj), label = Strain.Name))

# Color by count of DE proteins
ggplot(data = test_codon_enrichment, aes(x = FC, y = -log10(p.values.adj), col = num_de)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = 1.5, col = "red") +
  theme_light()

# Color by family
ggplot(data = test_codon_enrichment, aes(x = FC, y = -log10(p.values.adj), col = Anticodon)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = 1.5, col = "red") +
  theme_light()

# Color by family size
ggplot(data = test_codon_enrichment, aes(x = FC, y = -log10(p.values.adj), col = Family_size)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = 1.5, col = "red") +
  theme_light()

# Color by amino acid
ggplot(data = test_codon_enrichment, aes(x = FC, y = -log10(p.values.adj), col = AA)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = 1.5, col = "red") +
  theme_light()
```





# 7. Look for the expression of the tRNA synthetases in my proteomics data
## 7.0. Load data
```{r}
# List of dataframes with the proteins that were DE in each KO strain - at alpha = 0.01
de_proteins_list_001 <- fromJSON(paste(base_dir, "Data/Other/enrichment_analysis/de_proteins_list_001.json", sep=""))

## Remove WT dataframe
de_proteins_list_001 <- de_proteins_list_001[names(de_proteins_list_001) != "WT"]

# Synthetase information
chu_synths <- as.data.frame(fread(paste(base_dir, "Data/Other/Articles/chu_2011/S3.csv", sep="")))[1:20,] 

# Yeastmine
yeastmine <- as.data.frame(fread(paste(base_dir, "Data/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))

# Before I match standard to systematic names, I need to extend the rows with multiple standard names into several rows, each with one of the systematic names, since they are all meaningful and different
chu_synths_new <- data.frame(matrix(ncol = ncol(chu_synths), nrow = 0))
colnames(chu_synths_new) <- colnames(chu_synths)
for (i in 1:nrow(chu_synths)) {
  std_name <- chu_synths$Synthetase[i]
  if (grepl("/", std_name)) {
    std_names <- str_split_1(std_name, "/")
    for (j in 1:length(std_names)) {
      new_row <- chu_synths[i, ]
      new_row$Synthetase[1] <- std_names[j]
      chu_synths_new <- rbind(chu_synths_new, new_row)
    }
  }
  else {
    new_row <- chu_synths[i,]
    chu_synths_new <- rbind(chu_synths_new, new_row)
  }
}
chu_synths_new <- chu_synths_new %>%
  rename(gene_names = Synthetase)


# Get a column with systematic gene names in the synthetase dataframe (they only have the standard naming)
chu_synths_new <- match_systematic_and_standard_protein_names(data = chu_synths_new,
                                                              yeastmine = yeastmine,
                                                              input = "standard", 
                                                              simplify = F, 
                                                              add_extra_columns = F)
```

## 7.1. Go over the KO strains and see if any of the synthetases are DE in any of them
```{r}
de_synthetases <- list()
for (i in 1:length(de_proteins_list_001)) {
  de_proteins <- de_proteins_list_001[[i]]
  temp <- de_proteins[de_proteins %in% chu_synths_new$Gene.secondaryIdentifier]
  if (length(temp) > 0) {
    de_synthetases[[names(de_proteins_list_001)[i]]] <- temp
  }
}

# Get a table summarizing this
temp <- unlist(de_synthetases)
sort(table(temp))

# Remove unnecessary variables
rm(de_proteins, temp)
```

## 7.2. Use the information obtained in the previous chunk, of which synthetases are DE in which KO strains, to capture the information from those genes in those strains 
```{r}
de_synthetases_dfs <- list()
for (i in 1:length(da_full)) {
  strain_name <- names(da_full)[[i]]
  strains_with_de_synths <- names(de_synthetases)
  if (strain_name %in% strains_with_de_synths) {
    print(i)
    temp <- da_full[[i]]
    rownames(temp) <- match_systematic_and_standard_protein_names(data = rownames(temp),
                                                                     yeastmine = yeastmine,
                                                                     input = "standard",
                                                                     simplify = T) 
    temp <- temp[rownames(temp) %in% de_synthetases[[strain_name]],]
    temp$Synthetase <- rownames(temp)
    temp$Strain.Name <- strain_name
    de_synthetases_dfs[[strain_name]] <- temp
  }
}

# Turn the resulting list into a single dataframe
de_synthetases_df <- bind_rows(de_synthetases_dfs)
rownames(de_synthetases_df) <- NULL

# Add a column with the standard names for the tRNA synthetase genes
temp <- match_systematic_and_standard_protein_names(data = as.character(de_synthetases_df$Synthetase),
                                                    yeastmine = yeastmine, 
                                                    input = "systematic",
                                                    simplify = T)
de_synthetases_df$Synthetase_standard <- temp
de_synthetases_df <- de_synthetases_df %>%
  rename(Synthetase_systematic = Synthetase)
```

Add 2 columns: one for the amino acid which the KOd tRNA carries, another for the the amino acid that is loaded by the synthetase found to be DE
```{r}
# Amino acid carried by the KOd tRNA
temp <- master_dataset %>%
  dplyr::select(Strain.Name, Isotype_from_anticodon_1_letter)
de_synthetases_df <- left_join(de_synthetases_df, temp, by = "Strain.Name") %>%
  rename(AA = Isotype_from_anticodon_1_letter)

temp <- amino_acids %>%
  dplyr::select(AA, amino_acid_charge, amino_acid_type) %>%
  rename(AA_charge_tRNA = amino_acid_charge,
         AA_type_tRNA = amino_acid_type)
de_synthetases_df <- left_join(de_synthetases_df, temp, by = "AA") %>%
  rename(AA_carried_by_tRNA = AA)

# Amino acid loaded by the synthetase
temp <- amino_acids %>%
  dplyr::select(Amino_acid, AA, amino_acid_charge, amino_acid_type) %>%
  rename(AA_loaded_by_synthetase = AA,
         AA_charge_synth = amino_acid_charge,
         AA_type_synth = amino_acid_type)

temp_2 <- left_join(chu_synths_new, temp, by = "Amino_acid") %>%
  dplyr::select(Gene.secondaryIdentifier, AA_charge_synth, AA_type_synth) %>%
  rename(Synthetase = Gene.secondaryIdentifier)

temp_3 <- temp_2 %>%
  group_by(Synthetase) %>%
  summarise(text=paste(AA_charge_synth, collapse = ",")) %>%
  rename(AA_charge_synth = text)

temp_4 <- temp_2 %>%
  group_by(Synthetase) %>%
  summarise(text=paste(AA_type_synth, collapse = ",")) %>%
  rename(AA_type_synth = text)

de_synthetases_df <- left_join(de_synthetases_df, temp_3, by = "Synthetase")
de_synthetases_df <- left_join(de_synthetases_df, temp_4, by = "Synthetase")

temp <- left_join(chu_synths_new, temp, by = "Amino_acid") %>%
  dplyr::select(Gene.secondaryIdentifier, AA_loaded_by_synthetase) %>%
  rename(Synthetase = Gene.secondaryIdentifier) %>%
  group_by(Synthetase) %>%
  summarise(text=paste(AA_loaded_by_synthetase, collapse = ",")) %>%
  rename(AA_loaded_by_synthetase = text)
de_synthetases_df <- left_join(de_synthetases_df, temp, by = "Synthetase") %>%
  rename()
```










