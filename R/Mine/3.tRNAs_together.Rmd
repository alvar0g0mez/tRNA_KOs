---
title: "tRNAs"
author: "Álvaro Gómez Pérez"
date: "2024-11-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Packages
```{r}
library(dplyr)
library(data.table)
library(limma)
library(ggplot2)
library(patchwork)
library(tidyr)
library(tibble)
library(stringr)
library(gprofiler2)
library(xlsx)
library(stringr)
library(gridExtra)
library(grid)
suppressPackageStartupMessages(library(ComplexHeatmap))
suppressPackageStartupMessages(library(circlize))
library(factoextra)
library(glue)
library(dendextend)
library(ggrepel)
library(ggvenn)
library(tidyr)
library(interactions)
library(performance)
library(MASS)
library(jsonlite)
library(UpSetR)
library(ComplexUpset)
library(wesanderson)
library(forcats)
library(ggpubr)
library(xtable)
library(clusterProfiler)
library(org.Sc.sgd.db)
library(fgsea)
library(limpa)
```

Set parameters
```{r}
# Significance level to be used for all tests and plots in this file
alpha <- 0.05

# Significance level as a plain string to use when loading or writing files
alpha_plain <- str_replace(as.character(alpha), "\\.", "")

# Minimum threshold for the average log2-expression across all samples in order to keep a protein in the data before DE analysis
mean_log2_across_all_samples_threshold <- 2

# Minimum threshold for the variance of the log2-expression across all samples in order to keep a protein in the data before DE analysis
var_across_log2_all_samples_threshold <- 0.6

# Separate significance level, the one used for the enrichment analysis
alpha_enrichment <- 0.05

# Significance level above as a plain string to use when loading or writing files
alpha_enrichment_plain <- str_replace(as.character(alpha_enrichment), "\\.", "")

# Log-fold change limit to be considered "biologically significant"
lfc_threshold <- 0.5

# Set directories to be used
working_from = "charite"

if (working_from == "home") {
  base_dir = "/home/alvaro/MyStuff/"
} else
if (working_from == "charite") {
  base_dir = "C:/MyStuff/"
}
```





################################################################################
# 1. Load data and initial analysis
################################################################################
## 1.1. Load data
```{r}
# Proteomics data
proteomics_raw <- read.delim2(paste(base_dir, 'tRNA_KOs/Data/proteomics_data/AlternativeAAUsage-tRNA_peptidecentric_ProteinMaxLFQ_driftcorrected_batchcorrected_onWTs.tsv', sep=""), header = T)

# Sample layout
sample_layout <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/basic/sample_layout_alvaro.tsv", sep="")))

# The master tRNA dataset
master_dataset <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/basic/master_tRNA_dataset.csv", sep="")))

# The ODs
od <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/basic/OD_final.csv", sep = "")))

# Phenotypic data
phenotypic_data <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/Articles/bloom_ackermann_2014/phenotypic_results_full.tsv", sep="")))

# UniProt dataset
uniprot_db <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv", sep="")))

# Import the functions I have created in another file
source(paste(base_dir, "tRNA_KOs/Code/R/Mine/0.general_use_functions.R", sep=""))


# limpa output
dpcfit <- readRDS(paste(base_dir, "tRNA_KOs/Data/limpa_analysis/dpcfit.rds", sep=""))
y.protein <- readRDS(paste(base_dir, "tRNA_KOs/Data/limpa_analysis/y.protein.rds", sep=""))

## Set this so I don't have to change its name in the code below
trna_ko <- y.protein$E
```


### 1.2. Perform DE analysis - with limpa! Using this one from now on
Load results from protein inference step - this step was run once and took extremely long, so we just saved the results and load them now
```{r}
# Prepare to perform the DEA
## Change the protein names from the UniProt ones (produced by DIA-NN) to systematic Sc ones
## Some systematic names contain 2 of them - I have to deal with that - I'M TAKING THE FIRST ONE, HOPE THAT'S NOT TOO BAD
temp_uniprot <- uniprot_db %>%
  dplyr::select(Entry, `Gene Names (ordered locus)`) %>%
  dplyr::rename(Gene.secondaryIdentifier = `Gene Names (ordered locus)`)
temp_rownames <- data.frame(rownames(y.protein$E)) 
colnames(temp_rownames) <- "Entry"
temp_rownames <- temp_rownames %>%
  left_join(temp_uniprot, by = "Entry")

remove_second_systematic_name <- function(name) {
  if (grepl(";", name)) {
    new_name <- substr(name, 0, str_locate(name, ";")[1]-1)
  }
  else {
    new_name <- name
  }
  return(new_name)
}
temp_rownames$Gene.secondaryIdentifier <- sapply(temp_rownames$Gene.secondaryIdentifier, remove_second_systematic_name)

rownames(y.protein$E) <- temp_rownames$Gene.secondaryIdentifier

## Get the names of all KOs we have, and set WT as the reference
trna_levels <- c()
for (i in 1:ncol(trna_ko)) {
  sample_name <- colnames(trna_ko)[i]
  strain_name <- sample_layout$Strain.Name[sample_layout$final_proteomics_colnames == sample_name]
  if (length(strain_name) > 1) {
    strain_name <- strain_name[1]
  }
  trna_levels <- c(trna_levels, strain_name)
}
trna_levels <- as.factor(trna_levels)
trna_levels <- relevel(trna_levels, ref = "WT")

## Generate design matrix
mm <- model.matrix(~ 0 + trna_levels)
colnames(mm) <- levels(trna_levels)

fit <- dpcDE(y.protein, mm)
```

Quality control
```{r}
# Limpa QC plots
#plotDPC(dpcfit)
#plotMDSUsingSEs(y.protein)

## Average expression of each protein across all samples - need to get this working for limpa!!
#hist(rowMeans(y.protein))
#hist(apply(y.protein, 1, var), breaks = 60)
#mean(apply(y.protein, 1, var))
#median(apply(y.protein, 1, var))
```



MANUAL DE ANALYSIS FOR ONE SINGLE STRAIN - DELETE ONCE I'VE FIGURED OUT WHAT'S GOING ON WITH THE VOLCANO PLOTS
```{r}
df_wts <- as.data.frame(y.protein$E) %>%
  dplyr::select(contains("WT"))
df_strain <- as.data.frame(y.protein$E) %>%
  dplyr::select(contains("tA(AGC)D"))

p.vals <- c()
logFCs <- c()
for (i in 1:nrow(df_wts)) {
  wts <- as.numeric(df_wts[i,])
  strain <- as.numeric(df_strain[i,])
  
  p.vals <- c(p.vals, wilcox.test(wts, strain)$p.value)
  logFCs <- c(logFCs, log2(mean(strain)/mean(wts)))
}
p.adjusted <- p.adjust(p.vals, method = "BH")

plot_df <- data.frame(p.vals, logFCs, p.adjusted) %>%
  dplyr::mutate(status_adjusted = case_when(p.adjusted < 0.05 & logFCs > 0.5 ~ "Up-regulated",
                                   p.adjusted < 0.05 & logFCs < 0.5 ~ "Down-regulated",
                                   TRUE ~ "Un-affected"),
                status_unadjusted = case_when(p.vals < 0.05 & logFCs > 0.5 ~ "Up-regulated",
                                   p.vals < 0.05 & logFCs < 0.5 ~ "Down-regulated",
                                   TRUE ~ "Un-affected")) %>%
  dplyr::arrange(p.vals) %>%
  dplyr::mutate(rank = seq(1, nrow(plot_df), 1),
                BH_threshold = (2949/rank)*p.vals, 
                significant_manually = case_when(p.vals < BH_threshold ~ "Yes",
                                                 TRUE ~ "No"))

# Get the manually corrected p-values
p.adjusted.manually <- c()

for (i in 1:nrow(plot_df)) {
  this_rank <- plot_df$rank[i]
  p.adjusted.manually <- c(p.adjusted.manually, min(1, min(plot_df$BH_threshold[plot_df$rank >= this_rank])))
}
plot_df$p.adjusted.manually <- p.adjusted.manually

ggplot(data = plot_df, aes(x = logFCs, y = -log10(p.adjusted), col = status_adjusted)) +
  geom_point() +
  geom_vline(xintercept = 0.5, linetype = "dashed", col = "grey", linewidth = 1) +
  geom_vline(xintercept = -0.5, linetype = "dashed", col = "grey", linewidth = 1) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", col = "grey", linewidth = 1) +
  theme_light() + 
  labs(title = "Adjusted p-values")

ggplot(data = plot_df, aes(x = logFCs, y = -log10(p.vals), col = status_unadjusted)) +
  geom_point() +
  geom_vline(xintercept = 0.5, linetype = "dashed", col = "grey", linewidth = 1) +
  geom_vline(xintercept = -0.5, linetype = "dashed", col = "grey", linewidth = 1) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", col = "grey", linewidth = 1) +
  theme_light() + 
  labs(title = "Raw p-values")
```




Perform the DE analysis
THERE ARE STILL WARNINGS IN THE FOR LOOP, SHOULD LOOK INTO THAT BUT RESULTS SEEM REASONABLE
```{r}
# This is what they provide, I wonder if they use the kind of design matrix that Alexis used
# I did not, so I am going to introduce contrasts here? I hope that makes sense?
## Create all contrasts - need to susbtitute parentheses in strain names by dots so that it runs...
treatments <- colnames(fit$coefficients)
treatments <- sapply(treatments, function(x) str_replace(x, "\\(", "."))
treatments <- sapply(treatments, function(x) str_replace(x, "\\)", "."))
design <- model.matrix(~ 0 + treatments)
colnames(design) <- treatments
contrast_list <- paste0(treatments, "-WT")

## Need to change parentheses to dots in the fit object as well so they match...
colnames(fit$coefficients) <- sapply(colnames(fit$coefficients), function(x) str_replace(x, "\\(", "."))
colnames(fit$coefficients) <- sapply(colnames(fit$coefficients), function(x) str_replace(x, "\\)", "."))

## Introduce the contrasts and run eBayes for them, 10 at a time
da <- list()
batch_size <- 10
n_batches <- ceiling(ncol(fit$coefficients)/batch_size)

for (i in 1:n_batches) {
  contrast_subset <- contrast_list[((i - 1) * batch_size + 1):min(i * batch_size, length(contrast_list))]
  contrast.matrix <- makeContrasts(contrasts = contrast_subset, levels = design)
  
  fit2 <- contrasts.fit(fit, contrast.matrix)
  fit3 <- eBayes(fit2, robust = TRUE, trend = TRUE)
  
  new_contrast_names <- c()
  
  # Store topTables for each contrast
  for (contrast_name in colnames(contrast.matrix)) {
    new_name <- substr(contrast_name, 1, str_locate(contrast_name, "-")-1)
    if (grepl(".", new_name)) {
        substr(new_name, 3, 3) <- "("
        substr(new_name, 7, 7) <- ")"
    }
    da[[new_name]] <- topTable(fit3, coef = contrast_name, adjust.method = 'BH', number = Inf, sort.by = 'none')
    da[[new_name]]$Strain.Name <- rep(new_name, nrow(da[[new_name]]))
  }
}


# Plot p-value distribution per strain - another check for the volcano plots
strains <- unique(da$Strain.Name)
plot_list <- list()

for (i in 1:length(strains)) {
  strain <- strains[i]
  temp <- da %>%
    dplyr::filter(Strain.Name == strain)
  plot_list[[i]] <- ggplot(data = temp, aes(x = P.Value)) +
    geom_histogram(col = "black", fill = "grey") +
    theme_light() +
    xlab("Raw p-value") +
    ylab("Count") +
    labs(title = glue("{strain}"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "tRNA_KOs/Output/Plots/p_value_histograms/pval_hists_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)
```

Save DE proteins for GO enrichment analysis
```{r}
yeastmine <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))
de_proteins_list <- list()
for (i in 1:length(da)) {
  temp <- da[[i]]
  temp <- na.omit(temp)
  
  # Collect protein names and turn them all into systematic notation
  general_protein_names <- rownames(temp)[(temp$adj.P.Val < alpha) &
                                          (temp$logFC > lfc_threshold | temp$logFC < -lfc_threshold)]
  standard_protein_names <- general_protein_names[general_protein_names %in% yeastmine$Gene.symbol]
  systematic_protein_names <- general_protein_names[general_protein_names %in% yeastmine$Gene.secondaryIdentifier]
  final_protein_names <- c(systematic_protein_names, match_systematic_and_standard_protein_names(data = standard_protein_names,
                                                                                                 yeastmine = yeastmine,
                                                                                                 input = "standard",
                                                                                                 simplify = T))
  
  # Save protein names
  de_proteins_list[[names(da)[i]]] <- final_protein_names
}
output_file <- paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/de_proteins_list_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep="")
write_json(de_proteins_list, path=output_file)
```

Save all proteins for GSEA - da as a list
```{r}
write_json(da, path=paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/da_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), pretty = T)
```

Finish processing the DE analysis results
```{r}
# Format data
da <- bind_rows(da) %>%
  dplyr::mutate(protein = rep(rownames(da[[1]]), times = length(da))) %>%
  dplyr::distinct(Strain.Name, protein, logFC, .keep_all = T)
temp <- sample_layout %>%
  dplyr::distinct(Strain.Name, .keep_all = T)
da <- left_join(da, temp, by = "Strain.Name") %>%
  dplyr::relocate(Strain.Name, .before = logFC) %>%
  dplyr::relocate(protein, .after = Strain.Name) %>%
  filter(Strain.Name != "WT")

da <- da %>%
  dplyr::select(protein, Strain.Name, logFC, P.Value, adj.P.Val) %>%                              # From here on in this function it's added by me
  dplyr::mutate(diffexpressed_adjusted = case_when((logFC > lfc_threshold) & (adj.P.Val < alpha) ~ "Up_regulated",
                                            (logFC < -lfc_threshold) & (adj.P.Val < alpha) ~ "Down_regulated",
                                            TRUE ~ "Not_significant"),
         diffexpressed_non_adjusted = case_when((logFC > lfc_threshold) & (P.Value < alpha) ~ "Up_regulated",
                                                (logFC < -lfc_threshold) & (P.Value < alpha) ~ "Down_regulated",
                                                TRUE ~ "Not_significant"))

da <- da %>%
  dplyr::distinct(Strain.Name, protein, logFC, .keep_all = T)

# Now I have da as a dataframe, with the addition that it contains information on which proteins are up- or down-regulated
write_json(da, path=paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/da_df_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), pretty = T)


# Add a column to da with the number of replicates per KO - by me
unique_KOs <- unique(da$Strain.Name)
replicates <- c()
for (i in 1:length(unique_KOs)) {
  KO <- unique_KOs[i]
  replicates <- c(replicates, sum(grepl(KO, colnames(trna_ko), fixed = T)))
}
KOs_replicates <- data.frame(unique_KOs, replicates)
colnames(KOs_replicates) <- c("Strain.Name", "Replicate_num")
da <- merge(da, KOs_replicates, by = "Strain.Name")

# Responsiveness
responsiveness <- da %>%
  group_by(Strain.Name) %>%
  summarise(nDEP = sum(abs(logFC) >= lfc_threshold & adj.P.Val <= alpha, na.rm = T),
            Up_regulated_adjusted = sum(abs(logFC) >= lfc_threshold & adj.P.Val <= alpha & diffexpressed_adjusted == "Up_regulated", na.rm = T),
            Down_regulated_adjusted = sum(abs(logFC) >= lfc_threshold & adj.P.Val <= alpha & diffexpressed_adjusted == "Down_regulated", na.rm = T),
            Up_regulated_non_adjusted = sum(abs(logFC) >= lfc_threshold & P.Value <= alpha & diffexpressed_non_adjusted == "Up_regulated", na.rm = T),
            Down_regulated_non_adjusted = sum(abs(logFC) >= lfc_threshold & P.Value <= alpha & diffexpressed_non_adjusted == "Down_regulated", na.rm = T),
            Replicate_num = mean(Replicate_num)) %>%
  mutate(Amino_acid_1_letter = str_sub(Strain.Name, 2, 2),
         chromosome_letter = substr(Strain.Name, 8, 8),
         anticodon = str_extract(Strain.Name, "(?<=\\()[[:alpha:]]{3}(?=\\))"),
         up_down_regulated_ratio_adjusted = Up_regulated_adjusted/Down_regulated_adjusted,
         up_down_regulated_ratio_non_adjusted = Up_regulated_non_adjusted/Down_regulated_non_adjusted) %>%
  arrange(Amino_acid_1_letter) %>%
  mutate(anticodon = factor(anticodon, levels = unique(anticodon)))

# Add all amino acid names
amino_acids <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/GtRNAdb/amino_acids.csv", sep="")))
responsiveness <- left_join(responsiveness, amino_acids, by = "Amino_acid_1_letter")

# Save responsiveness dataset
fwrite(responsiveness, paste(base_dir, "tRNA_KOs/Data/produced_during_analysis/responsiveness_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep=""))

# Save results from the DE analysis in the same way as in the file where I do DE separately for each batch
DE <- list(fit = fit,
            fit2 = fit2,
            da = da, 
            responsiveness= responsiveness)



# Remove unnecesary variables
rm(amino_acids, DE, de_proteins_list, fit, fit2, KOs_replicates, mm, temp, trna_levels, contrast.matrix, design, fit3,
   yeastmine, final_protein_names, general_protein_names, i, KO, output_file, replicates, sample_name, standard_protein_names, strain_name,
   systematic_protein_names, unique_KOs, trna_ko, dpcfit)
```


## 1.3. CV analysis
CV QC on the data for DE analysis
```{r}
# Calculate CV
proteomics <- as.data.frame(y.protein$E)
proteomics$protein <- rownames(proteomics)
proteomics_data_log2_long <- pivot_longer(proteomics, cols = !protein, names_to = "final_proteomics_colnames")
proteomics_layout <- sample_layout %>%
  dplyr::select(final_proteomics_colnames, Strain.Name)
proteomics_data_log2_long <- left_join(proteomics_data_log2_long, proteomics_layout, by = "final_proteomics_colnames") %>%
  group_by(Strain.Name, protein) %>%
  dplyr::mutate(CV_strain = robust_cv(value)) %>%                    # CV for each protein, across the samples of the same family (biological replicates), across all proteins
  ungroup() %>%
  group_by(protein) %>%
  dplyr::mutate(CV_protein = robust_cv(value)) %>%                   # CV for a protein, across all samples
  ungroup()


# Plot
plot_cv_per_protein <- proteomics_data_log2_long %>%                       # dataset for plotting CV per protein
  dplyr::select(protein, CV_protein) %>%
  dplyr::distinct(protein, .keep_all = T)

plot_cv_per_strain <- proteomics_data_log2_long %>%
  dplyr::select(protein, Strain.Name, CV_strain)




ggplot(data = plot_cv_per_protein, aes(x = protein, y = CV_protein)) +
  geom_point() +
  theme_light() +
  theme(panel.grid.major.x = element_blank(),                              # remove the vertical grid lines
        panel.grid.major.y = element_line(linewidth = .1, color="black"),  # explicitly set the horizontal lines (or they will disappear too)
        axis.text.x=element_blank(),                                       # remove x axis labels
        axis.ticks.x=element_blank()) +                                    # remove x axis ticks
  xlab("Proteins") +
  ylab("CV per protein") +
  labs(title = "Coefficient of variation (CV) per protein",
       subtitle = "Across all samples") +
  geom_text_repel(data = subset(plot_cv_per_protein, CV_protein > 0.4),
                  aes(x = protein, y = CV_protein, label = protein),
                  size = 4)
proteins_with_high_CV <- plot_cv_per_protein$protein[plot_cv_per_protein$CV_protein > 0.4]


ggplot(data = plot_cv_per_strain, aes(x = Strain.Name, y = CV_strain)) +
  geom_boxplot(outliers = F) +
  theme_light()

strains_with_high_CV <- plot_cv_per_strain$Strain.Name[plot_cv_per_strain$CV_strain > 0.35]
```

Look at expression of each of the proteins with the high CV in detail
```{r}
# Fix the situation with 2 tRNA_KOs being present twice (so 6 replicates for each instead of 3) - just going to take the average between the replicated #samples
## Come up with the averages
n_occur <- data.frame(table(colnames(proteomics)))
repeated_samples <- as.character(n_occur$Var1)[n_occur$Freq > 1]

out_temp <- data.frame(matrix(ncol = 0, nrow = nrow(proteomics)))
for (i in 1:length(repeated_samples)) {
  strain <- repeated_samples[i]
  temp <- proteomics[, colnames(proteomics) == strain]
  temp[,1] <- as.numeric(temp[,1])
  temp[,2] <- as.numeric(temp[,2])
  out <- c(apply(temp, 1, mean))
  out_temp[,i] <- out
}
colnames(out_temp) <- repeated_samples

## Remove original columns from dataframe and add the averaged ones
proteomics_no_repeated_columns <- proteomics[,!(colnames(proteomics) %in% repeated_samples)]
proteomics_no_repeated_columns <- cbind(proteomics_no_repeated_columns, out_temp)

# Create dataset for ploting
temp_layout <- sample_layout %>%
  dplyr::select(final_proteomics_colnames, Strain.Name, Anticodon, Amino_acid_1_letter)
high_cv_proteins_proteomics <- proteomics_no_repeated_columns %>%
  dplyr::filter(protein %in% proteins_with_high_CV) %>%
  pivot_longer(cols = !protein, names_to = "final_proteomics_colnames") %>%
  left_join(temp_layout, by = "final_proteomics_colnames") %>%
  dplyr::mutate(Anticodon = case_when(Strain.Name == "WT" ~ "WT",
                                      TRUE ~ Anticodon),
                Amino_acid_1_letter = case_when(Strain.Name == "WT" ~ "WT",
                                                            TRUE ~ Amino_acid_1_letter))

# Plot
proteins <- unique(high_cv_proteins_proteomics$protein)

## Iterate over the proteins and make the same plots for all of them
for (i in 1:length(proteins)) {
  protein_selected <- proteins[i]
  
  # Plot abundance of the protein per amino acid carried 
  plot <- ggplot(data = subset(high_cv_proteins_proteomics, protein == protein_selected), aes(x = Amino_acid_1_letter, y = value)) +
          geom_boxplot(fill = "grey") +
          theme_light() +
          xlab("Amino acid") +
          ylab("log2(protein abundance)") +
          labs(title = glue("Abundance of {protein_selected} by amino acid carried by the KOd tRNA"))
  print(plot)
  
  myLetters <- letters[1:26]                            # Need this to be able to re-order anticodons by amino acid
  myLetters <- c(myLetters, "wt")                       # Need to add this so it doesn't break down because "WT" is not a letter
  
  # Plot abundance of the protein per anticodon (tRNA family)
  plot_2 <- ggplot(data = subset(high_cv_proteins_proteomics, protein == protein_selected), 
                   aes(x = fct_reorder(Anticodon, match(tolower(Amino_acid_1_letter), myLetters)), y = value, fill = Amino_acid_1_letter)) +
            geom_boxplot() +
            theme_light() +
            theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
          xlab("Anticodon") +
          ylab("log2(protein abundance)") +
          labs(title = glue("Abundance of {protein_selected} by anticodon in the KOd tRNA"),
               fill = "Amino acid")
  print(plot_2)
}
```



## 1.4. Volcano plots for the differential expression
```{r}
# One plot per KO and save them to a PDF - for all KOs
## Come up with the list of plots
plot_list <- list()
for (i in 1:length(levels(as.factor(da$Strain.Name)))) {
  trna <- levels(as.factor(da$Strain.Name))[i]
  temp <- da %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = glue("{trna} - {unique(temp$Replicate_num)} replicates")) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "tRNA_KOs/Output/Plots/Volcano_plots/volcano_plots_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)




# One plot per KO and save them to a PDF - for all KOs
## Come up with the list of plots
plot_list <- list()
for (i in 1:length(levels(as.factor(da$Strain.Name)))) {
  trna <- levels(as.factor(da$Strain.Name))[i]
  temp <- da %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(P.Value), col = diffexpressed_non_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = trna) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "tRNA_KOs/Output/Plots/Volcano_plots/volcano_plots_per_KO_all_KOs_non_adjusted_p_values_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)




# One plot per KO and save them to a PDF - only for KOs with at least 1 DE protein
## Remove KOs with 0 DE proteins
KOs_with_DE_proteins <- responsiveness$Strain.Name[responsiveness$nDEP > 0]
da_only_KOs_with_DE_proteins <- da[da$Strain.Name %in% KOs_with_DE_proteins,]

## Come up with the list of plots
plot_list <- list()
for (i in 1:length(KOs_with_DE_proteins)) {
  trna <- KOs_with_DE_proteins[i]
  temp <- da_only_KOs_with_DE_proteins %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = trna) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "tRNA_KOs/Output/Plots/Volcano_plots/volcano_plots_per_KO_KOs_with_DE_proteins_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)
```
--> Lots of the volcano plots are completely flat, just dots at the bottom. It would be nice if I could compare this to which are minor and which are major tRNA copies within each family actually, that would be great, but we don't have that information, do we? We have it for one family I think, I could check that, and then for the other families I would have to make the conclusions about "major" and "minor" myself precisely based on this, no?

Volcano plot for all KO strains together
```{r}
ggplot(data = da, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = "Volcano plot for all KO strains together",
         subtitle = "Adjusted p-values") +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))


ggplot(data = da, aes(x = logFC, y = -log10(P.Value), col = diffexpressed_non_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = "Volcano plot for all KO strains together",
         subtitle = "Raw p-values") +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))


# Remove unused objects
#rm(list = c("my_grobs", "plot_list", "KOs_with_DE_proteins", "temp", "da_only_KOs_with_DE_proteins", "trna", "i", "output_file"))
```

Evaluate distribution of p-values and fold-changes
```{r}
ggplot(data = da, aes(x = P.Value)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = "Distribution of raw p-values for DE", 
       subtitle = "All KO strains") +
  xlab("p-value") +
  ylab("Count")

ggplot(data = da, aes(x = adj.P.Val)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = "Distribution of adjusted p-values for DE", 
       subtitle = "All KO strains") +
  xlab("p-value") +
  ylab("Count")

ggplot(data = da, aes(x = logFC)) +
  geom_histogram(col = "black", fill = "grey", binwidth = 0.2) +
  theme_light() +
  labs(title = "Distribution of logFC values for DE", 
       subtitle = "All KO strains") +
  xlab("logFC") +
  ylab("Count")
```



## 1.5. Check number of DE proteins and also volcano plots for the UCU family - minor vs. major members
```{r}
# Just number of DE proteins
UCU_major_minor <- phenotypic_data %>% 
  filter(UCU_family != "No") %>%
  dplyr::select(Strain.Name, UCU_family)

UCU_responsiveness <- responsiveness%>% filter(anticodon == "UCU")

UCU_family <- full_join(UCU_major_minor, UCU_responsiveness, by = "Strain.Name")


# Volcano plots
## Keep only KOs in UCU family
KOs_in_UCU_family <- UCU_family$Strain.Name
da_only_KOs_from_UCU_family <- da[da$Strain.Name %in% KOs_in_UCU_family,]


## Come up with the list of plots
plot_list <- list()
for (i in 1:length(KOs_in_UCU_family)) {
  trna <- KOs_in_UCU_family[i]
  plot_title <- paste(trna, UCU_family$UCU_family[UCU_family$Strain.Name == trna], sep = "_")
  temp <- da_only_KOs_from_UCU_family %>% filter(Strain.Name == trna)
  plot_list[[i]] <- ggplot(data = temp, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed_adjusted)) +
    geom_point() +
    geom_hline(yintercept = -log10(alpha), linetype = "dashed", col = "gray") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = "dashed", col = "gray") +
    theme_light() +
    theme(legend.position = "none") +
    labs(title = plot_title) +
    scale_color_manual(values = c(Down_regulated = "#80AAFF", Not_significant = "#808080", Up_regulated = "#FF8080"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_location <- paste(base_dir, "tRNA_KOs/Output/Plots/Volcano_plots/volcano_plots_per_KO_UCU_family_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep="")
ggsave(
   filename = output_location, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)


# Remove unused objects
rm(list = c("my_grobs", "plot_list", "KOs_in_UCU_family", "temp", "da_only_KOs_from_UCU_family", "trna", "plot_title", "UCU_major_minor", "UCU_responsiveness", "i", "UCU_family", "output_location"))
```



## 1.6. Check number of DE proteins vs. replicates per KO
```{r}
ggplot(data = responsiveness, aes(x = as.factor(Replicate_num), y = nDEP, col = as.factor(Replicate_num))) +
  geom_boxplot() +
  geom_jitter(position=position_jitter(0.2)) +
  theme_light() +
  xlab("Number of replicates")

replicate_num_vs_nDEP_cor <- cor(responsiveness$nDEP, responsiveness$Replicate_num)
replicate_num_vs_nDEP_cor

# Remove unnecessary objects
rm(replicate_num_vs_nDEP_cor)
```
--> The point with this was that maybe a larger number of replicates causes more nDEP just because it's easier to achieve significance. However, there seems to be no correlation at all, I think that's actually good because it means that the nDEP will be only influenced by what is going on with the tRNA KOs? Even though that effect could be already confounding my results in this boxplot



## 1.7. Identify major and minor tRNA genes myself for all strains
Original version, general histogram and histograms per isoacceptors, coloring by anticodon
```{r}
responsiveness <- responsiveness %>%
  group_by(anticodon) %>% 
  summarize(Family_count = n(), across()) %>%
  ungroup()

# Histogram of avg_nDEP for each KO strain
ggplot(data = responsiveness, aes(x = nDEP)) +
  geom_histogram(binwidth = 1, color="black", fill="grey") +
  theme_light() +
  xlab("nDEP per tRNA KO") +
  ylab("Count") +
  labs(title = "Frequency of nDEP across all tRNA KO strains")

# Given this histogram, I used to define the threshold to make out major and minor tRNA genes - I had it at 2 - now I do this in a bit of a more complex way (below)

# Define a column with "minor"-"major", so that I can check how many major and minor ones there are per family (I could also do this directly based on the avg_nDEP tbh but oh well)
responsiveness <- responsiveness %>%
  group_by(anticodon) %>%
  mutate(family_max = max(nDEP)) %>%
  ungroup() %>%
  #mutate(Gene_type = case_when(nDEP <= 20 ~ "Minor",                                 This is how I did it before
  #                             nDEP > 20 & nDEP < 0.5*family_max ~ "Minor",
  #                             nDEP > 0.75*family_max ~ "Major")) %>%
  mutate(Gene_type = case_when(nDEP <= 20 ~ "-",
                               nDEP > 0.55*family_max ~ "Major",                      # Current version
                               TRUE ~ "Minor")) %>%
  group_by(anticodon) %>%
  summarize(Major_count = sum(Gene_type == "Major"), across()) %>%
  ungroup() %>%
  dplyr::select(-family_max)

# Save this new version of responsiveness
fwrite(responsiveness, paste(base_dir, "tRNA_KOs/Data/produced_during_analysis/responsiveness_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep=""))

# Get a dataframe with the size of each family, the number of those genes we have as KOs in the experiment, and how many of them are major, and plot this
colnames(master_dataset)[colnames(master_dataset) == "family_size"] <- "Family_size"
family_sizes <- left_join(master_dataset, responsiveness, by = "Strain.Name")
family_sizes <- family_sizes %>%
  filter(Strain.Name %in% responsiveness$Strain.Name) %>%                       # Filtered on KOd before, but that kept strains that were removed during filtering
  dplyr::select(anticodon, Family_size, Family_count, Major_count) %>%
  distinct(anticodon, .keep_all = T)


# Get long version to plot, and re-order the anticodons by family size, in order to keep that order for the x axis of the plot - I think I could have avoided this by using geom_col()? But I didn't know it yet
family_sizes <- family_sizes[order(-family_sizes$Family_size), ]
family_sizes_long <- family_sizes %>% pivot_longer(!anticodon, names_to = "Type", values_to = "Count")
family_sizes_long$anticodon <- factor(family_sizes_long$anticodon, levels = family_sizes$anticodon)
family_sizes_long$Type <- factor(family_sizes_long$Type, levels = c("Family_size", "Family_count", "Major_count"))

colnames(family_sizes_long)[colnames(family_sizes_long) == "anticodon"] <- "Anticodon"


# Plot this
ggplot(data = family_sizes_long, aes(x = Anticodon, y = Count, fill = Type)) +
  geom_bar(position="dodge", stat="identity") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
        legend.position = "none")


# What is the relationship between Family_count and Major_count?
ggplot(data = family_sizes, aes(x = Family_count, y = Major_count)) +
  geom_point() +
  geom_abline() +
  theme_light() +
  xlab("Genes in this family in the experiment") +
  ylab("Major genes detected in the family") +
  geom_text_repel(data = subset(family_sizes, Major_count/Family_count >= 1 | Major_count/Family_count < 0.3),
                  aes(x = Family_count, y = Major_count, label = anticodon),
                  size = 4)

# Add family size information to responsiveness dataset
temp <- family_sizes %>%
  dplyr::select(anticodon, Family_size)
responsiveness <- left_join(responsiveness, temp, by = "anticodon") %>%
  mutate(perc_family = Family_count/Family_size)


# Produce a single histogram like the one at the beginning of this chunk for each set of tRNA isoacceptors - and save them to a PDF
## Create empty list of plots
plot_list <- list()

## Generate the plots and add them to the list
aas <- sort(levels(as.factor(responsiveness$Amino_acid_name)))
for (i in 1:length(aas)) {
  aa <- aas[i]
  temp <- responsiveness %>%
    filter(Amino_acid_name == aa)
  plot_list[[aa]] <- ggplot(data = temp, aes(x = nDEP, fill = anticodon)) +
    geom_histogram(binwidth = 1, stat = StatBin2) +
    theme_light() +
    xlab("nDEP") +
    ylab("Count") +
    labs(title = glue("{aa}"))
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "tRNA_KOs/Output/Plots/nDEP_hists_per_isoacceptors_color_by_codon_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)


# Remove unnecessary variables
rm(family_sizes_long, my_grobs, plot_list, temp, aa, aas, output_file, i)
```

Histograms by anticodon, color by full sequence of the tRNA molecule (both DNA and mature sequences) - also not coloring by anything (TO DO)
```{r}
# Add columns with DNA and mature sequences to responsiveness dataframe
temp <- master_dataset %>%
  dplyr::select(Strain.Name, DNA_sequence, mature_sequence)
responsiveness <- left_join(responsiveness, temp, by = "Strain.Name")

## Create empty list of plots
plot_list_DNA_seq <- list()
plot_list_mature_seq <- list()
plot_list_not_colored <- list()

## Generate the plots and add them to the list
anticodons <- sort(unique(as.character(responsiveness$anticodon)))
for (i in 1:length(anticodons)) {
  my_anticodon <- anticodons[i]
  temp <- responsiveness %>%
    filter(anticodon == my_anticodon)
  
  # Color by DNA seq
  plot_list_DNA_seq[[my_anticodon]] <- ggplot(data = temp, aes(x = nDEP, col = DNA_sequence, fill = DNA_sequence)) +
    geom_histogram(bins = 100, stat = StatBin2) +
    theme_light() +
    xlab("nDEP") +
    ylab("Count") +
    labs(title = glue("{my_anticodon}")) + 
    theme(legend.position = "none")
  
  # Color by mature seq
  plot_list_mature_seq[[my_anticodon]] <- ggplot(data = temp, aes(x = nDEP, col = mature_sequence, fill = mature_sequence)) +
    geom_histogram(bins = 100, stat = StatBin2) +
    theme_light() +
    xlab("nDEP") +
    ylab("Count") +
    labs(title = glue("{my_anticodon}")) + 
    theme(legend.position = "none")
  
  # Not coloring by anything
  plot_list_not_colored[[my_anticodon]] <- ggplot(data = temp, aes(x = nDEP)) +
    geom_histogram(bins = 100, stat = StatBin2) +
    theme_light() +
    xlab("nDEP") +
    ylab("Count") +
    labs(title = glue("{my_anticodon}")) + 
    theme(legend.position = "none")
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs_DNA <- lapply(plot_list_DNA_seq, ggplotGrob)
my_grobs_mature <- lapply(plot_list_mature_seq, ggplotGrob)
my_grobs_not_colored <- lapply(plot_list_not_colored, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "tRNA_KOs/Output/Plots/nDEP_hists_per_anticodon_color_by_DNA_seq_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs_DNA, nrow=4, ncol=4), 
   width = 15, height = 9
)
output_file = paste(base_dir, "tRNA_KOs/Output/Plots/nDEP_hists_per_anticodon_color_by_mature_seq_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs_mature, nrow=4, ncol=4), 
   width = 15, height = 9
)
output_file = paste(base_dir, "tRNA_KOs/Output/Plots/nDEP_hists_per_anticodon_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs_not_colored, nrow=4, ncol=4), 
   width = 15, height = 9
)


# Save responsiveness dataframe for further use
fwrite(responsiveness, paste(base_dir, "tRNA_KOs/Data/produced_during_analysis/responsiveness_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep=""))
```

Repeat this but only for the strains with a single major tRNA gene, to have an image of the barplots only for those
```{r}
# Add columns with DNA and mature sequences to responsiveness dataframe
temp_resp <- responsiveness %>%
  filter(Major_count == 1)
  
## Create empty list of plots
plot_list <- list()

## Generate the plots and add them to the list
anticodons <- sort(unique(as.character(temp_resp$anticodon)))
for (i in 1:length(anticodons)) {
  my_anticodon <- anticodons[i]
  temp <- temp_resp %>%
    filter(anticodon == my_anticodon)
  
  # Get plots
  plot_list[[my_anticodon]] <- ggplot(data = temp, aes(x = nDEP)) +
    geom_histogram(bins = 100, stat = StatBin2) +
    theme_light() +
    xlab("nDEP") +
    ylab("Count") +
    labs(title = glue("{my_anticodon}")) + 
    theme(legend.position = "none")
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "tRNA_KOs/Output/Plots/nDEP_hists_per_anticodon_only_1_major_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)


# Save responsiveness dataframe for further use
fwrite(responsiveness, paste(base_dir, "tRNA_KOs/Data/produced_during_analysis/responsiveness_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep=""))
```

Repeat this but only for the strains with more than one single major tRNA gene
```{r}
# Add columns with DNA and mature sequences to responsiveness dataframe
temp_resp <- responsiveness %>%
  filter(Major_count > 1)
  
## Create empty list of plots
plot_list <- list()

## Generate the plots and add them to the list
anticodons <- sort(unique(as.character(temp_resp$anticodon)))
for (i in 1:length(anticodons)) {
  my_anticodon <- anticodons[i]
  temp <- temp_resp %>%
    filter(anticodon == my_anticodon)
  
  # Get plots
  plot_list[[my_anticodon]] <- ggplot(data = temp, aes(x = nDEP)) +
    geom_histogram(bins = 100, stat = StatBin2) +
    theme_light() +
    xlab("nDEP") +
    ylab("Count") +
    labs(title = glue("{my_anticodon}")) + 
    theme(legend.position = "none")
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "tRNA_KOs/Output/Plots/nDEP_hists_per_anticodon_more_than_1_major_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)


# Save responsiveness dataframe for further use
fwrite(responsiveness, paste(base_dir, "tRNA_KOs/Data/produced_during_analysis/responsiveness_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep=""))
```

Repeat this but only for the strains which have only KOs with less than 20 nDEP
```{r}
# Add columns with DNA and mature sequences to responsiveness dataframe
temp_resp <- responsiveness %>%
  filter(Major_count == 0)
  
## Create empty list of plots
plot_list <- list()

## Generate the plots and add them to the list
anticodons <- sort(unique(as.character(temp_resp$anticodon)))
for (i in 1:length(anticodons)) {
  my_anticodon <- anticodons[i]
  temp <- temp_resp %>%
    filter(anticodon == my_anticodon)
  
  # Get plots
  plot_list[[my_anticodon]] <- ggplot(data = temp, aes(x = nDEP)) +
    geom_histogram(bins = 100, stat = StatBin2) +
    theme_light() +
    xlab("nDEP") +
    ylab("Count") +
    labs(title = glue("{my_anticodon}")) + 
    theme(legend.position = "none")
}

## List of ggplot objects has to be turned to list of grobs for grid.arrange to work
my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file = paste(base_dir, "tRNA_KOs/Output/Plots/nDEP_hists_per_anticodon_nDEP_below_20_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=4, ncol=4), 
   width = 15, height = 9
)


# Save responsiveness dataframe for further use
fwrite(responsiveness, paste(base_dir, "tRNA_KOs/Data/produced_during_analysis/responsiveness_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep=""))


# Remove unnecessary variables
rm(amino_acids, master_by_amino_acid, master_by_anticodon, my_grobs_DNA, my_grobs_mature, plot_list_DNA_seq, plot_list_mature_seq, temp,
   anticodon, anticodons, i, my_anticodon, num_of_tRNA_versions_DNA, num_of_tRNA_versions_mature, output_file, temp_resp)
```


This used to be in section 2, but I think it's better here:

Sadly, I do need to create the corresponding resp_and_expression dataset before I can run the following chunk
```{r}
# tRNa expression data from Cozen et al., 2015 - keep only genomic rows
cozen <- read.xlsx(paste(base_dir, "tRNA_KOs/Data/tRNA_expression_comparative/cozen_et_al_2015.xlsx", sep=""), 1) %>%
  filter(read.mapping..genomic.sequence.or.mature.tRNA. == "genomic")

cozen_to_merge <- cozen %>%
  dplyr::filter(saccaromyces.genome.datasbase..sgd..tRNA.name != "NA" &
           mean.normalized.ReadCount..AlkB != "NA") %>%
  dplyr::select(name, tRNA.group, chromosome, chromosome.start, chromosome.end, chromosome.start,
         saccaromyces.genome.datasbase..sgd..tRNA.name, mean.normalized.ReadCount..AlkB, read.mapping..genomic.sequence.or.mature.tRNA.) %>%
  group_by(saccaromyces.genome.datasbase..sgd..tRNA.name) %>%
  mutate(mean_reads_per_tRNA = sum(as.numeric(mean.normalized.ReadCount..AlkB), na.rm = T)) %>%
  dplyr::rename(Strain.Name = saccaromyces.genome.datasbase..sgd..tRNA.name) %>%
  dplyr::select(Strain.Name, mean_reads_per_tRNA)

## Merge with resp
resp_and_expression <- left_join(responsiveness, cozen_to_merge, by = "Strain.Name")


# Remove unnecessary variables
rm(cozen, cozen_to_merge)



# Load data
chu_synths <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/Articles/chu_2011/S3.csv", sep=""))) %>%
  dplyr::select(-k_cat_ref)
chu_trnas <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/Articles/chu_2011/S2.csv", sep="")))
# The problem with these abundances for tRNAs is that they are for each family, not for each tRNA concretely, so I don't really know if they will be useful to me. I could collapse those from Cozen et al. by family and compare them to this to see if they point in the same direction, but might be a bit of a time waste

# Join the synthetase data to the resp_and_expression dataset
resp_and_expression <- left_join(resp_and_expression, chu_synths, by = "Amino_acid_3_letter")

# Add also the synthetase abundance we detect in our WTs
## Remove those synthetases we didn't detect in our data, as well as GRS2 (only active under stress)
synthetases <- fread(paste(base_dir, "tRNA_KOs/Data/basic/trna_synthetases.csv", sep=""))
temp <- synthetases %>%
  filter(Gene.symbol != "GRS2",
         !is.na(measured_proteomics_WT)) %>%
  dplyr::select(Amino_acid_1_letter, measured_proteomics_WT)
  

# For the rows for each amino acid, select the limiting one, the one we detect the least of (even though I don't even know if they join 1:1 to form the complex?)
synthetases_to_merge <- data.frame(matrix(ncol = ncol(synthetases), nrow = 0))
aas <- unique(synthetases$Amino_acid_1_letter)
for (i in 1:length(aas)) {
  aa <- aas[i]
  temp_2 <- temp %>%
    filter(Amino_acid_1_letter == aa)
  temp_2 <- temp_2[which.min(temp_2$measured_proteomics_WT),]
  synthetases_to_merge <- rbind(synthetases_to_merge, temp_2)
}

resp_and_expression <- left_join(resp_and_expression, synthetases_to_merge, by = "Amino_acid_1_letter")


# Remove unnecessary variables
rm(chu_synths, chu_trnas, synthetases, temp, temp_2, synthetases_to_merge, aa, aas, i)




# Get anticodon from codon and rename columns
anticodon_freq <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/Articles/chu_2011/S1.csv", sep="")))
anticodon_freq$anticodon <- lapply(anticodon_freq[,colnames(anticodon_freq) == "Codon"], codon_to_anticodon)
anticodon_freq$anticodon <- as.character(anticodon_freq$anticodon)
anticodon_freq$anticodon <- as.factor(anticodon_freq$anticodon)
anticodon_freq <- anticodon_freq %>%
  dplyr::rename(codon_frequency_chu_2011 = Frequency)

# Merge to resp_and_expression
resp_and_expression <- left_join(resp_and_expression, anticodon_freq, by = "anticodon")


# Save the dataset
fwrite(resp_and_expression, paste(base_dir, "tRNA_KOs/Data/produced_during_analysis/resp_and_expression_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep=""))
```


```{r}
# Family_count vs. major_count, as in 1.11., but color by amino acid carried - TODO
temp <- resp_and_expression %>%
  dplyr::select(anticodon, Amino_acid_1_letter)
temp_2 <- left_join(family_sizes, temp, by = "anticodon") %>%
  distinct(anticodon, .keep_all = T)

ggplot(data = temp_2, aes(x = Family_count, y = Major_count, col = Amino_acid_1_letter)) +
  geom_point() +
  geom_abline() +
  theme_light() +
  xlab("Genes in this family in the experiment") +
  ylab("Major genes detected in the family") +
  geom_text_repel(data = subset(temp_2, Major_count/Family_count == 1 | Major_count/Family_count < 0.3),
                  aes(x = Family_count, y = Major_count, label = anticodon),
                  size = 4, 
                  max.overlaps = 100)

# Same, but use in the y axis the % of major tRNAs instead of the count
ggplot(data = temp_2, aes(x = Family_count, y = Major_count/Family_count)) +
  geom_point() +
  geom_smooth(method='lm') +
  theme_light() +
  xlab("Genes in this family in the study") +
  ylab("% of major genes detected in the family") +
  geom_text_repel(data = subset(temp_2, Major_count/Family_count >= 1 | Major_count/Family_count < 0.3| anticodon == "CAA"),
                  aes(x = Family_count, y = Major_count/Family_count, label = anticodon, col = Amino_acid_1_letter),
                  size = 4)

# Same, but use in the y axis the % of major tRNAs instead of the count, and color by aa
ggplot(data = temp_2, aes(x = Family_size, y = Major_count/Family_count)) +
  geom_point() +
  geom_smooth(method='lm') +
  theme_light() +
  xlab("Genes in this family in total") +
  ylab("% of major genes detected in the family") +
  geom_text_repel(data = subset(temp_2, Major_count/Family_count >= 1 | Major_count/Family_count < 0.3 | anticodon == "CAA"),
                  aes(x = Family_size, y = Major_count/Family_count, label = anticodon, col = Amino_acid_1_letter),
                  size = 4)


# Remove unnecessary variables
rm(family_sizes, resp_and_expression)
```



## 1.8. Number of DE proteins per family, coloring by number of tRNAs in the family
```{r}
ggplot(data = responsiveness, aes(x = anticodon, y = nDEP, fill = Family_count)) +
  geom_boxplot() +
  theme_light() +
  xlab("Anticodon") +
  labs(fill = "Genes in\nfamily",
       title = "Number of DE proteins per family",
       subtitle = "Colored by number of tRNA genes in the family") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

ggplot(data = responsiveness, aes(x = anticodon, y = nDEP, fill = Family_count)) +
  geom_boxplot() +
  theme_light() +
  xlab("Anticodon") +
  labs(fill = "Genes in\nfamily",
       title = "Number of DE proteins per family",
       subtitle = "Colored by number of tRNA genes in the family - nDEP < 150") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  coord_cartesian(ylim = c(0, 150))


# Correlation between nDEP and tRNA family size
resp_summarized_by_family <- aggregate(responsiveness$nDEP, list(responsiveness$anticodon), mean)
colnames(resp_summarized_by_family) <- c("anticodon", "nDEP")
resp_summarized_by_family <- merge(resp_summarized_by_family, responsiveness[, c("anticodon", "Family_count")], by = "anticodon", all.x = T)
resp_summarized_by_family <- resp_summarized_by_family %>%
  distinct(anticodon, .keep_all = T)
cor(resp_summarized_by_family$nDEP, resp_summarized_by_family$Family_count)


# Remove unnecessary variables
rm(resp_summarized_by_family)
```
--> The boxplot is not particularly illustrative, but the correlation is pretty meaningful I think? Looks like larger families show, on average over all tRNAs in them, less DE proteins, which makes sense with their hypothesis I think? If there are a couple major tRNA genes per family, larger families are going to have a lot of minor ones, while small families will be mostly major ones. Here I am also assuming that there are only a couple major copies per family, which I don't think they said at any point? But I guess makes sense with this. 

More plots to look into this:
```{r}
# nDEP vs. family size
ggplot(data = responsiveness, aes(x = as.factor(Family_size), y = nDEP)) +
  geom_boxplot() +
  theme_light() +
  xlab("Family size") +
  ylab("nDEP") +
  labs(title = "nDEPs based on the number of tRNA genes in each family")

ggplot(data = responsiveness, aes(x = as.factor(Family_size), y = nDEP)) +
  geom_boxplot() +
  theme_light() +
  xlab("Family size") +
  ylab("nDEP") +
  coord_cartesian(ylim = c(0, 150)) +
  labs(title = "nDEPs based on the number of tRNA genes in each family",
       subtitle = "Truncated at nDEP < 150")

ggplot(data = responsiveness, aes(x = as.factor(Family_size), y = nDEP, fill = perc_family)) +
  geom_boxplot() +
  theme_light() +
  xlab("Family size") +
  ylab("nDEP") +
  coord_cartesian(ylim = c(0, 150)) +
  labs(title = "nDEPs based on the number of tRNA genes in each family",
       subtitle = "Truncated at nDEP < 150",
       fill = "% of genes in family\nincluded in experiment")


# nDEP vs. family count - tbh I don't think these ones are relevant at all?
ggplot(data = responsiveness, aes(x = as.factor(Family_count), y = nDEP)) +
  geom_boxplot() +
  theme_light() +
  xlab("Family count") +
  ylab("nDEP") +
  labs(title = "nDEPs vs. number of tRNA genes per family that were included in the study")

ggplot(data = responsiveness, aes(x = as.factor(Family_count), y = nDEP)) +
  geom_boxplot() +
  theme_light() +
  xlab("Family count") +
  ylab("nDEP") +
  coord_cartesian(ylim = c(0, 150)) +
  labs(title = "nDEPs vs. number of tRNA genes per family that were included in the study",
       subtitle = "Truncated at nDEP < 150")
```



## 1.9. Do all tRNAs with the same anticodon have exactly the same sequence throughout their whole structure?
No, they do not! Look further into this elsewhere
```{r}
num_of_tRNA_versions_DNA <- c()
num_of_tRNA_versions_mature <- c()
anticodons <- unique(master_dataset$Anticodon)
for (i in 1:length(anticodons)) {
  anticodon <- anticodons[i]
  temp <- master_dataset %>%
    filter(Anticodon == anticodon)
  num_of_tRNA_versions_DNA <- c(num_of_tRNA_versions_DNA, length(unique(temp$DNA_sequence)))
  num_of_tRNA_versions_mature <- c(num_of_tRNA_versions_mature, length(unique(temp$mature_sequence)))
}

temp <- data.frame(anticodons, num_of_tRNA_versions_DNA, num_of_tRNA_versions_mature)


# Remove unnecessary variables
rm(temp, anticodon, anticodons, i, num_of_tRNA_versions_DNA, num_of_tRNA_versions_mature)
```



## 1.10. Explore correlation between the number of tRNA genes for a certain amino acid (or anticodon) that couldn't be KOd, and the number of genes with that amino acid/anticodon - THIS WAS IN A DIFFERENT FILE, IN THE TSSC CODE! NOT SURE IF IT WILL RUN HERE BUT I THINK IT SHOULD
```{r}
# Plots by anticodon
master_by_anticodon <- master_dataset %>%
  distinct(Anticodon, .keep_all = T)

## Just the percentage of KOd genes per anticodon
ggplot(data = master_by_anticodon, aes(x = Anticodon, y = Perc_KOd_genes_per_anticodon)) +
  geom_point() +
  theme_light() +
  geom_text_repel(data = subset(master_by_anticodon, Perc_KOd_genes_per_anticodon < 0.7), aes(x = Anticodon, y = Perc_KOd_genes_per_anticodon, label = Anticodon)) +
  theme(axis.text.x = element_blank()) +
  labs(title = "% of tRNA-genes with each anticodon that were KOd") +
  ylab("% of genes KOd")



# Plots by amino acid - for some reason distinct() is not working???
master_by_amino_acid <- master_dataset[!duplicated(master_dataset$Amino_acid_1_letter),]

## Just the percentage of KOd genes per amino acid
ggplot(data = master_by_amino_acid, aes(x = Amino_acid_1_letter, y = Perc_KOd_genes_per_amino_acid, col = Number_of_tRNAs_loading_this_aa)) +
  geom_point() +
  theme_light() +
  geom_text_repel(data = subset(master_by_amino_acid, Perc_KOd_genes_per_amino_acid < 0.8), aes(x = Amino_acid_1_letter, y = Perc_KOd_genes_per_amino_acid, label = Amino_acid_1_letter)) +
  theme(axis.text.x = element_blank()) +
  xlab("Amino acid") +
  ylab("% of genes KOd") +
  labs(title = "% of tRNA-genes carrying each amino acid that were KOd",
       col = "Number of tRNAs\nloading this aa")

# How many tRNA genes are there for each amino acid?
ggplot(data = master_by_amino_acid, aes(x = Amino_acid_1_letter, y = Number_of_tRNAs_loading_this_aa)) +
  geom_point() +
  theme_light() +
  theme(axis.text.x = element_blank()) +
  labs(title = "Number of tRNA genes carrying each amino acid") +
  xlab("Amino acid") +
  ylab("Number of genes") +
  geom_text_repel(data = subset(master_by_amino_acid, Number_of_tRNAs_loading_this_aa < 6 | Number_of_tRNAs_loading_this_aa > 20), aes(x = Amino_acid_1_letter, y = Number_of_tRNAs_loading_this_aa, label = Amino_acid_1_letter))

# Family sizes of the genes that couldn't be KOd
not_included_genes <- master_dataset %>%
  filter(KOd == "No")

# Barplot for family sizes
ggplot(data = not_included_genes, aes(x = Family_size)) +
  geom_bar() +
  theme_light() +
  xlab("Family size") +
  ylab("Count") +
  labs(title = "Distribution of family sizes across genes that couldn't be KOd")

# Barplots for number of tRNA genes carrying that amino acid
ggplot(data = not_included_genes, aes(x = Number_of_tRNAs_loading_this_aa)) +
  geom_bar() +
  theme_light() +
  xlab("Number of genes for tRNAs carrying the same amino acid") +
  ylab("Count") +
  labs(title = "Distribution of the number of genes for tRNAs carrying the same amino acid",
       subtitle = "Across genes that couldn't be KOd")

# Remove unnecessary variables
rm(master_by_amino_acid, master_by_anticodon)
```



## 1.11. Replicate Alexis' original plots - kind of my own version
```{r}
ggplot(data = responsiveness, aes(x = Strain.Name, y = nDEP, fill = Amino_acid_1_letter)) +
  geom_col() +
  theme_light() +
  theme(axis.text.x = element_blank(), 
        axis.ticks.x = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.title = element_text(size=9),
        legend.key.size = unit(0.5, 'cm')) +
  xlab("KO strain") +
  labs(fill = "Amino acid")

ggplot(data = responsiveness, aes(x = nDEP)) +
  geom_density(fill="#77bd89",
               color="#1f6e34",
               alpha=0.8,
               linewidth = 1) +
  theme_light()

ggplot(data = responsiveness, aes(x = Amino_acid_1_letter, y = nDEP, fill = Amino_acid_1_letter)) +
  geom_boxplot() +
  theme_light() +
  labs(fill = "Amino acid",
       title = 'tRNA KOs Responsiveness per AA', 
       subtitle = 'Number of Differentially Expressed Proteins (DEPs)') +
  xlab("Amino acid") +
  theme(legend.title = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'))

ggplot(data = responsiveness, aes(x = Amino_acid_1_letter, y = nDEP, fill = Amino_acid_1_letter)) +
  geom_boxplot(outliers = F) +
  geom_jitter() +
  theme_light() +
  labs(fill = "Amino acid",
       title = 'tRNA KOs Responsiveness per AA', 
       subtitle = 'Number of Differentially Expressed Proteins (DEPs) - truncated < 100 nDEP') +
  xlab("Amino acid") +
  theme(legend.title = element_text(size=9),
        legend.key.size = unit(0.5, 'cm')) +
  coord_cartesian(ylim = c(0, 100))

ggplot(data = responsiveness, aes(x = chromosome_letter, y = nDEP, fill = chromosome_letter)) +
  geom_boxplot() +
  theme_light() +
  labs(fill = "Chromosome",
       title = 'tRNA KOs Responsiveness per Chromosome', 
       subtitle = 'Number of Differentially Expressed Proteins (DEPs)') +
  xlab("Chromosome") +
  theme(legend.title = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'))

ggplot(data = responsiveness, aes(x = chromosome_letter, y = nDEP, fill = chromosome_letter)) +
  geom_boxplot(outliers = F) +
  geom_jitter() +
  theme_light() +
  labs(fill = "Chromosome",
       title = 'tRNA KOs Responsiveness per Chromosome', 
       subtitle = 'Number of Differentially Expressed Proteins (DEPs) - truncated < 100 nDEP') +
  xlab("Chromosome") +
  theme(legend.title = element_text(size=9),
        legend.key.size = unit(0.5, 'cm')) +
  coord_cartesian(ylim = c(0, 100))


myLetters <- letters[1:26]              # Need this to be able to re-order anticodons by amino acid
ggplot(responsiveness, aes(x = fct_reorder(anticodon, match(tolower(Amino_acid_1_letter), myLetters)), y = nDEP, groupping = Amino_acid_1_letter, fill = Amino_acid_1_letter)) +
  geom_boxplot() +
  theme_light() +
  xlab("Anticodon") +
  labs(fill = "Amino acid") +
  labs(title = 'tRNA KOs Responsiveness per Anticodon', 
       subtitle = 'Number of Differentially Expressed Proteins (DEPs)') +
  theme(legend.title = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

ggplot(responsiveness, aes(x = fct_reorder(anticodon, match(tolower(Amino_acid_1_letter), myLetters)), y = nDEP, groupping = Amino_acid_1_letter, fill = Amino_acid_1_letter)) +
  geom_boxplot(outliers = F) +
  geom_jitter() +
  theme_light() +
  xlab("Anticodon") +
  labs(fill = "Amino acid") +
  coord_cartesian(ylim = c(0, 150)) +
  labs(title = 'tRNA KOs Responsiveness per Anticodon', 
       subtitle = 'Number of Differentially Expressed Proteins (DEPs) - truncated < 150 nDEP') +
  theme(legend.title = element_text(size=9),
        legend.key.size = unit(0.5, 'cm'),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```



## 1.12. Quick look at the OD
Join OD and responsiveness dataframes
```{r}
resp_temp <- responsiveness %>%
  dplyr::select(Strain.Name, nDEP, up_down_regulated_ratio_adjusted, up_down_regulated_ratio_non_adjusted)
od_and_nDEP <- left_join(od, resp_temp, by = "Strain.Name")
```


Plot just OD histograms
```{r}
ggplot(data = od, aes(x = OD_processed)) +
  geom_histogram(binwidth = 0.1, fill = "grey", col = "black") +
  theme_light() +
  labs(title = "Processed ODs for tRNA KO strains",
       subtitle = "For the following 96-well plates: 2.1., 2.2., 2.3.") +
  ylab("Frequency") +
  xlab("OD")

# Color by empty wells
ggplot(data = od, aes(x = OD_processed, fill = Empty_well)) +
  geom_histogram(binwidth = 0.03, col = "black") +
  theme_light() +
  labs(title = "Processed ODs for tRNA KO strains",
       subtitle = "For the following 96-well plates: 2.1., 2.2., 2.3.",
       fill = "Empty well?") +
  ylab("Frequency") +
  xlab("OD")
```

OD boxplots per anticodon and amino acid
```{r}
# Boxplot by anticodon, color by amino acid
temp_plot <- od %>%
  filter(Anticodon != "")
myLetters <- letters[1:26]              # Need this to be able to re-order anticodons by amino acid
ggplot(data = temp_plot, aes(x = fct_reorder(Anticodon, match(tolower(Amino_acid_1_letter), myLetters)), y = OD_processed, fill = Amino_acid_1_letter)) +
  geom_boxplot() +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 8)) +
  xlab("Anticodon") +
  ylab("OD") +
  labs(title = "OD boxplots per anticodon",
       subtitle = "Ordered and colored by amino acid carried", 
       fill = "Amino acid") +
  guides(fill=guide_legend(ncol=2))

# Boxplot by amino acid
ggplot(data = temp_plot, aes(x = Amino_acid_1_letter, y = OD_processed)) +
  geom_boxplot(fill = "grey") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 8)) +
  xlab("Anticodon") +
  ylab("OD") +
  labs(title = "OD boxplots per amino acid")

# Boxplot by whether a strain is WT, KO, or empty well - was going to do it for every single Strain.Name, but you cannot really see anything
# I could still do that and just divide it across a few plots, but I can also just compare the WTs here to the plots above
od <- od %>%
  mutate(Strain.Type = case_when(Strain.Name == "WT" ~ "WT",
                                 Strain.Name == "" ~ "Empty",
                                 TRUE ~ "KO"))
ggplot(data = od, aes(x = Strain.Type, y = OD_processed)) +
  geom_boxplot() +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 8)) +
  xlab("Strain type") +
  ylab("OD") +
  labs(title = "OD boxplots per strain type")
```

OD vs. nDEP
```{r}
# OD vs. nDEP
ggplot(data = od_and_nDEP, aes(x = OD_processed, y = nDEP)) +
  geom_point() +
  theme_light()

# OD vs. nDEP - y axis cut off at 200 nDEP
ggplot(data = od_and_nDEP, aes(x = OD_processed, y = nDEP)) +
  geom_point() +
  theme_light() +
  coord_cartesian(ylim = c(0, 200))
```

Up_regulated/Down_regulated proteins per strain vs. OD
```{r}
ggplot(data = od_and_nDEP, aes(x = OD_processed, y = up_down_regulated_ratio_non_adjusted)) +
  geom_point() +
  theme_light() + 
  labs(title = "Up-regulated protein count/down-regulated protein count vs. OD",
       subtitle = "Un-adjusted p-values") +
  xlab("OD") +
  ylab("Up-regulated proteins/Down-regulated proteins")

ggplot(data = od_and_nDEP, aes(x = OD_processed, y = up_down_regulated_ratio_adjusted)) +
  geom_point() +
  theme_light() + 
  labs(title = "Up-regulated protein count/down-regulated protein count vs. OD",
       subtitle = "Adjusted p-values") +
  xlab("OD") +
  ylab("Up-regulated proteins/Down-regulated proteins")
```



## 1.13. Explore phenotypic results (GR and GY)
Compare the phenotypic results from 2014 and 2020
```{r}
ggplot(data = phenotypic_data, aes(x = GR_YPD_2014, y = GR_YPD_2020)) +
  geom_point() +
  theme_light() +
  labs(title = "Growth rates in YPD")

ggplot(data = phenotypic_data, aes(x = GR_SDC_2014, y = GR_SDC_2020)) +
  geom_point() +
  theme_light() +
  labs(title = "Growth rates in SDC")

ggplot(data = phenotypic_data, aes(x = GY_YPD_2014, y = GY_YPD_2020)) +
  geom_point() +
  theme_light() +
  labs(title = "Growth yields in YPD")

ggplot(data = phenotypic_data, aes(x = GY_SDC_2014, y = GY_SDC_2020)) +
  geom_point() +
  theme_light() +
  labs(title = "Growth yields in SDC")
```

Compare phenotypic results to OD
```{r}
# Join the 2 datasets
temp_od <- od %>%
  dplyr::select(OD_processed, Strain.Name)
temp_phenotypic <- phenotypic_data %>%
  dplyr::select(Strain.Name, starts_with("GR"), starts_with("GY"))

od_and_phenotypic_data <- left_join(temp_phenotypic, temp_od, by = "Strain.Name")

# Plot
ggplot(data = od_and_phenotypic_data, aes(x = OD_processed, y = GR_low_glucose_2014)) +
  geom_point() +
  theme_light()

# After talking to Julia I decided to get rid of the 2020 values, since they strongly correlate with the 2014 ones and they don't provide any new insight, seemingly it's always better to use published data
od_and_phenotypic_data <- od_and_phenotypic_data %>%
  dplyr::select(!contains("2020"))

# Get correlations - actually let me add nDEP here and get a more complete view
temp_resp <- responsiveness %>%
  dplyr::select(Strain.Name, nDEP)
od_and_phenotypic_data_for_corr <- od_and_phenotypic_data %>%
  left_join(temp_resp, by = "Strain.Name") %>%
  dplyr::select(-Strain.Name) %>%
  na.omit()
cor_mat <- round(cor(od_and_phenotypic_data_for_corr), 2)
melted_cormat <- melt(cor_mat)
ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  geom_text(aes(Var2, Var1, label = value), size = 3) +
  scale_fill_gradient2(low = "blue", high = "red",
                       limit = c(-1,1), name="Correlation") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```



## 1.14. Up-regulated and down-regulated proteins exploration
```{r}
resp_only_no_up_regulated_strains <- responsiveness %>%
  filter(up_down_regulated_ratio_adjusted == 0)

print("Strain.Name")
length(unique(responsiveness$Strain.Name))
length(unique(resp_only_no_up_regulated_strains$Strain.Name))

print("Anticodon")
length(unique(responsiveness$anticodon))
length(unique(resp_only_no_up_regulated_strains$anticodon))

print("Amino acid")
length(unique(responsiveness$Amino_acid_1_letter))
length(unique(resp_only_no_up_regulated_strains$Amino_acid_1_letter))

print("Mean major count")
mean(responsiveness$Major_count)
mean(resp_only_no_up_regulated_strains$Major_count)
```



## 1.15. Clean up environment
Next section loads all the data it needs, so I can delete everything except the system/set up parameters
```{r}
rm(da, master_dataset, responsiveness, sample_layout)
```









########################################################################################
# 2. Compare to data from the literature that might explain the nDEP for each KO strain:
########################################################################################
  - tRNA expression data from Cozen et al., 2015
  - tRNA synthetase abundance data from Chu et al., 2011
  - anticodon frequency in the genome from van der Haar, 2008


## 2.1. tRNA expression data from Cozen et al., 2015
The main issue with this dataset (apart from the fact that they are read counts) is that in many rows, the counts are not assigned to a single tRNA gene, but they can come from any tRNA gene with a certain anticodon. Actually, these are the reads that come from sequencing the actual, mature tRNAs, seemingly these are very hard to differentiate. Also, there are extremely high counts for these ones, so they are pretty uninformative and make it complicated to interpret when summing them up with the read counts that are for each tRNA gene specifically (because it seems like all those that are counted together as the mature tRNA have basically the same level of expression). Hence, I decided to only use the rows which have one single tRNA identified per row, this is, the genomic rows: these are the ones where the information comes from sequencing the tRNA just after it has been transcribed, before maturation or anything, which allows to identify exactly which gene they are coming from (all of this is kind of my interpretation, not 100% sure of it, but I think this is it). 

Load data
```{r}
# tRNa expression data from Cozen et al., 2015 - keep only genomic rows
cozen <- read.xlsx(paste(base_dir, "tRNA_KOs/Data/tRNA_expression_comparative/cozen_et_al_2015.xlsx", sep=""), 1) %>%
  filter(read.mapping..genomic.sequence.or.mature.tRNA. == "genomic")

# Load responsiveness dataset
responsiveness <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/produced_during_analysis/responsiveness_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep="")))
```

Remove rows with NAs in relevant columns, select columns of interest, get the sum of reads per tRNA (since there are several rows for the same tRNA), and rename to merge with responsiveness dataframe
```{r}
cozen_to_merge <- cozen %>%
  dplyr::filter(saccaromyces.genome.datasbase..sgd..tRNA.name != "NA" &
           mean.normalized.ReadCount..AlkB != "NA") %>%
  dplyr::select(name, tRNA.group, chromosome, chromosome.start, chromosome.end, chromosome.start,
         saccaromyces.genome.datasbase..sgd..tRNA.name, mean.normalized.ReadCount..AlkB, read.mapping..genomic.sequence.or.mature.tRNA.) %>%
  group_by(saccaromyces.genome.datasbase..sgd..tRNA.name) %>%
  mutate(mean_reads_per_tRNA = sum(as.numeric(mean.normalized.ReadCount..AlkB), na.rm = T)) %>%
  dplyr::rename(Strain.Name = saccaromyces.genome.datasbase..sgd..tRNA.name) %>%
  dplyr::select(Strain.Name, mean_reads_per_tRNA)

## Merge with resp
resp_and_expression <- left_join(responsiveness, cozen_to_merge, by = "Strain.Name")


# Remove unnecessary variables
rm(cozen, cozen_to_merge)
```

Plots - nDEP vs. tRNA expression from Cozen et al., 2015
```{r}
# Plot average nDEP vs. avg expression - genomic tRNA sequences
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP)) +
  geom_point() +
  theme_light() + 
  labs(title = "nDEP vs. tRNA expression") +
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")

# Same, but color by number of tRNA genes in family
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = Family_count)) +
  geom_point() +
  theme_light() + 
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")
```


## 2.2. Integrate data from tRNA synthetase abundance and tRNA abundance (van der Haar et al., 2008) 
Load and prepare data
```{r}
# Load data
chu_synths <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/Articles/chu_2011/S3.csv", sep=""))) %>%
  dplyr::select(-k_cat_ref)
chu_trnas <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/Articles/chu_2011/S2.csv", sep="")))
# The problem with these abundances for tRNAs is that they are for each family, not for each tRNA concretely, so I don't really know if they will be useful to me. I could collapse those from Cozen et al. by family and compare them to this to see if they point in the same direction, but might be a bit of a time waste

# Join the synthetase data to the resp_and_expression dataset
resp_and_expression <- left_join(resp_and_expression, chu_synths, by = "Amino_acid_3_letter")

# Add also the synthetase abundance we detect in our WTs
## Remove those synthetases we didn't detect in our data, as well as GRS2 (only active under stress)
synthetases <- fread(paste(base_dir, "tRNA_KOs/Data/basic/trna_synthetases.csv", sep=""))
temp <- synthetases %>%
  filter(Gene.symbol != "GRS2",
         !is.na(measured_proteomics_WT)) %>%
  dplyr::select(Amino_acid_1_letter, measured_proteomics_WT)
  

# For the rows for each amino acid, select the limiting one, the one we detect the least of (even though I don't even know if they join 1:1 to form the complex?)
synthetases_to_merge <- data.frame(matrix(ncol = ncol(synthetases), nrow = 0))
aas <- unique(synthetases$Amino_acid_1_letter)
for (i in 1:length(aas)) {
  aa <- aas[i]
  temp_2 <- temp %>%
    filter(Amino_acid_1_letter == aa)
  temp_2 <- temp_2[which.min(temp_2$measured_proteomics_WT),]
  synthetases_to_merge <- rbind(synthetases_to_merge, temp_2)
}

resp_and_expression <- left_join(resp_and_expression, synthetases_to_merge, by = "Amino_acid_1_letter")


# Remove unnecessary variables
rm(chu_synths, chu_trnas, synthetases, temp, temp_2, synthetases_to_merge, aa, aas, i)
```

Plots - nDEP vs. tRNA expression from Cozen et al., 2015 (coloring by amino acid characteristics)
```{r}
# Plot average nDEP vs. avg expression - color by amino acid type
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = amino_acid_type)) +
  geom_point() +
  theme_light() + 
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")

# Plot average nDEP vs. avg expression - color by amino acid charge
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = amino_acid_charge)) +
  geom_point() +
  theme_light() + 
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")

# Plot average nDEP vs. avg expression - color by amino acid weight
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = molecular_weight_Da)) +
  geom_point() +
  theme_light() + 
  xlab("Sequencing reads per tRNA (from Cozen et al., 2015)") +
  ylab("nDEP per tRNA KO")
```

Plots - tRNA expression from Cozen et al., 2015 vs. tRNA synthetase abundance from van der Haar, 2008
```{r}
# tRNA abundance from Cozen et al., vs. log2 tRNA synthetase abundance from Chu et al.
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA)) +
  geom_point() +
  theme_light()

# Same, but color by major and minor based on our proteomics
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA, col = Gene_type)) +
  geom_point() +
  theme_light()

# Plot average nDEP vs. avg expression, but color by tRNA synthetase abundance from van der Haar, 2008
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = synthetase_abundance)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid type
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA, col = amino_acid_type)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid charge
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA, col = amino_acid_charge)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid weight
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = mean_reads_per_tRNA, col = molecular_weight_Da)) +
  geom_point() +
  theme_light()
```

Plots - tRNA expression from Cozen et al., 2015 vs. tRNA synthetase abundance from our WTs
```{r}
# tRNA abundance from Cozen et al., vs. log2 tRNA synthetase abundance from Chu et al.
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WTs_WT), y = mean_reads_per_tRNA)) +
  geom_point() +
  theme_light()

# Same, but color by major and minor based on our proteomics
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WTs_WT), y = mean_reads_per_tRNA, col = Gene_type)) +
  geom_point() +
  theme_light()

# Plot average nDEP vs. avg expression, but color by tRNA synthetase abundance from our WT samples
ggplot(data = resp_and_expression, aes(x = mean_reads_per_tRNA, y = nDEP, col = measured_proteomics_WTs_WT)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid type
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WTs_WT), y = mean_reads_per_tRNA, col = amino_acid_type)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid charge
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WTs_WT), y = mean_reads_per_tRNA, col = amino_acid_charge)) +
  geom_point() +
  theme_light()

# Same, but color by amino acid weight
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WTs_WT), y = mean_reads_per_tRNA, col = molecular_weight_Da)) +
  geom_point() +
  theme_light()
```

Plots - nDEP vs. synthetase abundance - from van der Haar, 2008
```{r}
# nDEP vs. synthetase abundance
ggplot(data = resp_and_expression, aes(x = synthetase_abundance, y = nDEP)) +
  geom_point()

# nDEP vs. log2-synthetase abundance
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (from von der Haar, 2008)") +
  xlab("log2-tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO")

ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (from von der Haar, 2008)",
       subtitle = "Truncated nDEP < 150") +
  xlab("log2-tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO") +
  coord_cartesian(ylim = c(0, 150))

# nDEP vs. log2-synthetase abundance - color by family size
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = Family_count)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by chromosome
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = chromosome_letter)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid type
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = amino_acid_type)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid charge
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = amino_acid_charge)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid weight
ggplot(data = resp_and_expression, aes(x = log2(synthetase_abundance), y = nDEP, col = molecular_weight_Da)) +
  geom_point() +
  theme_light() +
  xlab("log2-tRNA synthetase abundance (from Chu et al., 2011)") +
  ylab("nDEP per tRNA KO")
```

Plots - nDEP vs. synthetase abundance - from our WTs
```{r}
# nDEP vs. synthetase abundance
ggplot(data = resp_and_expression, aes(x = measured_proteomics_WTs_WT, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (measured in WTs)") +
  xlab("tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO")

ggplot(data = resp_and_expression, aes(x = measured_proteomics_WTs_WT, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (measured in WTs)",
       subtitle = "Truncated nDEP < 150") +
  xlab("tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO") +
  coord_cartesian(ylim = c(0, 150))
  

# nDEP vs. log2-synthetase abundance
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WTs_WT), y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (measured in WTs)") +
  xlab("log2-tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by family size
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WTs_WT), y = nDEP, col = Family_count)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (measured in WTs)") +
  xlab("log2-tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by chromosome
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WTs_WT), y = nDEP, col = chromosome_letter)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (measured in WTs)") +
  xlab("log2-tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid type
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WTs_WT), y = nDEP, col = amino_acid_type)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (measured in WTs)") +
  xlab("log2-tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid charge
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WTs_WT), y = nDEP, col = amino_acid_charge)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (measured in WTs)") +
  xlab("log2-tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO")

# nDEP vs. log2-synthetase abundance - color by amino acid weight
ggplot(data = resp_and_expression, aes(x = log2(measured_proteomics_WTs_WT), y = nDEP, col = molecular_weight_Da)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. tRNA-synthetase abundance (measured in WTs)") +
  xlab("log2-tRNA synthetase abundance") +
  ylab("nDEP per tRNA KO")
```

Plots - nDEP vs. synthetase k_cat - from van der Haar, 2008
```{r}
# nDEP vs. log2-synthetase k_cat
ggplot(data = resp_and_expression, aes(x = log2(k_cat_value), y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. log2(synthetase catalytic constant) - from van der Haar, 2008") +
  xlab(bquote(log2-k["cat"]))

# The synthetases for W seem to have a k_cat more than 10x those of other amino acids, so I am going to get rid of that one then repeat the plot
ggplot(data = resp_and_expression, aes(x = k_cat_value, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. synthetase catalytic constant - from van der Haar, 2008")

ggplot(data = resp_and_expression, aes(x = k_cat_value, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. synthetase catalytic constant - from van der Haar, 2008",
       subtitle = "Truncated at catalytic constant < 150") +
  coord_cartesian(xlim = c(0, 150))

ggplot(data = resp_and_expression, aes(x = k_cat_value, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. synthetase catalytic constant - from van der Haar, 2008",
       subtitle = "Truncated at catalytic constant < 40") +
  coord_cartesian(xlim = c(0, 40))

# Not really a pattern I think, let's try synthetase abundance*k_cat
ggplot(data = resp_and_expression, aes(x = k_cat_value*synthetase_abundance, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. synthetase catalytic constant * synthetase abundance - from van der Haar, 2008") +
  coord_cartesian(xlim = c(0, 500000))
```



## 2.3. Add information about codon frequency as well
Load and prepare data
```{r}
# Get anticodon from codon and rename columns
anticodon_freq <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/Articles/chu_2011/S1.csv", sep="")))
anticodon_freq$anticodon <- lapply(anticodon_freq[,colnames(anticodon_freq) == "Codon"], codon_to_anticodon)
anticodon_freq$anticodon <- as.character(anticodon_freq$anticodon)
anticodon_freq$anticodon <- as.factor(anticodon_freq$anticodon)
anticodon_freq <- anticodon_freq %>%
  dplyr::rename(codon_frequency_chu_2011 = Frequency)

# Merge to resp_and_expression
resp_and_expression <- left_join(resp_and_expression, anticodon_freq, by = "anticodon")
```

Plots - nDEP vs. codon frequency (from van der Haar, 2008)
```{r}
# Codon frequency vs. nDEP
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency (from van der Haar, 2008)") +
  xlab("Codon frequency") +
  ylab("nDEP per tRNA KO")

ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency (from van der Haar, 2008)",
       subtitle = "Truncated nDEP < 150") +
  xlab("Codon frequency") +
  ylab("nDEP per tRNA KO") +
  coord_cartesian(ylim = c(0, 150))

# Codon frequency vs. nDEP - color by tRNA abundance from Cozen et al.
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = mean_reads_per_tRNA)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency (from van der Haar, 2008)") +
  xlab("Codon frequency") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by log2 tRNA synthetase abundance from Chu et al.
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = log2(synthetase_abundance))) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency (from van der Haar, 2008)") +
  xlab("Codon frequency") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by family size
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = Family_count)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency (from van der Haar, 2008)") +
  xlab("Codon frequency") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by amino acid type
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = amino_acid_type)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency (from van der Haar, 2008)") +
  xlab("Codon frequency") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by amino acid charge
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = amino_acid_charge)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency (from van der Haar, 2008)") +
  xlab("Codon frequency") +
  ylab("nDEP per tRNA KO")

# Codon frequency vs. nDEP - color by amino acid weight
ggplot(data = resp_and_expression, aes(x = codon_frequency_chu_2011, y = nDEP, col = molecular_weight_Da)) +
  geom_point() +
  theme_light() +
  labs(title = "nDEP vs. codon frequency (from van der Haar, 2008)") +
  xlab("Codon frequency") +
  ylab("nDEP per tRNA KO")
```


## 2.4. Save the resp_and_expression dataset as it is at this point, and clean up the environment
```{r}
fwrite(resp_and_expression, paste(base_dir, "tRNA_KOs/Data/produced_during_analysis/resp_and_expression_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep=""))
rm(anticodon_freq, resp_and_expression, responsiveness)
```




################################################################################
# 3. Modelling
################################################################################
## 3.0. Load data - so I don't have to run everything above
```{r}
resp_and_expression <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/produced_during_analysis/resp_and_expression_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep="")))

# Create a new version of the dataset with prettier names for the columns so the model summary is more readable
resp_and_expression_modelling <- resp_and_expression %>%
  dplyr::rename(catalytic_constant = k_cat_value,
                codon_frequency = codon_frequency_chu_2011,
                tRNA_expression = mean_reads_per_tRNA,
                synthetase_abundance_literature = synthetase_abundance,
                synthetase_abundance_our_WTs = measured_proteomics_WT)

# Add info on U_34, A_34 from master_dataset
master_dataset <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/basic/master_tRNA_dataset.csv", sep=""))) %>%
  dplyr::select(Strain.Name, A_34, U_34) %>%
  mutate(A_34 = as.numeric(A_34),
         U_34 = as.numeric(A_34))
resp_and_expression_modelling <- left_join(resp_and_expression_modelling, master_dataset, by = "Strain.Name")
```


## 3.1. Get correlations between all the possible numerical variables used for modelling, and represent them in a heatmap
```{r}
resp_measure_corrs <- resp_and_expression_modelling %>%
  dplyr::select_if(is.numeric)

cor_mat <- round(cor(resp_measure_corrs, use = "pairwise.complete.obs"), 2)

melted_corrs <- melt(cor_mat)

ggplot(data = melted_corrs, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  geom_text(aes(Var2, Var1, label = value), size = 3) +
  scale_fill_gradient2(low = "blue", high = "red",
                       limit = c(-1,1), name="Correlation") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))


# Remove unnecessary variables
rm(cor_mat, melted_corrs)
```


## 3.2. Evaluate missingness before model fitting
Methods to fit GLMs use na.omit() before fitting the model! So they are getting rid of all rows with a NA anywhere, which will strongly affect my model

How many rows do we end up with after na.omit() in each case?
```{r}
# Without tRNA expression
check_lit <- resp_and_expression_modelling %>%
  dplyr::select(nDEP, synthetase_abundance_literature, catalytic_constant, codon_frequency) %>%
  na.omit()
nrow(check_lit)
(nrow(check_lit)/nrow(resp_and_expression_modelling))*100
check_WTs <- resp_and_expression_modelling %>%
  dplyr::select(nDEP, synthetase_abundance_our_WTs, catalytic_constant, codon_frequency) %>%
  na.omit()
nrow(check_WTs)
(nrow(check_WTs)/nrow(resp_and_expression_modelling))*100

# With tRNA expression
check_lit <- resp_and_expression_modelling %>%
  dplyr::select(nDEP, tRNA_expression, synthetase_abundance_literature, catalytic_constant, codon_frequency) %>%
  na.omit()
nrow(check_lit)
(nrow(check_lit)/nrow(resp_and_expression_modelling))*100
check_WTs <- resp_and_expression_modelling %>%
  dplyr::select(nDEP, tRNA_expression, synthetase_abundance_our_WTs, catalytic_constant, codon_frequency) %>%
  na.omit()
nrow(check_WTs)
(nrow(check_WTs)/nrow(resp_and_expression_modelling))*100
```

Which are the columns introducing these NAs?
```{r}
sum(is.na(resp_and_expression_modelling$nDEP))
sum(is.na(resp_and_expression_modelling$tRNA_expression))
sum(is.na(resp_and_expression_modelling$synthetase_abundance_literature))
sum(is.na(resp_and_expression_modelling$catalytic_constant))
sum(is.na(resp_and_expression_modelling$codon_frequency))
sum(is.na(resp_and_expression_modelling$synthetase_abundance_our_WTs))
```

Can we fix this in any way? Input the NAs in our measurements for synthetase abundance? - Tbh I don't think that's a great idea 
```{r}
ggplot(data = resp_and_expression_modelling, aes(x = synthetase_abundance_literature, y = synthetase_abundance_our_WTs)) +
  geom_point() +
  geom_abline(col = "red", slope = 0.1) +
  theme_light()
```


## 3.3. Model the data with a GLM 
Poisson - way too much overdispersion
```{r}
# Poisson model
fit <- glm(data = resp_and_expression_modelling,
           formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
           family = poisson)
summary(fit)

# Check overdispersion - seems like there is, unsurprisingly
check_overdispersion(fit)

# Actually in the fit for the Poisson model we can already get an idea of if there is overdispersion or not: we do this by looking at the residual deviance and at the corresponding degrees of freedom, if the ratio between them is roughly 1, there is no overdispersion. If it is larger, there is overdispersion. So yeah, we see that we indeed have it here. 
```

Negative binomial - with 3 variables
```{r}
# With synthetase abundance from van der Haar, 2008
#fit <- glm.nb(data = resp_and_expression_modelling, 
#              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
#              link = log)
#summary(fit)
#check_overdispersion(fit)

# I get a weird error here, which I think I got already at some point in my masters - it doesn't say it, but it is likely due to a convergence error? Last time, using this other package to fit the model worked. Got it from here in both cases: https://stats.stackexchange.com/questions/93352/error-in-fitting-negative-binomial-regression-model-in-r-when-replicating-publis
library(glmmADMB)
fit <- glmmadmb(data = resp_and_expression_modelling,
                formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
                family = "nbinom")
summary(fit)
#check_overdispersion(fit)




# With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)

# What if I fit this model with the same function as above?
fit <- glmmadmb(data = resp_and_expression_modelling,
                formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
                family = "nbinom")
summary(fit)
```

Negative binomial - with 4 variables
```{r}
# With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)

# I get a weird error here, which I think I got already at some point in my masters - it doesn't say it, but it is likely due to a convergence error? Last time, using this other package to fit the model worked. Got it from here in both cases: https://stats.stackexchange.com/questions/93352/error-in-fitting-negative-binomial-regression-model-in-r-when-replicating-publis
library(glmmADMB)
fit <- glmmadmb(data = resp_and_expression_modelling,
                formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
                family = "nbinom")
summary(fit)





# With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)
```

Negative binomial - with 3 variables - remove strains below certain numbers of nDEPs - NOT USING THIS ANYMORE
```{r}
# nDEP > 0
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 0)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 1
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 1)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 2
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 2)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 3
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 3)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 4
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 4)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 5
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 5)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 10
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 10)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency,
              link = log)
summary(fit)
check_overdispersion(fit)
```

Negative binomial - with 4 variables - remove strains below certain numbers of nDEPs - NOT USING THIS ANYMORE
```{r}
# nDEP > 0
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 0)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 1
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 1)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 2
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 2)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 3
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 3)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 4
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 4)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 5
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 5)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)



# nDEP > 10
resp_and_expression_modelling <- resp_and_expression_modelling %>%
  filter(nDEP > 10)

## With synthetase abundance from van der Haar, 2008
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)

## With synthetase abundance from our WTs
fit <- glm.nb(data = resp_and_expression_modelling, 
              formula = nDEP ~ synthetase_abundance_our_WTs*catalytic_constant*codon_frequency*tRNA_expression,
              link = log)
summary(fit)
check_overdispersion(fit)
```


## 3.4. Log-transform nDEP and use a Gaussian model - HONESTLY NOT SURE IF THIS IS WORTH IT
Prepare data
```{r}
gaussian_modelling_df <- resp_and_expression_modelling %>%
  mutate(nDEP = ifelse(nDEP == 0, 0, log2(nDEP)))
```

Very simple linear model
```{r}
fit <- lm(data = gaussian_modelling_df, nDEP ~ synthetase_abundance_literature*catalytic_constant*codon_frequency)
summary(fit)
```




Remove unnecessary variables
```{r}
rm(check_lit, check_WTs, fit, resp_and_expression, resp_and_expression_modelling, resp_measure_corrs, measured_proteomics_WTs)
```








################################################################################
# 4. Evaluate codon enrichment in DEPs sequences
################################################################################
SHOULD I CONSIDER SOME GROUPING BY CODON HERE? LIKE, THE DIFFERENT TRNAS THAT HAVE THE SAME CODON?
Load data (generated in Python script "check_codon_enrichment_in_DEPs_sequences.py")
```{r}
# Load list
codon_ratios_list <- fromJSON(txt = paste(base_dir, "tRNA_KOs/Data/check_codon_enrichment_in_protein_sequences/codon_counts.json", sep=""))

# Remove from the list those strains where there aren't at least 4 DE proteins
bool <- c()
for (i in 1:length(codon_ratios_list)) {
  bool <- c(bool, length(codon_ratios_list[[i]][["DE_up_regulated"]])+length(codon_ratios_list[[i]][["DE_down_regulated"]]) > 4)
}
codon_ratios_list <- codon_ratios_list[bool]


# Load master dataset
master_dataset <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/basic/master_tRNA_dataset.csv", sep="")))

# Load resp_and_expression dataset
resp_and_expression <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/produced_during_analysis/resp_and_expression_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep="")))
```

Iterate over the strains and perform a test for each, testing the mean counts of DE vs. that of non_DE
```{r}
strains <- names(codon_ratios_list)
p.values_wmw_total <- c()
p.values_wmw_up_non <- c()
p.values_wmw_up_down <- c()
p.values_wmw_down_non <- c()
mean_de_total <- c()
mean_de_up <- c()
mean_de_down <- c()
mean_non_de <- c()
num_de_total <- c()
num_de_up <- c()
num_de_down <- c()
num_non_de <- c()
for (i in 1:length(codon_ratios_list)) {
  # Grab data for this strain
  strain_name <- names(codon_ratios_list)[i]
  de_up <- codon_ratios_list[[strain_name]][["DE_up_regulated"]]
  de_down <- codon_ratios_list[[strain_name]][["DE_down_regulated"]]
  de_total <- c(as.numeric(de_up), as.numeric(de_down))
  non_de <- codon_ratios_list[[strain_name]][["non_DE"]]
  de_df_up <- data.frame(codon_ratios_list[[strain_name]][["DE_up_regulated"]])
  de_df_down <- data.frame(codon_ratios_list[[strain_name]][["DE_down_regulated"]])
  de_df_total <- data.frame(de_total)
  non_de_df <- data.frame(codon_ratios_list[[strain_name]][["non_DE"]])
  print(strain_name)
  
  # It's possible that either de_up or de_down (and hence de_df_up or de_df_down) are empty, so I need to account for that if I don't want to get an error
  de_up_empty <- length(de_up) == 0
  de_down_empty <- length(de_down) == 0
  
  if (de_up_empty) {
    # Plot overlapping histograms - not worth it I think
    ggplot() +
      geom_histogram(data = de_df_down, aes(x = log2(codon_ratios_list..strain_name.....DE...)), fill = "blue", alpha = 0.9)
      geom_histogram(data = non_de_df, aes(x = log2(codon_ratios_list..strain_name.....non_DE...)), fill = "orange", alpha = 0.4)
    
    # Test - WMW
    p.values_wmw_total <- c(p.values_wmw_total, wilcox.test(de_total, non_de)$p.value)
    p.values_wmw_up_non <- c(p.values_wmw_up_non, NA)
    p.values_wmw_up_down <- c(p.values_wmw_up_down, NA)
    p.values_wmw_down_non <- c(p.values_wmw_down_non, wilcox.test(de_down, non_de)$p.value)
    
    # Test - log2 transform and t-test (need to take care of 0s) and use t-test - is this worth doing?
    
    
    # Save the mean of each group to the output vectors as well
    mean_de_total <- c(mean_de_total, mean(de_total))
    mean_de_up <- c(mean_de_up, NA)
    mean_de_down <- c(mean_de_down, mean(de_down))
    mean_non_de <- c(mean_non_de, mean(non_de))
    
    # Save the number of proteins in each of the two groups - probably will explain the significance bc of low power with small DE protein counts
    num_de_total <- c(num_de_total, length(de_total))
    num_de_up <- c(num_de_up, length(de_up))
    num_de_down <- c(num_de_down, length(de_down))
    num_non_de <- c(num_non_de, length(non_de))
  }
  else if (de_down_empty) {
    # Plot overlapping histograms - not worth it I think
    ggplot() +
      geom_histogram(data = de_df_up, aes(x = log2(codon_ratios_list..strain_name.....DE...)), fill = "red", alpha = 0.9) +
      geom_histogram(data = non_de_df, aes(x = log2(codon_ratios_list..strain_name.....non_DE...)), fill = "orange", alpha = 0.4)
    
    # Test - WMW
    p.values_wmw_total <- c(p.values_wmw_total, wilcox.test(de_total, non_de)$p.value)
    p.values_wmw_up_non <- c(p.values_wmw_up_non, wilcox.test(de_up, non_de)$p.value)
    p.values_wmw_up_down <- c(p.values_wmw_up_down, NA)
    p.values_wmw_down_non <- c(p.values_wmw_down_non, NA)
    
    # Test - log2 transform and t-test (need to take care of 0s) and use t-test - is this worth doing?
    
    
    # Save the mean of each group to the output vectors as well
    mean_de_total <- c(mean_de_total, mean(de_total))
    mean_de_up <- c(mean_de_up, mean(de_up))
    mean_de_down <- c(mean_de_down, NA)
    mean_non_de <- c(mean_non_de, mean(non_de))
    
    # Save the number of proteins in each of the two groups - probably will explain the significance bc of low power with small DE protein counts
    num_de_total <- c(num_de_total, length(de_total))
    num_de_up <- c(num_de_up, length(de_up))
    num_de_down <- c(num_de_down, length(de_down))
    num_non_de <- c(num_non_de, length(non_de))
  }
  else {
    # Plot overlapping histograms - not worth it I think
    ggplot() +
      geom_histogram(data = de_df_up, aes(x = log2(codon_ratios_list..strain_name.....DE...)), fill = "red", alpha = 0.9) +
      geom_histogram(data = de_df_down, aes(x = log2(codon_ratios_list..strain_name.....DE...)), fill = "blue", alpha = 0.9)
      geom_histogram(data = non_de_df, aes(x = log2(codon_ratios_list..strain_name.....non_DE...)), fill = "orange", alpha = 0.4)
    
    # Test - WMW
    p.values_wmw_total <- c(p.values_wmw_total, wilcox.test(de_total, non_de)$p.value)
    p.values_wmw_up_non <- c(p.values_wmw_up_non, wilcox.test(de_up, non_de)$p.value)
    p.values_wmw_up_down <- c(p.values_wmw_up_down, wilcox.test(de_up, de_down)$p.value)
    p.values_wmw_down_non <- c(p.values_wmw_down_non, wilcox.test(de_down, non_de)$p.value)
    
    # Test - log2 transform and t-test (need to take care of 0s) and use t-test - is this worth doing?
    
    
    # Save the mean of each group to the output vectors as well
    mean_de_total <- c(mean_de_total, mean(de_total))
    mean_de_up <- c(mean_de_up, mean(de_up))
    mean_de_down <- c(mean_de_down, mean(de_down))
    mean_non_de <- c(mean_non_de, mean(non_de))
    
    # Save the number of proteins in each of the two groups - probably will explain the significance bc of low power with small DE protein counts
    num_de_total <- c(num_de_total, length(de_total))
    num_de_up <- c(num_de_up, length(de_up))
    num_de_down <- c(num_de_down, length(de_down))
    num_non_de <- c(num_non_de, length(non_de))
  }
}

p.values.adj_total <- p.adjust(p.values_wmw_total, method = "fdr")
p.values.adj_up_non <- p.adjust(p.values_wmw_up_non, method = "fdr")
p.values.adj_up_down <- p.adjust(p.values_wmw_up_down, method = "fdr")
p.values.adj_down_non <- p.adjust(p.values_wmw_down_non, method = "fdr")

test_codon_enrichment <- data.frame(Strain.Name = strains, p.values_wmw_up_non, p.values.adj_up_non, p.values_wmw_total, p.values.adj_total,
                                    p.values_wmw_up_down, p.values.adj_up_down, p.values_wmw_down_non, p.values.adj_down_non,
                                    mean_de_total, mean_de_up, mean_de_down, mean_non_de, num_de_total, num_de_up, num_de_down, num_non_de) %>%
  dplyr::mutate(direction_up_non = case_when(mean_de_up > mean_non_de ~ "DE_up",
                                      TRUE ~ "non_DE"),
         direction_up_down = case_when(mean_de_up > mean_de_down ~ "DE_up",
                                       TRUE ~ "DE_down"),
         direction_down_non = case_when(mean_de_down > mean_non_de ~ "DE_down",
                                        TRUE ~ "non_DE"),
         FC_total = mean_de_total/mean_non_de,
         FC_up_non = mean_de_up/mean_non_de,
         FC_up_down = mean_de_up/mean_de_down,
         FC_down_non = mean_de_down/mean_non_de,
         logFC_total = log2(FC_total),
         logFC_up_non = log2(FC_up_non),
         logFC_up_down = log2(FC_up_down),
         logFC_down_non = log2(FC_down_non))

# Get the logFC - need to deal with the negative values in the FC - there is definitely a better way to do this but oh well
# THIS IS NOW INCLUDED IN THE MUTATE ABOVE
#logFC <- c()
#for (i in 1:nrow(test_codon_enrichment)) {
#  FC <- test_codon_enrichment$FC[i]
#  if (FC < 1) {
#    out <- -log10(abs(FC))
#  }
#  else if (FC > 1) {
#    out <- log10(FC)
#  }
#  else if (FC == 0) {
#    out <- 0
#  }
#  logFC <- c(logFC, out)
#}
#test_codon_enrichment$logFC <- log10(test_codon_enrichment$FC)


# Remove unnecessary variables
#rm(bool, strains, p.values_wmw, mean_de, mean_non_de, p.values.adj, logFC, FC, out, num_de, num_non_de)
```

Add some information to this plot to be able to color plots by it (amino acid, codon, etc.)
```{r}
temp <- master_dataset %>%
  dplyr::select(Strain.Name, Anticodon, Best_isotype_model_1_letter, Family_size) %>%
  dplyr::rename(AA = Best_isotype_model_1_letter)
test_codon_enrichment <- left_join(test_codon_enrichment, temp, by = "Strain.Name")

temp <- resp_and_expression %>%
  dplyr::select(Strain.Name, codon_frequency_chu_2011)
test_codon_enrichment <- left_join(test_codon_enrichment, temp, by = "Strain.Name")
rm(temp)
```

"Volcano plot" - total DE proteins vs. non-DE proteins
```{r}
# Basic volcano plot - FC vs. -log10(adj.p-value) - tag only significant p-values and FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light() +
  geom_text_repel(data = subset(test_codon_enrichment, (((logFC_total > 0.5 | logFC_total < -0.5) &
                                                           -log10(p.values.adj_total) > -log10(0.05)))|-log10(p.values.adj_total) > -log10(0.05)),
                  aes(x = logFC_total, y = -log10(p.values.adj_total), label = Strain.Name)) +
  xlab("logFC") +
  ylab("-log10(p-value)") +
  labs(title = "Testing results for target codon proportion in DE vs. non-DE proteins",
       subtitle = "Each dot represents a strain")

# Basic volcano plot - FC vs. -log10(adj.p-value) - tag all significant FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light() +
  geom_text_repel(data = subset(test_codon_enrichment, logFC_total > 0.5 | logFC_total < -0.5), 
                  aes(x = logFC_total, y = -log10(p.values.adj_total), label = Strain.Name))

# Color by count of DE proteins
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total), col = num_de_total)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by family
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total), col = Anticodon)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by family size
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total), col = Family_size)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by amino acid
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total), col = AA)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by codon frequency
ggplot(data = test_codon_enrichment, aes(x = logFC_total, y = -log10(p.values.adj_total), col = codon_frequency_chu_2011)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()
```

"Volcano plot" - up-regulated vs. non-DE proteins
```{r}
# Basic volcano plot - FC vs. -log10(adj.p-value) - tag only significant p-values and FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_up_non, y = -log10(p.values.adj_up_non))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light() +
  geom_text_repel(data = subset(test_codon_enrichment, (((logFC_up_non > 0.5 | logFC_up_non < -0.5) &
                                                           -log10(p.values.adj_up_non) > -log10(0.05)))|-log10(p.values.adj_up_non) > -log10(0.05)),
                  aes(x = logFC_up_non, y = -log10(p.values.adj_up_non), label = Strain.Name))

# Basic volcano plot - FC vs. -log10(adj.p-value) - tag all significant FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_up_non, y = -log10(p.values.adj_up_non))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light() +
  geom_text_repel(data = subset(test_codon_enrichment, logFC_up_non > 0.5 | logFC_up_non < -0.5), 
                  aes(x = logFC_up_non, y = -log10(p.values.adj_up_non), label = Strain.Name))

# Color by count of DE proteins
ggplot(data = test_codon_enrichment, aes(x = logFC_up_non, y = -log10(p.values.adj_up_non), col = num_de_up)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by family
ggplot(data = test_codon_enrichment, aes(x = logFC_up_non, y = -log10(p.values.adj_up_non), col = Anticodon)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by family size
ggplot(data = test_codon_enrichment, aes(x = logFC_up_non, y = -log10(p.values.adj_up_non), col = Family_size)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by amino acid
ggplot(data = test_codon_enrichment, aes(x = logFC_up_non, y = -log10(p.values.adj_up_non), col = AA)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by codon frequency
ggplot(data = test_codon_enrichment, aes(x = logFC_up_non, y = -log10(p.values.adj_up_non), col = codon_frequency_chu_2011)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()
```

"Volcano plot" - dowm-regulated vs. non-DE proteins
```{r}
# Basic volcano plot - FC vs. -log10(adj.p-value) - tag only significant p-values and FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_down_non, y = -log10(p.values.adj_down_non))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light() +
  geom_text_repel(data = subset(test_codon_enrichment, (((logFC_down_non > 0.5 | logFC_down_non < -0.5) &
                                                           -log10(p.values.adj_down_non) > -log10(0.05)))|-log10(p.values.adj_down_non) > -log10(0.05)),
                  aes(x = logFC_down_non, y = -log10(p.values.adj_down_non), label = Strain.Name))

# Basic volcano plot - FC vs. -log10(adj.p-value) - tag all significant FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_down_non, y = -log10(p.values.adj_down_non))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light() +
  geom_text_repel(data = subset(test_codon_enrichment, logFC_down_non > 0.5 | logFC_down_non < -0.5), 
                  aes(x = logFC_down_non, y = -log10(p.values.adj_down_non), label = Strain.Name))

# Color by count of DE proteins
ggplot(data = test_codon_enrichment, aes(x = logFC_down_non, y = -log10(p.values.adj_down_non), col = num_de_down)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by family
ggplot(data = test_codon_enrichment, aes(x = logFC_down_non, y = -log10(p.values.adj_down_non), col = Anticodon)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by family size
ggplot(data = test_codon_enrichment, aes(x = logFC_down_non, y = -log10(p.values.adj_down_non), col = Family_size)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by amino acid
ggplot(data = test_codon_enrichment, aes(x = logFC_down_non, y = -log10(p.values.adj_down_non), col = AA)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by codon frequency
ggplot(data = test_codon_enrichment, aes(x = logFC_down_non, y = -log10(p.values.adj_down_non), col = codon_frequency_chu_2011)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()
```

"Volcano plot" - up-regulated vs. down-regulated proteins
```{r}
# Basic volcano plot - FC vs. -log10(adj.p-value) - tag only significant p-values and FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_up_down, y = -log10(p.values.adj_up_down))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light() +
  geom_text_repel(data = subset(test_codon_enrichment, (((logFC_up_down > 0.5 | logFC_up_down < -0.5) &
                                                           -log10(p.values.adj_up_down) > -log10(0.05)))|-log10(p.values.adj_up_down) > -log10(0.05)),
                  aes(x = logFC_up_down, y = -log10(p.values.adj_up_down), label = Strain.Name))

# Basic volcano plot - FC vs. -log10(adj.p-value) - tag all significant FCs
ggplot(data = test_codon_enrichment, aes(x = logFC_up_down, y = -log10(p.values.adj_up_down))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light() +
  geom_text_repel(data = subset(test_codon_enrichment, logFC_up_down > 0.5 | logFC_up_down < -0.5), 
                  aes(x = logFC_up_down, y = -log10(p.values.adj_up_down), label = Strain.Name))

# Color by count of DE proteins
#ggplot(data = test_codon_enrichment, aes(x = logFC_up_down, y = -log10(p.values.adj_up_down), col = num_de_total)) +
#  geom_point() +
#  geom_hline(yintercept = -log10(alpha), col = "red") +
#  geom_vline(xintercept = 0.5, col = "red") +
#  geom_vline(xintercept = -0.5, col = "red") +
#  theme_light()

# Color by family
ggplot(data = test_codon_enrichment, aes(x = logFC_up_down, y = -log10(p.values.adj_up_down), col = Anticodon)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by family size
ggplot(data = test_codon_enrichment, aes(x = logFC_up_down, y = -log10(p.values.adj_up_down), col = Family_size)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by amino acid
ggplot(data = test_codon_enrichment, aes(x = logFC_up_down, y = -log10(p.values.adj_up_down), col = AA)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()

# Color by codon frequency
ggplot(data = test_codon_enrichment, aes(x = logFC_up_down, y = -log10(p.values.adj_up_down), col = codon_frequency_chu_2011)) +
  geom_point() +
  geom_hline(yintercept = -log10(alpha), col = "red") +
  geom_vline(xintercept = 0.5, col = "red") +
  geom_vline(xintercept = -0.5, col = "red") +
  theme_light()
```




Remove unnecessary variables
```{r}
rm(codon_ratios_list, de_df, master_dataset, non_de_df, resp_and_expression, test_codon_enrichment, de, i, non_de, strain_name)
```







################################################################################
# 5. Look for the expression of the tRNA synthetases in my proteomics data
################################################################################
## 5.0. Load data
```{r}
# Processed KO proteomics dataframe
trna_ko <- as.data.frame(as.matrix(fread(paste(base_dir, "tRNA_KOs/Data/proteomics_data/processed_proteomics_dataframe.tsv", sep="")), rownames = 1))

# List of dataframes with the proteins that were DE in each KO strain
de_proteins_list <- fromJSON(paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/de_proteins_list_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""))

## Remove WT dataframe
de_proteins_list <- de_proteins_list[names(de_proteins_list) != "WT"]

# Synthetase information
chu_synths <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/Articles/chu_2011/S3.csv", sep="")))[1:20,] 
synthetases <- fread(paste(base_dir, "tRNA_KOs/Data/basic/trna_synthetases.csv", sep=""))

# Yeastmine
yeastmine <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))

# Responsiveness

```


## 5.1. Evaluate some basic stuff about synthetases: how many are there, how many do I detect, etc.
Check how many synthetases exist in Sc
```{r}
# How many tRNA synthases
sum(grepl("trna synthase", synthetases$Gene.name, ignore.case = T))

# How many tRNA synthetases 
sum(grepl("trna synthetase", synthetases$Gene.name, ignore.case = T))

# How many are mitochondrial?
sum(grepl("mitochondrial", synthetases$Gene.name, ignore.case = T))
```

Check how many of them we detect in our dataset
```{r}
# Get all the proteins we detect into systematic notation
detected_proteins <- match_systematic_and_standard_protein_names(data = rownames(trna_ko),
                                                                 yeastmine = yeastmine,
                                                                 input = "standard",
                                                                 simplify = T)

# See how many tRNA synthetases are in there: 18, 67% of them
sum(detected_proteins %in% synthetases$Gene.secondaryIdentifier)
sum(detected_proteins %in% synthetases$Gene.secondaryIdentifier)/length(unique(synthetases$Gene.secondaryIdentifier))

# Check which ones: only 1 is mitochondrial, all others are cytosolic - so I think we are mainly interested in cytosolic, we detect 17 of the 18 there are, the one we don't detect is YPL040C
synths_detected <- synthetases[synthetases$Gene.secondaryIdentifier %in% detected_proteins,]
sum(synths_detected$mitochondrial == "Yes")
sum(synthetases$mitochondrial == "No")
temp <- synthetases$Gene.secondaryIdentifier[synthetases$mitochondrial == "No"]
synthetases$Gene.secondaryIdentifier[!(synthetases$Gene.secondaryIdentifier %in% synths_detected$Gene.secondaryIdentifier) & (synthetases$mitochondrial == "No")]
```

Check how much of each we detect across WTs, add that information to the dataset and save the dataset
```{r}
# Prepare
WTs <- trna_ko[, grepl("WT", colnames(trna_ko))]
KOs <- trna_ko[, !grepl("WT", colnames(trna_ko))]
rownames(WTs) <- match_systematic_and_standard_protein_names(as.character(rownames(WTs)),
                                                             yeastmine = yeastmine, 
                                                             input = "standard",
                                                             simplify = T)

# Actually check and save it to a new column in the dataframe
measured_proteomics_WTs <- c()
quantified_in_how_many_WTs <- c()
quantified_in_how_many_KO_samples <- c()
for (i in 1:nrow(synthetases)) {
  synth <- synthetases$Gene.secondaryIdentifier[i]
  
  # If the synthetase is detected at all, present in the dataset
  if (synth %in% rownames(WTs)) {
    ## Get the average expression of this synthetase across WTs
    synth_quant_across_WTs <- as.numeric(WTs[rownames(WTs) == synth,])
    measured_proteomics_WTs <- c(measured_proteomics_WTs, mean(synth_quant_across_WTs, na.rm = T))
    hist(as.numeric(WTs[rownames(WTs) == synth,]))
    
    ## In how many WT samples is this synthetase actually detected? (value != 0)
    quantified_in_how_many_WTs <- c(quantified_in_how_many_WTs, sum(synth_quant_across_WTs != 0))
    
    ## In how many samples in total is this synthetase actually detected? (value != 0)
    synth_quant_across_KO_samples <- as.numeric(KOs[rownames(KOs) == synth,])
    quantified_in_how_many_KO_samples <- c(quantified_in_how_many_KO_samples, sum(synth_quant_across_all_samples != 0))
  }
  
  # If it is not
  else {
    measured_proteomics_WTs <- c(measured_proteomics_WTs, NA)
    quantified_in_how_many_WTs <- c(quantified_in_how_many_WTs, NA)
    quantified_in_how_many_KO_samples <- c(quantified_in_how_many_KO_samples, NA)
  }
}
synthetases$measured_proteomics_WTs_WT <- measured_proteomics_WTs
synthetases$quantified_in_how_many_WTs <- quantified_in_how_many_WTs
synthetases$quantified_in_how_many_KO_samples <- quantified_in_how_many_KO_samples


# Add columns with all other amino acid information
temp <- fread(paste(base_dir, "tRNA_KOs/Data/databases/GtRNAdb/amino_acids.csv", sep="")) %>%
  dplyr::select(-molecular_weight_Da)
synthetases <- left_join(synthetases, temp, by = "Amino_acid_3_letter")


# One final thing - add information of which ones are included in the TS library, and which ones are included in the GFP/RFP data
ts_sample_layout <- as.data.frame(fread(paste(base_dir, "TSSC/Data/Boone_lab/sample_layout.csv", sep="")))
ts_fluorescence_raw_1 <- as.data.frame(fread(paste(base_dir, "TSSC/Data/Boone_lab/Fluorescence/raw_1.csv", sep="")))

synthetases <- synthetases %>%
  dplyr::mutate(in_ts_library = case_when(Gene.secondaryIdentifier %in% ts_sample_layout$Sys.Name ~ "Yes",
                                          TRUE ~ "No"),
                in_fluorescence_data = case_when(Gene.symbol %in% ts_fluorescence_raw_1$Gene ~ "Yes",
                                                 TRUE ~ "No"))

# Get a subset of this for a screenshot for a slide
temp <- synthetases %>%
  dplyr::select(Gene.name, Gene.symbol, Gene.secondaryIdentifier, mitochondrial, Amino_acid_3_letter, in_ts_library, in_fluorescence_data)


# Save this dataset
fwrite(synthetases, paste(base_dir, "tRNA_KOs/Data/basic/trna_synthetases.csv", sep=""))
```


## 5.2. Go over the KO strains and see if any of the synthetases are DE in any of them
```{r}
de_synthetases <- list()
direction <- list()
for (i in 1:length(de_proteins_list)) {
  strain <- names(de_proteins_list)[i]
  de_proteins <- de_proteins_list[[i]]
  temp <- de_proteins[de_proteins %in% synthetases$Gene.secondaryIdentifier]
  if (length(temp) > 0) {
    de_synthetases[[names(de_proteins_list)[i]]] <- temp
    
    direction_this_strain <- c()
    for (j in 1:length(temp)) {
      protein <- temp[j]
      direction_this_strain <- c(direction_this_strain, da$diffexpressed_adjusted[da$protein == protein & da$Strain.Name == strain])
    }
    direction[[names(de_proteins_list)[i]]] <- direction_this_strain
  }
}

# Get a table summarizing this
temp <- unlist(de_synthetases)
sort(table(temp))

# Are these up- or down-regulated?


# Remove unnecessary variables
rm(de_proteins, temp)
```
--> At alpha = 0.05 and logFC = 0 I think --> All the DE synthetases I observe are in 33 (or something like that) out of the 197 KO strains! That's gotta mean something, I have to check what is special about those strains (maybe they are just the ones with the most DE proteins or something like that, who knows, but still, need to check if there is something special about the amino acid they carry or whatever)


## 5.3. Use the information obtained in the previous chunk, of which synthetases are DE in which KO strains, to capture the information from those genes in those strains
```{r}
grab_de_synthetases_dfs <- function(da, de_synthetases, yeastmine) {
  de_synthetases_dfs <- list()
  for (i in 1:length(da)) {
    strain_name <- names(da)[[i]]
    strains_with_de_synths <- names(de_synthetases)
    if (strain_name %in% strains_with_de_synths) {
      temp <- da[[i]]
      rownames(temp) <- match_systematic_and_standard_protein_names(data = rownames(temp),
                                                                       yeastmine = yeastmine,
                                                                       input = "standard",
                                                                       simplify = T) 
      temp <- temp[rownames(temp) %in% de_synthetases[[strain_name]],]
      temp$Synthetase <- rownames(temp)
      temp$Strain.Name <- strain_name
      de_synthetases_dfs[[strain_name]] <- temp
    }
  }
  
  # Turn the resulting list into a single dataframe
  de_synthetases_df <- bind_rows(de_synthetases_dfs)
  rownames(de_synthetases_df) <- NULL
  
  # Add a column with the standard names for the tRNA synthetase genes
  temp <- match_systematic_and_standard_protein_names(data = as.character(de_synthetases_df$Synthetase),
                                                      yeastmine = yeastmine, 
                                                      input = "systematic",
                                                      simplify = T)
  de_synthetases_df$Synthetase_standard <- temp
  de_synthetases_df <- de_synthetases_df %>%
    dplyr::rename(Synthetase_systematic = Synthetase)
  
  return(de_synthetases_df)
}


da <- read_json(path=paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/da_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), simplifyVector = T)

de_synthetases_df <- grab_de_synthetases_dfs(da, de_synthetases, yeastmine)
```

Add 2 columns: one for the amino acid which the KOd tRNA carries, another for the the amino acid that is loaded by the synthetase found to be DE
```{r}
add_2_columns <- function(de_synthetases_df) {
  # Amino acid carried by the KOd tRNA
  temp <- master_dataset %>%
    dplyr::select(Strain.Name, Amino_acid_1_letter, anticodon, codon, chromosome, Family_size)
  de_synthetases_df <- left_join(de_synthetases_df, temp, by = "Strain.Name") 
  
  temp <- amino_acids %>%
    dplyr::select(Amino_acid_1_letter, amino_acid_charge, amino_acid_type) %>%
    dplyr::rename(AA_charge_tRNA = amino_acid_charge,
           AA_type_tRNA = amino_acid_type)
  de_synthetases_df <- left_join(de_synthetases_df, temp, by = "Amino_acid_1_letter") %>%
    dplyr::rename(AA_carried_by_tRNA = Amino_acid_1_letter)
  
  # Amino acid loaded by the synthetase
  temp <- amino_acids %>%
    dplyr::select(Amino_acid_name, Amino_acid_1_letter, Amino_acid_3_letter, amino_acid_charge, amino_acid_type) %>%
    dplyr::rename(AA_loaded_by_synthetase = Amino_acid_1_letter,
           AA_charge_synth = amino_acid_charge,
           AA_type_synth = amino_acid_type)
  
  temp_2 <- left_join(chu_synths_new, temp, by = "Amino_acid_3_letter") %>%
    dplyr::select(Gene.secondaryIdentifier, AA_charge_synth, AA_type_synth) %>%
    dplyr::rename(Synthetase = Gene.secondaryIdentifier)
  
  temp_3 <- temp_2 %>%
    group_by(Synthetase) %>%
    summarise(text=paste(AA_charge_synth, collapse = ",")) %>%
    dplyr::rename(AA_charge_synth = text,
           Synthetase_systematic = Synthetase)
  
  temp_4 <- temp_2 %>%
    group_by(Synthetase) %>%
    summarise(text=paste(AA_type_synth, collapse = ",")) %>%
    dplyr::rename(AA_type_synth = text,
           Synthetase_systematic = Synthetase)
  
  de_synthetases_df <- left_join(de_synthetases_df, temp_3, by = "Synthetase_systematic")
  de_synthetases_df <- left_join(de_synthetases_df, temp_4, by = "Synthetase_systematic")
  
  temp <- left_join(chu_synths_new, temp, by = "Amino_acid_3_letter") %>%
    dplyr::select(Gene.secondaryIdentifier, AA_loaded_by_synthetase) %>%
    dplyr::rename(Synthetase = Gene.secondaryIdentifier) %>%
    group_by(Synthetase) %>%
    summarise(text=paste(AA_loaded_by_synthetase, collapse = ",")) %>%
    dplyr::rename(AA_loaded_by_synthetase = text,
           Synthetase_systematic = Synthetase)
  de_synthetases_df <- left_join(de_synthetases_df, temp, by = "Synthetase_systematic") 
  
  return(de_synthetases_df)
}

amino_acids <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/GtRNAdb/amino_acids.csv", sep=""))) 
master_dataset <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/basic/master_tRNA_dataset.csv", sep="")))

de_synthetases_df <- add_2_columns(de_synthetases_df)


# Also add a column which counts how many DE synthetases there are in each strain, and also another one with in how many strains each synthetase is DE
de_synthetases_df <- de_synthetases_df %>%
  group_by(Strain.Name) %>%
  mutate(DE_synths_per_strain = n()) %>%
  ungroup() %>%
  group_by(Synthetase_systematic) %>%
  mutate(strains_per_synth = n())

# Add the information from the synthetases dataframe of in how many total samples and in how many WT samples each synthetase is detected
temp <- synthetases %>%
  dplyr::select(Gene.secondaryIdentifier, measured_proteomics_WTs_WT, quantified_in_how_many_WTs, quantified_in_how_many_KO_samples) %>%
  dplyr::rename(Synthetase_systematic = Gene.secondaryIdentifier)
de_synthetases_df<- de_synthetases_df %>%
  left_join(temp, by = "Synthetase_systematic")


# Remove unnecessary variables
rm(chu_synths, chu_synths_new, de_proteins_list, new_row, trna_ko, yeastmine,
   std_name, std_names, i, j, check, detected_proteins, de_synthetases,
   grab_de_synthetases_dfs, da, amino_acids, add_2_columns, synths_detected)
```


## 5.4. Check how many synthetases we have TS alleles for in the Boone library
There are 13 of them, none of them mitochondrial, none of them the ARC1 cofactor, one of them a synthase - 2 of them were sick when sent and did not grow
```{r}
ts_library <- as.data.frame(fread(paste(base_dir, "TSSC/Data/Boone_lab/Growth/Mine/Processed_by_them/growth_agar_matched.tsv", sep="")))
ts_library_synths <- ts_library[ts_library$Systematic_name %in% synthetases$Gene.secondaryIdentifier,]
synths_in_ts_library_info <- synthetases[synthetases$Gene.secondaryIdentifier %in% ts_library$Systematic_name,] 
```


## 5.5. There are only 33 strains with DE synthetases - is there anything special about them?
```{r}
unique(de_synthetases_df$AA_carried_by_tRNA)
unique(de_synthetases_df$anticodon)
unique(de_synthetases_df$chromosome)

length(unique(de_synthetases_df$AA_carried_by_tRNA))
length(unique(de_synthetases_df$anticodon))
length(unique(de_synthetases_df$chromosome))
```

```{r}
sort(table(de_synthetases_df$AA_loaded_by_synthetase))

# Rank the 33 KO strains based on AA_type_synth
sort(table(de_synthetases_df$AA_type_synth))

# Rank the 33 KO strains based on how many DE synthetases there are in each of them

```

More plots
```{r}
# Boxplots for the number of DE synthetases per amino acid carried
ggplot(data = de_synthetases_df, aes(x = AA_carried_by_tRNA, y = DE_synths_per_strain)) +
  geom_boxplot(col = "black") +
  theme_light() +
  labs(title = "Number of DE synthetases by the amino acid carried by the KOd tRNA") +
  xlab("Amino acid carried by the tRNA") +
  ylab("Count of DE synthetases")

# Scatter plot for the number of strains in which each synthetase is DE
ggplot(data = de_synthetases_df, aes(x = Synthetase_standard, y = strains_per_synth, col = AA_loaded_by_synthetase)) +
  geom_point(size = 3) +
  theme_light() +
  labs(title = "Number of strains in which each synthetase is DE",
       col = "AA loaded by synthetase") +
  xlab("Synthetase") +
  ylab("Strain count") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  guides(col=guide_legend(ncol=2))

# Scatter plot: number of strains in which each synthetase is DE vs. number of samples in which that synthetase is detected
ggplot(data = de_synthetases_df, aes(x = Synthetase_standard, y = strains_per_synth, col = AA_loaded_by_synthetase)) +
  geom_point(size = 3) +
  theme_light() +
  labs(title = "Number of strains in which each synthetase is DE",
       col = "AA loaded by synthetase") +
  xlab("Synthetase") +
  ylab("Strain count") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  guides(col=guide_legend(ncol=2))
```


## 5.6. Save the dataframes with the information on the DE synthetases and remove everything
```{r}
# Save them
fwrite(de_synthetases_df_001, paste(base_dir, "tRNA_KOs/Data/synthetases/de_synthetases_df_001.tsv", sep=""))
fwrite(de_synthetases_df_005, paste(base_dir, "tRNA_KOs/Data/synthetases/de_synthetases_df_005.tsv", sep=""))

# Remove everything
rm(de_synthetases_df_001, de_synthetases_df_005, ts_library, synths_in_ts_library_info, ts_library_synths, synthetases, WTs, master_dataset, synth, measured_proteins)
```







######################################################################################
# 6. Check if different KOs with the same anticodon cause the same proteins to be DE
######################################################################################
## 6.0. Load data
```{r}
# List of dataframes with the proteins that were DE in each KO strain
de_proteins_list <- fromJSON(paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/de_proteins_list_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""))

## Remove WT dataframe
de_proteins_list <- de_proteins_list[names(de_proteins_list) != "WT"]

# Load responsiveness dataset
responsiveness <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/produced_during_analysis/responsiveness_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".csv", sep="")))

# Master dataset
master_dataset <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/basic/master_tRNA_dataset.csv", sep="")))
```




## 6.1. Jaccard index heatmaps - KOs with no DEPs are ignored here, not included in the plots!
Heatmaps by anticodon - without NAs
```{r}
# Preparations: remove KOs with 0 DE proteins from list, grab anticodon names, create empty list to put Jaccard index matrices there
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list)
anticodons <- unique(responsiveness$anticodon)
jaccard_matrices_list <- list()

# Iterate over the anticodons and get a Jaccard index matrix for each of them
for (i in 1:length(anticodons)) {
  # For each anticodon, grab the tRNAs that contain it, and get a matrix with the Jaccard index across them
  anticodon <- anticodons[i]
  KOs_with_anticodon <- names(de_protein_list)[grepl(anticodon, names(de_protein_list))]
  
  # This is so I don't end up with matrices with a single cell
  if (length(KOs_with_anticodon) > 1) {
    jaccard_matrix <- get_jaccad_index_matrix(de_protein_list, KOs_with_anticodon)
    jaccard_matrices_list[[anticodon]] <- jaccard_matrix
  }
}

# Iterate over the Jaccard index matrices and get a heatmap from each of them
plot_list <- list()
for (i in 1:length(jaccard_matrices_list)) {
  anticodon <- names(jaccard_matrices_list)[i]
  mat <- jaccard_matrices_list[[i]]
  melt_mat <- melt(mat)
  plot_list[[i]] <- ggplot(melt_mat, aes(Var1, Var2)) +
                      geom_tile(aes(fill = value), colour = "white") +
                      scale_fill_gradient(low = "white", high = "red") +
                      xlab("") +
                      ylab("") +
                      labs(title = glue("{anticodon}")) +
                      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
}


## Print to PDF
my_grobs <- lapply(plot_list, ggplotGrob)
output_file <- paste(base_dir, "tRNA_KOs/Output/Plots/compare_DEPs_across_KOs/jaccard/Jaccard_index_heatmaps_per_anticodon_no_NAs_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=3, ncol=3), 
   width = 15, height = 9
)


# Remove unnecessary variables
rm(anticodons, jaccard_matrices_list, anticodon, KOs_with_anticodon, jaccard_matrix, plot_list, my_grobs, output_file, melt_mat, mat, i)
```

Heatmaps by amino acid - without NAs
```{r}
# Preparations: remove KOs with 0 DE proteins from list, grab anticodon names, create empty list to put Jaccard index matrices there
de_protein_list <- Filter(function(x) length(x) > 0, de_proteins_list)
amino_acids <- unique(responsiveness$Amino_acid_1_letter)
jaccard_matrices_list <- list()

# Iterate over the amino acids and get a Jaccard index matrix for each of them
for (i in 1:length(amino_acids)) {
  # For each amino acid, grab the tRNAs that carry it, and get a matrix with the Jaccard index across them
  aa <- amino_acids[i]
  strain_names <- unique(responsiveness$Strain.Name[responsiveness$Amino_acid_1_letter == aa])
  KOs_with_amino_acid <- names(de_protein_list)[names(de_protein_list) %in% strain_names]
  
  # This is so I don't end up with matrices with a single cell
  if (length(KOs_with_amino_acid) > 1) {
    jaccard_matrix <- get_jaccad_index_matrix(de_protein_list, KOs_with_amino_acid)
    jaccard_matrices_list[[aa]] <- jaccard_matrix
  }
}

# Iterate over the Jaccard index matrices and get a heatmap from each of them
plot_list <- list()
for (i in 1:length(jaccard_matrices_list)) {
  aa <- names(jaccard_matrices_list)[i]
  mat <- jaccard_matrices_list[[i]]
  melt_mat <- melt(mat)
  plot_list[[i]] <- ggplot(melt_mat, aes(Var1, Var2)) +
                      geom_tile(aes(fill = value), colour = "white") +
                      scale_fill_gradient(low = "white", high = "red") +
                      xlab("") +
                      ylab("") +
                      labs(title = glue("{aa}")) +
                      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
}

my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file <- paste(base_dir, "tRNA_KOs/Output/Plots/compare_DEPs_across_KOs/jaccard/Jaccard_index_heatmaps_per_amino_acid_no_NAs_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=2, ncol=3), 
   width = 15, height = 9
)


# Remove unnecessary variables
rm(jaccard_matrices_list, jaccard_matrix, plot_list, my_grobs, output_file, mat, melt_mat, aa, amino_acids, i, KOs_with_amino_acid, strain_names)
```

Heatmaps by anticodon - with NAs
```{r}
# Preparations: remove KOs with 0 DE proteins from list, grab anticodon names, create empty list to put Jaccard index matrices there
anticodons <- unique(responsiveness$anticodon)
jaccard_matrices_list <- list()

# Iterate over the anticodons and get a Jaccard index matrix for each of them
for (i in 1:length(anticodons)) {
  # For each anticodon, grab the tRNAs that contain it, and get a matrix with the Jaccard index across them
  anticodon <- anticodons[i]
  KOs_with_anticodon <- names(de_protein_list)[grepl(anticodon, names(de_protein_list))]
  
  # This is so I don't end up with matrices with a single cell
  if (length(KOs_with_anticodon) > 1) {
    jaccard_matrix <- get_jaccad_index_matrix(de_protein_list, KOs_with_anticodon)
    jaccard_matrices_list[[anticodon]] <- jaccard_matrix
  }
}

# Iterate over the Jaccard index matrices and get a heatmap from each of them
plot_list <- list()
for (i in 1:length(jaccard_matrices_list)) {
  anticodon <- names(jaccard_matrices_list)[i]
  mat <- jaccard_matrices_list[[i]]
  melt_mat <- melt(mat)
  plot_list[[i]] <- ggplot(melt_mat, aes(Var1, Var2)) +
                      geom_tile(aes(fill = value), colour = "white") +
                      scale_fill_gradient(low = "white", high = "red") +
                      xlab("") +
                      ylab("") +
                      labs(title = glue("{anticodon}")) +
                      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
}

my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file <- paste(base_dir, "tRNA_KOs/Output/Plots/compare_DEPs_across_KOs/jaccard/Jaccard_index_heatmaps_per_anticodon_with_NAs_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=3, ncol=3), 
   width = 15, height = 9
)


# Remove unnecessary variables
rm(anticodons, jaccard_matrices_list, anticodon, KOs_with_anticodon, jaccard_matrix, plot_list, my_grobs, output_file, mat, melt_mat, i)
```

Heatmaps by amino acid - with NAs
```{r}
# Preparations: remove KOs with 0 DE proteins from list, grab anticodon names, create empty list to put Jaccard index matrices there
amino_acids <- unique(responsiveness$Amino_acid_1_letter)
jaccard_matrices_list <- list()

# Iterate over the amino acids and get a Jaccard index matrix for each of them
for (i in 1:length(amino_acids)) {
  # For each amino acid, grab the tRNAs that carry it, and get a matrix with the Jaccard index across them
  aa <- amino_acids[i]
  strain_names <- unique(responsiveness$Strain.Name[responsiveness$Amino_acid_1_letter == aa])
  KOs_with_amino_acid <- names(de_protein_list)[names(de_protein_list) %in% strain_names]
  
  # This is so I don't end up with matrices with a single cell
  if (length(KOs_with_amino_acid) > 1) {
    jaccard_matrix <- get_jaccad_index_matrix(de_protein_list, KOs_with_amino_acid)
    jaccard_matrices_list[[aa]] <- jaccard_matrix
  }
}

# Iterate over the Jaccard index matrices and get a heatmap from each of them
plot_list <- list()
for (i in 1:length(jaccard_matrices_list)) {
  aa <- names(jaccard_matrices_list)[i]
  mat <- jaccard_matrices_list[[i]]
  melt_mat <- melt(mat)
  plot_list[[i]] <- ggplot(melt_mat, aes(Var1, Var2)) +
                      geom_tile(aes(fill = value), colour = "white") +
                      scale_fill_gradient(low = "white", high = "red") +
                      xlab("") +
                      ylab("") +
                      labs(title = glue("{aa}")) +
                      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
}

my_grobs <- lapply(plot_list, ggplotGrob)

## Print to PDF
output_file <- paste(base_dir, "tRNA_KOs/Output/Plots/compare_DEPs_across_KOs/jaccard/Jaccard_index_heatmaps_per_amino_acid_with_NAs_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".pdf", sep = "")
ggsave(
   filename = output_file, 
   plot = marrangeGrob(my_grobs, nrow=2, ncol=3), 
   width = 15, height = 9
)


# Remove unnecessary variables
rm(KOs_with_anticodon, jaccard_matrix, jaccard_matrices_list, plot_list, my_grobs, output_file, mat, melt_mat, i, aa, amino_acids, KOs_with_amino_acid, strain_names)
```






## 6.3. Intersections between all KOs, collecting all possible information in the columns 
### 6.3.1. Create dataframe
Create dataframe - only basic columns that are obtained through iteration
```{r}
# Prepare for iterations, create empty vectors to which I will save the information (and from which I'll create a dataframe afterwards)
observed_pairs <- c()
strains <- names(de_proteins_list)
strains_1 <- c()
strains_2 <- c()
protein_number_1 <- c()
protein_number_2 <- c()
protein_names_1 <- c()
protein_names_2 <- c()
overlap <- c()
overlap_size <- c()


# First iteration through the strains
for (i in 1:length(strains)) {
  strain_1 <- strains[i]
  proteins_strain_1 <- de_proteins_list[[strain_1]]
  
  # Second iteration through the strains
  for (j in 1:length(strains)) {
    strain_2 <- strains[j]
    proteins_strain_2 <- de_proteins_list[[strain_2]]
    
    # Make sure we are not comparing a strain to itself
    condition_1 = strain_1 != strain_2
    
    # Also make sure that we haven't added this pair of strains before already
    strain_pair <- paste(sort(c(strain_1, strain_2)), collapse = ",")
    condition_2 = !(strain_pair %in% observed_pairs)
    
    # If both these conditions are covered, analyze the pair of strains and add their characteristics to the output vectors
    if (condition_1 & condition_2) {
      strains_1 <- c(strains_1, strain_1)
      strains_2 <- c(strains_2, strain_2)
      protein_number_1 <- c(protein_number_1, length(proteins_strain_1))
      protein_number_2 <- c(protein_number_2, length(proteins_strain_2))
      protein_names_1 <- c(protein_names_1, paste(proteins_strain_1, collapse = ","))
      protein_names_2 <- c(protein_names_2, paste(proteins_strain_2, collapse = ","))
      overlap <- c(overlap, paste(intersect(proteins_strain_1, proteins_strain_2), collapse = ","))
      overlap_size <- c(overlap_size, length(intersect(proteins_strain_1, proteins_strain_2)))
      
      observed_pairs <- c(observed_pairs, paste(sort(c(strain_1, strain_2)), collapse = ","))
    }
  }
}

DE_protein_overlaps <- data.frame(strains_1, strains_2, protein_number_1, protein_number_2, overlap_size, protein_names_1, protein_names_2, overlap)
```

Add all other columns (calculations or matching to master or responsiveness datasets) - I am not using all variables from these dataset, only the most basic ones for now - I'll explore those and then I can always come back and add more
```{r}
DE_protein_overlaps <- DE_protein_overlaps %>%
  rowwise() %>%
  mutate(protein_number_avg = mean(c(protein_number_1, protein_number_2)),
         Gene_type_1 = unique(responsiveness$Gene_type[responsiveness$Strain.Name == strains_1])[1],
         Gene_type_2 = unique(responsiveness$Gene_type[responsiveness$Strain.Name == strains_2])[1]) %>%
  ungroup() %>%
  mutate(overlap_over_strain_1 = overlap_size/protein_number_1,
         overlap_over_strain_2 = overlap_size/protein_number_2,
         overlap_over_union = overlap_size/(protein_number_1+protein_number_2),
         overlap_over_log_union = overlap_size/log2(protein_number_1+protein_number_2),
         Jaccard_index = overlap_size/(protein_number_1+protein_number_2-overlap_size))

# Match to strain_1
DE_protein_overlaps <- DE_protein_overlaps %>%
  dplyr::rename(Strain.Name = strains_1)
temp <- responsiveness %>%
  dplyr::select(Strain.Name, anticodon, Amino_acid_1_letter, chromosome_letter, amino_acid_type, amino_acid_charge)

DE_protein_overlaps <- left_join(DE_protein_overlaps, temp, by = "Strain.Name") %>%
  dplyr::rename(anticodon_1 = anticodon,
         Amino_acid_1 = Amino_acid_1_letter,
         chr_1 = chromosome_letter,
         aa_type_1 = amino_acid_type,
         aa_charge_1 = amino_acid_charge)

## Repeat this for the columns only in master_dataset (U_34 and A_34)
temp <- master_dataset %>%
  dplyr::select(Strain.Name, contains("Nt_at"))
DE_protein_overlaps <- left_join(DE_protein_overlaps, temp, by = "Strain.Name") %>%
  dplyr::rename(strains_1 = Strain.Name,
         Nt_at_1_1 = Nt_at_1,
         Nt_at_2_1 = Nt_at_2,
         Nt_at_3_1 = Nt_at_3,
         Nt_at_4_1 = Nt_at_4,
         Nt_at_5_1 = Nt_at_5,
         Nt_at_6_1 = Nt_at_6,
         Nt_at_7_1 = Nt_at_7,
         Nt_at_8_1 = Nt_at_8,
         Nt_at_9_1 = Nt_at_9,
         Nt_at_10_1 = Nt_at_10,
         Nt_at_11_1 = Nt_at_11,
         Nt_at_12_1 = Nt_at_12,
         Nt_at_13_1 = Nt_at_13,
         Nt_at_14_1 = Nt_at_14,
         Nt_at_15_1 = Nt_at_15,
         Nt_at_16_1 = Nt_at_16,
         Nt_at_17_1 = Nt_at_17,
         Nt_at_18_1 = Nt_at_18,
         Nt_at_19_1 = Nt_at_19,
         Nt_at_20_1 = Nt_at_20,
         Nt_at_21_1 = Nt_at_21,
         Nt_at_22_1 = Nt_at_22,
         Nt_at_23_1 = Nt_at_23,
         Nt_at_24_1 = Nt_at_24,
         Nt_at_25_1 = Nt_at_25,
         Nt_at_26_1 = Nt_at_26,
         Nt_at_27_1 = Nt_at_27,
         Nt_at_28_1 = Nt_at_28,
         Nt_at_29_1 = Nt_at_29,
         Nt_at_30_1 = Nt_at_30,
         Nt_at_31_1 = Nt_at_31,
         Nt_at_32_1 = Nt_at_32,
         Nt_at_33_1 = Nt_at_33,
         Nt_at_34_1 = Nt_at_34,
         Nt_at_35_1 = Nt_at_35,
         Nt_at_36_1 = Nt_at_36,
         Nt_at_37_1 = Nt_at_37,
         Nt_at_38_1 = Nt_at_38,
         Nt_at_39_1 = Nt_at_39,
         Nt_at_40_1 = Nt_at_40,
         Nt_at_41_1 = Nt_at_41,
         Nt_at_42_1 = Nt_at_42,
         Nt_at_43_1 = Nt_at_43,
         Nt_at_44_1 = Nt_at_44,
         Nt_at_45_1 = Nt_at_45,
         Nt_at_46_1 = Nt_at_46,
         Nt_at_47_1 = Nt_at_47,
         Nt_at_48_1 = Nt_at_48,
         Nt_at_49_1 = Nt_at_49,
         Nt_at_50_1 = Nt_at_50,
         Nt_at_51_1 = Nt_at_51,
         Nt_at_52_1 = Nt_at_52,
         Nt_at_53_1 = Nt_at_53,
         Nt_at_54_1 = Nt_at_54,
         Nt_at_55_1 = Nt_at_55,
         Nt_at_56_1 = Nt_at_56,
         Nt_at_57_1 = Nt_at_57,
         Nt_at_58_1 = Nt_at_58,
         Nt_at_59_1 = Nt_at_59,
         Nt_at_60_1 = Nt_at_60,
         Nt_at_61_1 = Nt_at_61,
         Nt_at_62_1 = Nt_at_62,
         Nt_at_63_1 = Nt_at_63,
         Nt_at_64_1 = Nt_at_64,
         Nt_at_65_1 = Nt_at_65,
         Nt_at_66_1 = Nt_at_66,
         Nt_at_67_1 = Nt_at_67,
         Nt_at_68_1 = Nt_at_68,
         Nt_at_69_1 = Nt_at_69,
         Nt_at_70_1 = Nt_at_70,
         Strain.Name = strains_2)


# Match to strain_2
temp <- responsiveness %>%
  dplyr::select(Strain.Name, anticodon, Amino_acid_1_letter, chromosome_letter, amino_acid_type, amino_acid_charge)
DE_protein_overlaps <- left_join(DE_protein_overlaps, temp, by = "Strain.Name") %>%
  dplyr::rename(anticodon_2 = anticodon,
         Amino_acid_2 = Amino_acid_1_letter,
         aa_type_2 = amino_acid_type,
         aa_charge_2 = amino_acid_charge,
         chr_2 = chromosome_letter)

## Repeat this for the columns only in master_dataset (U_34 and A_34)
temp <- master_dataset %>%
  dplyr::select(Strain.Name, contains("Nt_at"))
DE_protein_overlaps <- left_join(DE_protein_overlaps, temp, by = "Strain.Name") %>%
  dplyr::rename(strains_2 = Strain.Name,
         Nt_at_1_2 = Nt_at_1,
         Nt_at_2_2 = Nt_at_2,
         Nt_at_3_2 = Nt_at_3,
         Nt_at_4_2 = Nt_at_4,
         Nt_at_5_2 = Nt_at_5,
         Nt_at_6_2 = Nt_at_6,
         Nt_at_7_2 = Nt_at_7,
         Nt_at_8_2 = Nt_at_8,
         Nt_at_9_2 = Nt_at_9,
         Nt_at_10_2 = Nt_at_10,
         Nt_at_11_2 = Nt_at_11,
         Nt_at_12_2 = Nt_at_12,
         Nt_at_13_2 = Nt_at_13,
         Nt_at_14_2 = Nt_at_14,
         Nt_at_15_2 = Nt_at_15,
         Nt_at_16_2 = Nt_at_16,
         Nt_at_17_2 = Nt_at_17,
         Nt_at_18_2 = Nt_at_18,
         Nt_at_19_2 = Nt_at_19,
         Nt_at_20_2 = Nt_at_20,
         Nt_at_21_2 = Nt_at_21,
         Nt_at_22_2 = Nt_at_22,
         Nt_at_23_2 = Nt_at_23,
         Nt_at_24_2 = Nt_at_24,
         Nt_at_25_2 = Nt_at_25,
         Nt_at_26_2 = Nt_at_26,
         Nt_at_27_2 = Nt_at_27,
         Nt_at_28_2 = Nt_at_28,
         Nt_at_29_2 = Nt_at_29,
         Nt_at_30_2 = Nt_at_30,
         Nt_at_31_2 = Nt_at_31,
         Nt_at_32_2 = Nt_at_32,
         Nt_at_33_2 = Nt_at_33,
         Nt_at_34_2 = Nt_at_34,
         Nt_at_35_2 = Nt_at_35,
         Nt_at_36_2 = Nt_at_36,
         Nt_at_37_2 = Nt_at_37,
         Nt_at_38_2 = Nt_at_38,
         Nt_at_39_2 = Nt_at_39,
         Nt_at_40_2 = Nt_at_40,
         Nt_at_41_2 = Nt_at_41,
         Nt_at_42_2 = Nt_at_42,
         Nt_at_43_2 = Nt_at_43,
         Nt_at_44_2 = Nt_at_44,
         Nt_at_45_2 = Nt_at_45,
         Nt_at_46_2 = Nt_at_46,
         Nt_at_47_2 = Nt_at_47,
         Nt_at_48_2 = Nt_at_48,
         Nt_at_49_2 = Nt_at_49,
         Nt_at_50_2 = Nt_at_50,
         Nt_at_51_2 = Nt_at_51,
         Nt_at_52_2 = Nt_at_52,
         Nt_at_53_2 = Nt_at_53,
         Nt_at_54_2 = Nt_at_54,
         Nt_at_55_2 = Nt_at_55,
         Nt_at_56_2 = Nt_at_56,
         Nt_at_57_2 = Nt_at_57,
         Nt_at_58_2 = Nt_at_58,
         Nt_at_59_2 = Nt_at_59,
         Nt_at_60_2 = Nt_at_60,
         Nt_at_61_2 = Nt_at_61,
         Nt_at_62_2 = Nt_at_62,
         Nt_at_63_2 = Nt_at_63,
         Nt_at_64_2 = Nt_at_64,
         Nt_at_65_2 = Nt_at_65,
         Nt_at_66_2 = Nt_at_66,
         Nt_at_67_2 = Nt_at_67,
         Nt_at_68_2 = Nt_at_68,
         Nt_at_69_2 = Nt_at_69,
         Nt_at_70_2 = Nt_at_70)

# Come up with columns that require matching between these 2 sets of them
DE_protein_overlaps <- DE_protein_overlaps %>%
  mutate(same_family = anticodon_1 == anticodon_2,
         same_amino_acid = Amino_acid_1 == Amino_acid_2,
         same_chromosome = chr_1 == chr_2,
         same_family_and_chr = same_family&same_chromosome,
         same_amino_acid_and_chr = same_amino_acid&same_chromosome,
         same_aa_type = aa_type_1 == aa_type_2,
         same_aa_charge = aa_charge_1 == aa_charge_2,
         Nt_at_1 = Nt_at_1_1 == Nt_at_1_2,
         Nt_at_2 = Nt_at_2_1 == Nt_at_2_2,
         Nt_at_3 = Nt_at_3_1 == Nt_at_3_2,
         Nt_at_4 = Nt_at_4_1 == Nt_at_4_2,
         Nt_at_5 = Nt_at_5_1 == Nt_at_5_2,
         Nt_at_6 = Nt_at_6_1 == Nt_at_6_2,
         Nt_at_7 = Nt_at_7_1 == Nt_at_7_2,
         Nt_at_8 = Nt_at_8_1 == Nt_at_8_2,
         Nt_at_9 = Nt_at_9_1 == Nt_at_9_2,
         Nt_at_10 = Nt_at_10_1 == Nt_at_10_2,
         Nt_at_11 = Nt_at_11_1 == Nt_at_11_2,
         Nt_at_12 = Nt_at_12_1 == Nt_at_12_2,
         Nt_at_13 = Nt_at_13_1 == Nt_at_13_2,
         Nt_at_14 = Nt_at_14_1 == Nt_at_14_2,
         Nt_at_15 = Nt_at_15_1 == Nt_at_15_2,
         Nt_at_16 = Nt_at_16_1 == Nt_at_16_2,
         Nt_at_17 = Nt_at_17_1 == Nt_at_17_2,
         Nt_at_18 = Nt_at_18_1 == Nt_at_18_2,
         Nt_at_19 = Nt_at_19_1 == Nt_at_19_2,
         Nt_at_20 = Nt_at_20_1 == Nt_at_30_2,
         Nt_at_21 = Nt_at_21_1 == Nt_at_21_2,
         Nt_at_22 = Nt_at_22_1 == Nt_at_22_2,
         Nt_at_23 = Nt_at_23_1 == Nt_at_23_2,
         Nt_at_24 = Nt_at_24_1 == Nt_at_24_2,
         Nt_at_25 = Nt_at_25_1 == Nt_at_25_2,
         Nt_at_26 = Nt_at_26_1 == Nt_at_26_2,
         Nt_at_27 = Nt_at_27_1 == Nt_at_27_2,
         Nt_at_28 = Nt_at_28_1 == Nt_at_28_2,
         Nt_at_29 = Nt_at_29_1 == Nt_at_29_2,
         Nt_at_30 = Nt_at_30_1 == Nt_at_30_2,
         Nt_at_31 = Nt_at_31_1 == Nt_at_31_2,
         Nt_at_32 = Nt_at_32_1 == Nt_at_32_2,
         Nt_at_33 = Nt_at_33_1 == Nt_at_33_2,
         Nt_at_34 = Nt_at_34_1 == Nt_at_34_2,
         Nt_at_35 = Nt_at_35_1 == Nt_at_35_2,
         Nt_at_36 = Nt_at_36_1 == Nt_at_36_2,
         Nt_at_37 = Nt_at_37_1 == Nt_at_37_2,
         Nt_at_38 = Nt_at_38_1 == Nt_at_38_2,
         Nt_at_39 = Nt_at_39_1 == Nt_at_39_2,
         Nt_at_40 = Nt_at_40_1 == Nt_at_40_2,
         Nt_at_41 = Nt_at_41_1 == Nt_at_41_2,
         Nt_at_42 = Nt_at_42_1 == Nt_at_42_2,
         Nt_at_43 = Nt_at_43_1 == Nt_at_43_2,
         Nt_at_44 = Nt_at_44_1 == Nt_at_44_2,
         Nt_at_45 = Nt_at_45_1 == Nt_at_45_2,
         Nt_at_46 = Nt_at_46_1 == Nt_at_46_2,
         Nt_at_47 = Nt_at_47_1 == Nt_at_47_2,
         Nt_at_48 = Nt_at_48_1 == Nt_at_48_2,
         Nt_at_49 = Nt_at_49_1 == Nt_at_49_2,
         Nt_at_50 = Nt_at_50_1 == Nt_at_50_2,
         Nt_at_51 = Nt_at_51_1 == Nt_at_51_2,
         Nt_at_52 = Nt_at_52_1 == Nt_at_52_2,
         Nt_at_53 = Nt_at_53_1 == Nt_at_53_2,
         Nt_at_54 = Nt_at_54_1 == Nt_at_54_2,
         Nt_at_55 = Nt_at_55_1 == Nt_at_55_2,
         Nt_at_56 = Nt_at_56_1 == Nt_at_56_2,
         Nt_at_57 = Nt_at_57_1 == Nt_at_57_2,
         Nt_at_58 = Nt_at_58_1 == Nt_at_58_2,
         Nt_at_59 = Nt_at_59_1 == Nt_at_59_2,
         Nt_at_60 = Nt_at_60_1 == Nt_at_60_2,
         Nt_at_61 = Nt_at_61_1 == Nt_at_61_2,
         Nt_at_62 = Nt_at_62_1 == Nt_at_62_2,
         Nt_at_63 = Nt_at_63_1 == Nt_at_63_2,
         Nt_at_64 = Nt_at_64_1 == Nt_at_64_2,
         Nt_at_65 = Nt_at_65_1 == Nt_at_65_2,
         Nt_at_66 = Nt_at_66_1 == Nt_at_66_2,
         Nt_at_67 = Nt_at_67_1 == Nt_at_67_2,
         Nt_at_68 = Nt_at_68_1 == Nt_at_68_2,
         Nt_at_69 = Nt_at_69_1 == Nt_at_69_2,
         Nt_at_70 = Nt_at_70_1 == Nt_at_70_2) %>%
  dplyr::select(-c(Nt_at_1_1, Nt_at_1_2, Nt_at_2_1, Nt_at_2_2, Nt_at_3_1, Nt_at_3_2, Nt_at_4_1, Nt_at_4_2, Nt_at_5_1, Nt_at_5_2, Nt_at_6_1, Nt_at_6_2, Nt_at_7_1, Nt_at_7_2, Nt_at_8_1, Nt_at_8_2, Nt_at_9_1, Nt_at_9_2, Nt_at_10_1, Nt_at_10_2, Nt_at_11_1, Nt_at_11_2, Nt_at_12_1, Nt_at_12_2, Nt_at_13_1, Nt_at_13_2, Nt_at_14_1, Nt_at_14_2, Nt_at_15_1, Nt_at_15_2, Nt_at_16_1, Nt_at_16_2, Nt_at_17_1, Nt_at_17_2, Nt_at_18_1, Nt_at_18_2, Nt_at_19_1, Nt_at_19_2, Nt_at_20_1, Nt_at_20_2, Nt_at_21_1, Nt_at_21_2, Nt_at_22_1, Nt_at_22_2, Nt_at_23_1, Nt_at_23_2, Nt_at_24_1, Nt_at_24_2, Nt_at_25_1, Nt_at_25_2, Nt_at_26_1, Nt_at_26_2, Nt_at_27_1, Nt_at_27_2, Nt_at_28_1, Nt_at_28_2, Nt_at_29_1, Nt_at_29_2, Nt_at_30_1, Nt_at_30_2, Nt_at_31_1, Nt_at_31_2, Nt_at_32_1, Nt_at_32_2, Nt_at_33_1, Nt_at_33_2, Nt_at_34_1, Nt_at_34_2, Nt_at_35_1, Nt_at_35_2, Nt_at_36_1, Nt_at_36_2, Nt_at_37_1, Nt_at_37_2, Nt_at_38_1, Nt_at_38_2, Nt_at_39_1, Nt_at_39_2, Nt_at_40_1, Nt_at_40_2, Nt_at_41_1, Nt_at_41_2, Nt_at_42_1, Nt_at_42_2, Nt_at_43_1, Nt_at_43_2, Nt_at_44_1, Nt_at_44_2, Nt_at_45_1, Nt_at_45_2, Nt_at_46_1, Nt_at_46_2, Nt_at_47_1, Nt_at_47_2, Nt_at_48_1, Nt_at_48_2, Nt_at_49_1, Nt_at_49_2, Nt_at_50_1, Nt_at_50_2, Nt_at_51_1, Nt_at_51_2, Nt_at_52_1, Nt_at_52_2, Nt_at_53_1, Nt_at_53_2, Nt_at_54_1, Nt_at_54_2, Nt_at_55_1, Nt_at_55_2, Nt_at_56_1, Nt_at_56_2, Nt_at_57_1, Nt_at_57_2, Nt_at_58_1, Nt_at_58_2, Nt_at_59_1, Nt_at_59_2, Nt_at_60_1, Nt_at_60_2, Nt_at_61_1, Nt_at_61_2, Nt_at_62_1, Nt_at_62_2, Nt_at_63_1, Nt_at_63_2, Nt_at_64_1, Nt_at_64_2, Nt_at_65_1, Nt_at_65_2, Nt_at_66_1, Nt_at_66_2, Nt_at_67_1, Nt_at_67_2, Nt_at_68_1, Nt_at_68_2, Nt_at_69_1, Nt_at_69_2, Nt_at_70_1, Nt_at_70_2))

# Get columns based on strain_1 and strain_2, but which reorganize this: the one with more DEPs to one column, the one with less DEPs to the other
# Just so that I can check the overlap_size/amount of DEPs in the KO strain with less out of the pair. Not sure if too important but oh well
DE_protein_overlaps <- DE_protein_overlaps %>%
  rowwise() %>%
  mutate(Strain_more_DEPs = max(protein_number_1, protein_number_2),
         Strain_less_DEPs = min(protein_number_1, protein_number_2),
         Ratio_more_to_less_DEPs = Strain_more_DEPs/Strain_less_DEPs)

# Add columns where I combine the strings for the anticodons and amino acids for the 2 strains (always using sort() before so that they are unique)
DE_protein_overlaps <- DE_protein_overlaps %>%
  rowwise() %>%
  mutate(both_anticodons = paste(sort(c(anticodon_1, anticodon_2)), collapse = "-"),
         both_amino_acids = paste(sort(c(Amino_acid_1, Amino_acid_2)), collapse = "-"),
         both_aa_types = paste(sort(c(aa_type_1, aa_type_2)), collapse = "-"),
         both_aa_charges = paste(sort(c(aa_charge_1, aa_charge_2)), collapse = "-"))

# Put columns with protein names as the last ones
DE_protein_overlaps <- DE_protein_overlaps %>%
  relocate(protein_names_1, .after = last_col()) %>%
  relocate(protein_names_2, .after = last_col()) %>%
  relocate(overlap, .after = last_col())
```

Save this dataset as of now 
```{r}
fwrite(DE_protein_overlaps, paste(base_dir, "tRNA_KOs/Data/compare_DEPs_across_KOs/DE_protein_overlaps_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".tsv", sep=""))
```



### 6.3.3. Explore large intersections
There are only 42 such pairs out of 19,306 combinations - at alpha = 0.01, idk over which Jaccard Index
At alpha = 0.05 and JI >= 0.5, there are 29???
```{r}
# Subset the dataframe
high_jaccard_df <- DE_protein_overlaps %>%
  filter(Jaccard_index >= 0.5) %>%
  mutate(same_family = case_when(same_family == T ~ "Yes",
                                 TRUE ~ "No"),
         same_amino_acid = case_when(same_amino_acid == T ~ "Yes",
                                 TRUE ~ "No"))

# Look at the strains in this subset of the data
sort(table(high_jaccard_df$strains_1))
sort(table(high_jaccard_df$strains_2))

# Look at the anticodons and amino acids in this subset of the data
sort(table(high_jaccard_df$both_anticodons))
sort(table(high_jaccard_df$both_amino_acids))

# Look at the amino acid types and charges in this subset of the data
sort(table(high_jaccard_df$both_aa_types))
sort(table(high_jaccard_df$both_aa_charges))
```

Plot
```{r}
# Barplot of these strains by amino acid types
ggplot(data = high_jaccard_df, aes(x = fct_rev(fct_infreq(both_aa_types)))) +
  geom_bar() +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  labs(title = "Distribution of the KO strain pairs with a Jaccard Index > 0.5",
       subtitle = "Classified based on amino acid types of the 2 KOs") +
  xlab("Amino acid types") +
  ylab("Count")

# Barplot of these strains by amino acid charges
ggplot(data = high_jaccard_df, aes(x = fct_rev(fct_infreq(both_aa_charges)))) +
  geom_bar() +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  labs(title = "Distribution of the KO strain pairs with a Jaccard Index > 0.5",
       subtitle = "Classified based on amino acid charges of the 2 KOs") +
  xlab("Amino acid charges") +
  ylab("Count")

# Barplot of these strains by whether they have the same anticodon
ggplot(data = high_jaccard_df, aes(x = fct_rev(fct_infreq(same_family)))) +
  geom_bar() +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  labs(title = "Distribution of the KO strain pairs with a Jaccard Index > 0.5",
       subtitle = "Classified based on whether the 2 KOs were for the same anticodon") +
  xlab("Same family?") +
  ylab("Count")

# Barplot of these strains by whether they carry the same amino acid
ggplot(data = high_jaccard_df, aes(x = fct_rev(fct_infreq(same_amino_acid)))) +
  geom_bar() +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  labs(title = "Distribution of the KO strain pairs with a Jaccard Index > 0.5",
       subtitle = "Classified based on whether the 2 KOs were for tRNAs carrying the same amino acid") +
  xlab("Same amino acid?") +
  ylab("Count")
```

Go into the top pairs with the largest JIs and look at what are the proteins in them - does it have a biological meaning or is it just random stuff/survival stuff/whatever?
```{r}
# Since I want to do enrichment analysis below, I need to load some stuff beforehand - based on the enrichment analysis file
## List of dataframes with the proteins that were DE in each KO strain - at alpha = 0.01 - remove emtpy vectors
de_proteins_list <- fromJSON(paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/de_proteins_list_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""))
de_proteins_list <- Filter(function(x) length(x) > 0, de_proteins_list)

# Full Entrez ID dataframe, with all genes
entrez_db <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/entrez_reference.txt", sep="")))

## Define background
temp <- data.frame("Protein_stable_ID" = de_proteins_list[["WT"]])
temp <- left_join(temp, entrez_db, by = "Protein_stable_ID")
my_universe <- temp$`NCBI_gene_(formerly_Entrezgene)_ID`

# Load YeastMine dataset
yeastmine <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))




# Prepare for iteration
N <- 10                                       # This sets the limit at JI > 0.65, fair enough I guess?
high_jaccard_ea_list <- list()
high_jaccard_protein_names <- list()
high_jaccard_protein_description <- list()
high_jaccard_df <- high_jaccard_df %>%
  arrange(desc(Jaccard_index))


for (i in 1:N) {
  strain_1 <- high_jaccard_df$strains_1[i]
  strain_2 <- high_jaccard_df$strains_2[i]
  
  # Grab the names of the proteins in the intersection
  proteins <- intersect(de_proteins_list[[strain_1]], de_proteins_list[[strain_2]])
  
  # Do an enrichment analysis
  proteins_detected <- data.frame("Protein_stable_ID" = proteins)
  proteins_detected <- left_join(proteins_detected, entrez_db, by = "Protein_stable_ID")
  proteins_detected <- proteins_detected$`NCBI_gene_(formerly_Entrezgene)_ID`
  
  go_results <- enrichGO(gene = proteins_detected, 
                           OrgDb = "org.Sc.sgd.db", 
                           keyType = "ENTREZID", 
                           ont = "ALL", 
                           universe = my_universe,
                           maxGSSize = 200)
  high_jaccard_ea_list[[i]] <- as.data.frame(go_results)
  
  
  # Save the full names of the proteins (normal ones and descriptive ones)
  temp <- data.frame("Gene.secondaryIdentifier" = proteins)
  temp <- left_join(temp, yeastmine, by = "Gene.secondaryIdentifier")
  high_jaccard_protein_description[[i]] <- temp[["Gene.name"]]
  
  high_jaccard_protein_names[[i]] <- proteins
}

# Get a version of the high_jaccard_df from which I can take a screenshot for my slides
temp_2 <- high_jaccard_df %>%
  dplyr::select(strains_1, strains_2, protein_number_1, protein_number_2, overlap_size, Jaccard_index)

# Summary of the proteins across the N intersections
sort(table(unlist(high_jaccard_protein_description)))

# Get a summary dataframe with the protein names and the description, for a slide
temp <- data.frame(table(unlist(high_jaccard_protein_names)))
colnames(temp) <- c("Gene.secondaryIdentifier", "Freq")
temp <- left_join(temp, yeastmine, by = "Gene.secondaryIdentifier") %>%
  dplyr::select(Gene.secondaryIdentifier, Freq, Gene.name)

# Summarize the pathways found in the EA
temp_list <- c()
for (i in 1:length(high_jaccard_ea_list)) {
  temp_list[[i]] <- as.character(high_jaccard_ea_list[[i]]$Description)
}
sort(table(unlist(temp_list)))
```


### 6.3.4. Test and plot for Jaccard Index across different variables (same amino acid, same anticodon, same chromosome, same amino acid charge, same amino acid type...) - variables with 2 levels
```{r}
#' This functions needs to receive as input a dataframe where we want to perform the test for all the columns! Except for one column which is the one containing the Jaccard Index, and which needs to be called "Jaccard_index"
#' 
perform_chi_square_and_wmw_return_pvalues_and_effect_sizes <- function(DE_protein_overlaps) {
  # Create some vectors to collect the outcome
  variables <- c()
  p_vals_chi_square <- c()
  true_to_false_ratio_chi_square <- c()
  p_vals_wmw <- c()
  effect_size_directions_wmw <- c()
  perc_same_across_all_pairs <- c()
  
  
  # Iterate over the columns of the dataframe, performing the tests for each of them
  columns <- colnames(DE_protein_overlaps)
  columns <- columns[!columns %in% c("Jaccard_index")]
  for (i in 1:length(columns)) {
    # Save the name of the variable we are testing for
    variable <- columns[i]
    variables <- c(variables, variable)
    
    ## Chi-square test for the proportion of 0s in each group
    data <- table(as.numeric(!(DE_protein_overlaps$Jaccard_index == 0)), as.factor(DE_protein_overlaps[[variable]]))
    p_vals_chi_square <- c(p_vals_chi_square, chisq.test(data)$p.value)
    
    ## Proportion of 0s in each group
    true_group_zero_prop <- sum(DE_protein_overlaps$Jaccard_index[DE_protein_overlaps[[variable]] == T] == 0, na.rm = T)/
      sum(DE_protein_overlaps[[variable]] == T)
    false_group_zero_prop <- sum(DE_protein_overlaps$Jaccard_index[DE_protein_overlaps[[variable]] == F] == 0, na.rm = T)/
      sum(DE_protein_overlaps[[variable]] == F)
    true_to_false_ratio <- true_group_zero_prop/false_group_zero_prop                 
    # Changed this, now it represents the % increase (or decrease) in the proportion of 0s in the TRUE group w.r.t. the FALSE group
    if (true_to_false_ratio > 1) {
      true_to_false_ratio_chi_square <- c(true_to_false_ratio_chi_square, (true_to_false_ratio-1)*100)
    } else {
      true_to_false_ratio_chi_square <- c(true_to_false_ratio_chi_square, (1-true_to_false_ratio)*100)
    }
    
    
    ## Wilcoxon-Mann Whitney test for the non-zero values
    temp <- DE_protein_overlaps %>%
      filter(Jaccard_index != 0)
    x <- temp$Jaccard_index[temp[colnames(temp) == variable] == T]
    y <- temp$Jaccard_index[temp[colnames(temp) == variable] == F]
    p_vals_wmw <- c(p_vals_wmw, wilcox.test(x, y)$p.value)
    
    ## Wilcoxon-Mann Whitney effect size - TURNED THIS INTO "PERCENTAGE" EFFECT SIZE BY DIVIDING BY THE MEAN JACCARD INDEX IN THE GROUP WHERE THE PAIRS OF KOS DO NOT SHARE THE CHARACTERISTIC ("FALSE" GROUP) SO AS TO TRY TO MAKE THIS MORE INTERPRETABLE
    effect_size_directions_wmw <- c(effect_size_directions_wmw, ((mean(x)-mean(y))/mean(y))*100)
    
    # Grab a value which shows the percentage of pairs across which each variable was TRUE
    perc_same_across_all_pairs <- c(perc_same_across_all_pairs, sum(DE_protein_overlaps[[variable]] == T)/nrow(DE_protein_overlaps))
  }
  
  # Put it all together and return it
  p_values_chisq_and_wmw <- data.frame(variables, p_vals_chi_square, true_to_false_ratio_chi_square, p_vals_wmw, effect_size_directions_wmw,
                                       perc_same_across_all_pairs)
  return(p_values_chisq_and_wmw)
}


# Define the columns we want to provide as input for the above defined function - to test (Chi-square and WMW) the Jaccard Indexes across their levels
df <- DE_protein_overlaps %>%
  dplyr::select(Jaccard_index,
                same_amino_acid,
                same_family, 
                same_chromosome,
                same_amino_acid_and_chr, 
                same_family_and_chr,
                same_aa_charge,
                same_aa_type,
                Nt_at_1,
                Nt_at_2,
                Nt_at_3,
                Nt_at_4,
                Nt_at_5,
                Nt_at_6,
                Nt_at_7,
                Nt_at_8,
                Nt_at_9,
                Nt_at_10,
                Nt_at_11,
                Nt_at_12,
                Nt_at_13,
                Nt_at_14,
                Nt_at_15,
                Nt_at_16,
                Nt_at_17,
                Nt_at_18,
                Nt_at_19,
                Nt_at_20,
                Nt_at_21,
                Nt_at_22,
                Nt_at_23,
                Nt_at_24,
                Nt_at_25,
                Nt_at_26,
                Nt_at_27,
                Nt_at_28,
                Nt_at_29,
                Nt_at_30,
                Nt_at_31,
                Nt_at_32,
                Nt_at_33,
                Nt_at_34,
                Nt_at_35,
                Nt_at_36,
                Nt_at_37,
                Nt_at_38,
                Nt_at_39,
                Nt_at_40,
                Nt_at_41,
                Nt_at_42,
                Nt_at_43,
                Nt_at_44,
                Nt_at_45,
                Nt_at_46,
                Nt_at_47,
                Nt_at_48,
                Nt_at_49,
                Nt_at_40,
                Nt_at_51,
                Nt_at_52,
                Nt_at_53,
                Nt_at_54,
                Nt_at_55,
                Nt_at_56,
                Nt_at_57,
                Nt_at_58,
                Nt_at_59,
                Nt_at_60,
                Nt_at_61,
                Nt_at_62,
                Nt_at_63,
                Nt_at_64,
                Nt_at_65,
                Nt_at_66,
                Nt_at_67,
                Nt_at_68,
                Nt_at_69,
                Nt_at_70)

# Perform testing and save p-values and effect sizes
p_values_chisq_and_wmw <- perform_chi_square_and_wmw_return_pvalues_and_effect_sizes(df)

# Correct the p-values with BH
p_values_chisq_and_wmw$p_vals_chi_square_adj <- p.adjust(p_values_chisq_and_wmw$p_vals_chi_square, method = "BH")
p_values_chisq_and_wmw$p_vals_wmw_adj <- p.adjust(p_values_chisq_and_wmw$p_vals_wmw, method = "BH")






# WHEN USING ALL NUCLEOTIDE POSITIONS

# Keep only significant rows
p_values_large <- p_values_chisq_and_wmw %>%
  filter(p_vals_wmw_adj < alpha) %>%
  dplyr::select(-c(p_vals_chi_square, p_vals_wmw)) %>%
  arrange(p_vals_chi_square_adj)

p_values_print <- p_values_large %>%
  dplyr::select(-(perc_same_across_all_pairs))

# Print the resulting table to LaTex
print(xtable(p_values_print, label = "p_values_table_with_Nts", digits = c(9)), include.rownames = F)








# WHEN NOT USING ALL NUCLEOTIDE POSITIONS

## Filter out all rows referring to the nucleotides
#p_values_chisq_and_wmw <- p_values_chisq_and_wmw %>%
#  filter(!(grepl("Nt_at", variables))) %>%
#  dplyr::select(-c(p_vals_chi_square, p_vals_wmw, perc_same_across_all_pairs))
#
## Make the row descriptions a bit prettier - colnames I need to fix directly in LaTex - this only functions when I am not using all nucleotide #positions
#p_values_chisq_and_wmw$variables <- c("Carried amino acid", "Anticodon", "Chromosome", "Carried amino acid and chromosome", "Anticodon and chromosome",
#                                      "Amino acid charge", "Amino acid type")
#
## Print it to take it to LaTex
#print(xtable(p_values_chisq_and_wmw, label = "p_values_table", digits = c(8)), include.rownames=FALSE)
```

Manually check the effect of Nt_at_21, looking at what happens exactly for each Nt that can be there - TO DO
```{r}
D
```

Relate effect of Nt_at_whatever on Jaccard Index by conservation of that Nt position
```{r}
# Look at correlation first of all
temp <- p_values_large 
rownames(temp) <- temp[,1]
temp <- temp[,-1]
cor_mat <- round(cor(temp, use = "pairwise.complete"), 2)


# Look at how common each nucleotide is in each of some of the most interesting positions
table(master_dataset$Nt_at_21)
table(master_dataset$Nt_at_1)
table(master_dataset$Nt_at_33)


# Plots
ggplot(data = p_values_large, aes(x = perc_same_across_all_pairs, y = effect_size_directions_wmw)) +
  geom_point() +
  theme_light() +
  geom_text_repel(data = subset(p_values_large, effect_size_directions_wmw > 20 | perc_same_across_all_pairs > 0.45), 
                  aes(x = perc_same_across_all_pairs, y = effect_size_directions_wmw, label = variables))
```



## 6.4. Explore intersections between major KOs inside each family (only families with more than 1 major KO)
Prepare data
```{r}
# Load protein overlaps dataset created in previous section, with all possible intersections
DE_protein_overlaps <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/compare_DEPs_across_KOs/DE_protein_overlaps_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".tsv", sep="")))

# Master dataset
master_dataset <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/basic/master_tRNA_dataset.csv", sep = "")))
```

Got a bit side-tracked, exploring the correlation between the average nDEP in the pair and the JI
```{r}
# Keep only pairs where the 2 KOs belong to the same family
DE_protein_overlaps_same_family <- DE_protein_overlaps %>%
  filter(anticodon_1 == anticodon_2)

# JI vs. average nDEP
ggplot(data = DE_protein_overlaps, aes(x = protein_number_avg, y = Jaccard_index)) +
  geom_point(size = 0.2) +
  theme_light()

# JI vs. average nDEP - color by same family
ggplot(data = DE_protein_overlaps, aes(x = protein_number_avg, y = Jaccard_index, col = same_family)) +
  geom_point(size = 0.2) +
  theme_light()

# JI vs. average nDEP - for those pairs in the same family only
ggplot(data = DE_protein_overlaps_same_family, aes(x = protein_number_avg, y = Jaccard_index)) +
  geom_point(size = 1) +
  theme_light()
```

Analyze
```{r}
# This is what happens if I filter based on major - minor (defined by me)
DE_protein_overlaps_major_within_family <- DE_protein_overlaps %>%
  filter(anticodon_1 == anticodon_2,
         Gene_type_1 == "Major" & Gene_type_2 == "Major")

# Get a version of this which I can screenshot for a slide
temp <- DE_protein_overlaps_major_within_family %>%
  dplyr::select(strains_1, strains_2, protein_number_1, protein_number_2, overlap_size, Jaccard_index)

# Grab the strains in here and put them into a vector so I can filter the EA results by them
paired_major_strains <- sort(unique(c(as.character(DE_protein_overlaps_major_within_family$strains_1), as.character(DE_protein_overlaps_major_within_family$strains_2))))
```

Look at the EA results for these strains
```{r}
# Load GO EA results - this one doesn't work recently because I haven't been running the GO analysis! Only the GSEA, with both GO and KEGG annotations
go_results_list <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_results_list_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), simplifyVector = T)

# Load GSEA results (GO and KEGG)
kegg_gsea_results <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/kegg_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold),
                                            "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), simplifyVector = T)
go_gsea_results <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold),
                                            "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), simplifyVector = T)

# Keep only those we are interested in
go_results_list_filtered <- go_results_list[names(go_results_list) %in% paired_major_strains]
kegg_gsea_results_filtered <- kegg_gsea_results[names(kegg_gsea_results) %in% paired_major_strains]
go_gsea_results_filtered <- go_gsea_results[names(go_gsea_results) %in% paired_major_strains]
```



Produce LaTex table with significant pathways in pairs of KOs with the same anticodon
  - GO
```{r}
N <- 10

# Load the GO GSEA results produced in that file
go_gsea_results <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), simplifyVector = T)

# For GO GSEA results
## Get the unique codons to iterate over
codons <- unique(sapply(names(go_gsea_results), extract_anticodon_from_trna_name))

# Iterate over codons and create a table for each pair of KOs (for those anticodons for which we have more than 1 KO)
for (i in 1:length(codons)) {
  codon <- codons[i]
  temp_go_gsea_results <- go_gsea_results[grepl(codon, names(go_gsea_results))]
  
  # Proceed only if there are GSEA results for at least 2 KOs with this anticodon, and if at least 2 of them are major
  if ((length(temp_go_gsea_results) > 1) & sum(names(temp_go_gsea_results) %in% paired_major_strains) > 1) {
    temp_list <- list()
    temp_go_gsea_results <- temp_go_gsea_results[names(temp_go_gsea_results) %in% paired_major_strains]    # Remove the non-major subunits
    for (j in 1:length(temp_go_gsea_results)) {
      temp_go_gsea_results[[j]] <- temp_go_gsea_results[[j]][order(temp_go_gsea_results[[j]]$padj),]       # Order by increasing p-adj
      temp_go_gsea_results[[j]] <- temp_go_gsea_results[[j]][1:N,]                                         # Grab only the first N pathways
      temp_list[[names(temp_go_gsea_results)[j]]] <- sort(temp_go_gsea_results[[j]]$pathway)               # Grab the pathway names and order there them                                                                                                                     alphabetically, which makes it easier to compare them                                                                                                             between KO strains
    }
    out_df <- data.frame(matrix(ncol = 0, nrow = max(sapply(temp_list, length))))
    for (j in 1:length(temp_list)) {
      new_col <- temp_list[[j]]
      if (length(new_col) == max(sapply(temp_list, length))) {
        out_df[,j] <- new_col
      } else {
        out_df[,j] <- c(new_col, rep(NA, max(sapply(temp_list, length))-length(new_col)))
      }
    }
    colnames(out_df) <- names(temp_list)
    print(xtable(out_df), include.rownames=FALSE)
  }
}
```

  - KEGG
```{r}
N <- 10

# Load the GO GSEA results produced in that file
kegg_gsea_results <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/kegg_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), simplifyVector = T)

# For GO GSEA results
## Get the unique codons to iterate over
codons <- unique(sapply(names(kegg_gsea_results), extract_anticodon_from_trna_name))

# Iterate over codons and create a table for each pair of KOs (for those anticodons for which we have more than 1 KO)
for (i in 1:length(codons)) {
  codon <- codons[i]
  temp_kegg_gsea_results <- kegg_gsea_results[grepl(codon, names(kegg_gsea_results))]
  
  # Proceed only if there are GSEA results for at least 2 KOs with this anticodon, and if at least 2 of them are major
  if ((length(temp_kegg_gsea_results) > 1) & sum(names(temp_kegg_gsea_results) %in% paired_major_strains) > 1) {
    temp_list <- list()
    temp_kegg_gsea_results <- temp_kegg_gsea_results[names(temp_kegg_gsea_results) %in% paired_major_strains]    # Remove the non-major subunits
    for (j in 1:length(temp_kegg_gsea_results)) {
      temp_kegg_gsea_results[[j]] <- temp_kegg_gsea_results[[j]][order(temp_kegg_gsea_results[[j]]$padj),]       # Order by increasing p-adj
      temp_kegg_gsea_results[[j]] <- temp_kegg_gsea_results[[j]][1:N,]                                         # Grab only the first N pathways
      temp_list[[names(temp_kegg_gsea_results)[j]]] <- sort(temp_kegg_gsea_results[[j]]$pathway)               # Grab the pathway names and order there them                                                                                                                     alphabetically, which makes it easier to compare them                                                                                                             between KO strains
    }
    out_df <- data.frame(matrix(ncol = 0, nrow = max(sapply(temp_list, length))))
    for (j in 1:length(temp_list)) {
      new_col <- temp_list[[j]]
      if (length(new_col) == max(sapply(temp_list, length))) {
        out_df[,j] <- new_col
      } else {
        out_df[,j] <- c(new_col, rep(NA, max(sapply(temp_list, length))-length(new_col)))
      }
    }
    colnames(out_df) <- names(temp_list)
    print(xtable(out_df), include.rownames=FALSE)
  }
}
```





# 6.5. Get the top 50 proteins between major KOs of the same family and compare their overlap
Cannot really do it based on the scores (as Markus suggested) for now since the scores for most of the strains are equal for like 90% or more of the proteins - maybe should fix that? But for now I'm doing it based on DE proteins, sorry, don't have time for this since I have to present in the group meeting soon
```{r}

```


Get the lists of IDs for ChatGPT, so it can go through the SGD pages for me and summarize what's going on with each strain
```{r}
for (i in 1:nrow(DE_protein_overlaps_major_within_family)) {
  strain_1 <- DE_protein_overlaps_major_within_family$strains_1[i]
  strain_2 <- DE_protein_overlaps_major_within_family$strains_2[i]
  
  print(glue("RESULST FOR THE FOLLOWING STRAIN PAIR: {strain_1}{strain_2}"))
  
  temp_1 <- da[[strain_1]] %>%
    filter(adj.P.Val < 0.05 & abs(logFC) > 0.5)
  
  temp_2 <- da[[strain_2]] %>%
    filter(adj.P.Val < 0.05 & abs(logFC) > 0.5)
  
  
  print(glue("{strain_1}"))
  print(cat(rownames(temp_1), sep = ", "))
  
  print(glue("{strain_2}"))
  print(cat(rownames(temp_2), sep=", "))
}
```













































